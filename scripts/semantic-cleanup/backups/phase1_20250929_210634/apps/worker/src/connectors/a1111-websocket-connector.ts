// A1111 WebSocket Connector
// Connects to local Automatic1111 WebUI API for stable diffusion image generation

import { BaseConnector, HealthCheckCapabilities } from './base-connector.js';
import {
  JobData,
  JobResult,
  ProgressCallback,
  ServiceInfo,
  ConnectorConfig,
  logger,
  JobProgress,
} from '@emp/core';
import axios, { AxiosInstance } from 'axios';

export interface A1111JobData extends JobData {
  prompt: string;
  negative_prompt?: string;
  width?: number;
  height?: number;
  steps?: number;
  cfg_scale?: number;
  sampler_name?: string;
  scheduler?: string;
  seed?: number;
  batch_size?: number;
  n_iter?: number;
  restore_faces?: boolean;
  tiling?: boolean;
  do_not_save_samples?: boolean;
  do_not_save_grid?: boolean;
  eta?: number;
  denoising_strength?: number;
  s_min_uncond?: number;
  s_churn?: number;
  s_tmax?: number;
  s_tmin?: number;
  s_noise?: number;
  override_settings?: Record<string, any>;
  override_settings_restore_afterwards?: boolean;
  refiner_checkpoint?: string;
  refiner_switch_at?: number;
  disable_extra_networks?: boolean;
  firstpass_image?: string;
  comments?: Record<string, any>;
}

export interface A1111Result extends JobResult {
  images: string[];
  parameters: Record<string, any>;
  info: string;
}

export default class A1111WebSocketConnector extends BaseConnector {
  service_type = 'a1111' as const;
  version = '1.0.0';
  
  private client: AxiosInstance;
  private baseUrl: string;
  private connected: boolean = false;
  private healthCheckInterval?: NodeJS.Timeout;

  constructor(
    connectorId: string,
    config?: {
      host?: string;
      port?: number;
      secure?: boolean;
    }
  ) {
    super(connectorId);
    
    const port = config?.port || parseInt(process.env.A1111_PORT || process.env.A1111_BASE_PORT || '7860');
    const host = config?.host || process.env.A1111_HOST || 'localhost';
    this.baseUrl = `http://${host}:${port}`;

    this.client = axios.create({
      baseURL: this.baseUrl,
      timeout: 60000, // 60 second timeout for API requests
      headers: {
        'Content-Type': 'application/json',
      },
    });

    logger.info('A1111 WebSocket Connector initialized', {
      baseUrl: this.baseUrl,
      connectorId: this.connector_id,
    });
  }

  static getRequiredEnvVars(): Record<string, string> {
    return {
      A1111_PORT: '${A1111_BASE_PORT:-7860}',
      A1111_HOST: '${A1111_HOST:-localhost}',
      COMFYUI_CHECKPOINTS_PATH: '${COMFYUI_CHECKPOINTS_PATH:-/workspace/ComfyUI/models/checkpoints}',
    };
  }

  // Required abstract method implementations
  protected async initializeService(): Promise<void> {
    logger.info('Initializing A1111 service...');
    
    try {
      await this.waitForService();
      this.connected = true;
      this.startHealthChecks();
      logger.info('A1111 service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize A1111 service:', error);
      throw error;
    }
  }

  protected async cleanupService(): Promise<void> {
    logger.info('Cleaning up A1111 service...');
    
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = undefined;
    }
    
    this.connected = false;
    logger.info('A1111 service cleanup completed');
  }

  protected async processJobImpl(
    jobData: JobData,
    progressCallback: ProgressCallback
  ): Promise<JobResult> {
    const a1111JobData = jobData as A1111JobData;
    
    logger.info('Processing A1111 job', { 
      jobId: jobData.id,
      prompt: a1111JobData.prompt.substring(0, 100) + '...'
    });

    try {
      // Call progress callback to indicate job started
      await progressCallback({
        job_id: jobData.id,
        progress: 0,
        message: 'Starting image generation...',
      });

      // Prepare the request payload
      const payload = this.buildPayload(a1111JobData);
      
      // Submit job to A1111
      const response = await this.client.post('/sdapi/v1/txt2img', payload);
      
      if (response.status !== 200) {
        throw new Error(`A1111 API returned status ${response.status}: ${response.statusText}`);
      }

      const result = response.data;
      
      if (!result.images || result.images.length === 0) {
        throw new Error('No images generated by A1111');
      }

      // Call progress callback to indicate completion
      await progressCallback({
        job_id: jobData.id,
        progress: 100,
        message: `Generated ${result.images.length} image(s)`,
      });

      logger.info('A1111 job completed successfully', {
        jobId: jobData.id,
        imageCount: result.images.length
      });

      const processingTimeMs = Date.now() - Date.parse(jobData.metadata?.created_at as string || new Date().toISOString());
      
      return {
        success: true,
        data: result,
        processing_time_ms: processingTimeMs,
        service_metadata: {
          service_version: this.version,
          service_type: this.service_type,
          model_used: payload.override_settings?.sd_model_checkpoint || 'default',
        },
      };

    } catch (error) {
      logger.error('A1111 job processing failed:', error);
      
      // Call progress callback to indicate error
      await progressCallback({
        job_id: jobData.id,
        progress: 0,
        message: `Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      });

      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        processing_time_ms: Date.now() - Date.parse(jobData.metadata?.created_at as string || new Date().toISOString()),
        service_metadata: {
          service_version: this.version,
          service_type: this.service_type,
          processing_stats: {
            error_type: error instanceof Error ? error.constructor.name : 'UnknownError',
          },
        },
      };
    }
  }

  async checkHealth(): Promise<boolean> {
    try {
      const response = await this.client.get('/sdapi/v1/options', { timeout: 5000 });
      return response.status === 200;
    } catch (error) {
      logger.debug('A1111 health check failed:', error);
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    try {
      const response = await this.client.get('/sdapi/v1/sd-models');
      return response.data?.map((model: any) => model.model_name) || [];
    } catch (error) {
      logger.error('Failed to get available models:', error);
      return [];
    }
  }

  async getServiceInfo(): Promise<ServiceInfo> {
    try {
      const configResponse = await this.client.get('/sdapi/v1/options');
      const samplerResponse = await this.client.get('/sdapi/v1/samplers');
      const modelResponse = await this.client.get('/sdapi/v1/sd-models');

      return {
        service_name: 'Automatic1111 WebUI',
        service_version: 'unknown', // A1111 doesn't expose version in API
        base_url: this.baseUrl,
        status: this.connected ? 'online' : 'offline',
        capabilities: {
          supported_formats: ['png', 'jpg'],
          supported_models: modelResponse.data?.map((model: any) => model.model_name) || [],
          features: [
            'txt2img',
            'img2img',
            'stable_diffusion',
            'sampling',
            'model_switching',
          ],
        },
      };
    } catch (error) {
      logger.error('Failed to get service info:', error);
      return {
        service_name: 'Automatic1111 WebUI',
        service_version: 'unknown',
        base_url: this.baseUrl,
        status: 'error',
        capabilities: {
          supported_formats: [],
          supported_models: [],
          features: [],
        },
      };
    }
  }

  async canProcessJob(jobData: JobData): Promise<boolean> {
    const a1111Data = jobData as A1111JobData;
    
    if (!a1111Data.prompt || typeof a1111Data.prompt !== 'string') {
      return false;
    }

    if (a1111Data.prompt.trim().length === 0) {
      return false;
    }

    // Check if service is healthy
    return await this.checkHealth();
  }

  async cancelJob(jobId: string): Promise<void> {
    try {
      await this.client.post('/sdapi/v1/interrupt');
      logger.info(`A1111 job ${jobId} cancellation requested`);
    } catch (error) {
      logger.error(`Failed to cancel A1111 job ${jobId}:`, error);
      throw error;
    }
  }

  async updateConfiguration(config: ConnectorConfig): Promise<void> {
    // Update connector configuration if needed
    logger.info('A1111 connector configuration updated');
  }

  getConfiguration(): ConnectorConfig {
    return {
      connector_id: this.connector_id,
      service_type: this.service_type,
      base_url: this.baseUrl,
      timeout_seconds: 60,
      retry_attempts: 3,
      retry_delay_seconds: 2,
      health_check_interval_seconds: 30,
      max_concurrent_jobs: 5,
    };
  }

  private buildPayload(jobData: A1111JobData): any {
    return {
      prompt: jobData.prompt,
      negative_prompt: jobData.negative_prompt || '',
      width: jobData.width || 512,
      height: jobData.height || 512,
      steps: jobData.steps || 20,
      cfg_scale: jobData.cfg_scale || 7.0,
      sampler_name: jobData.sampler_name || 'Euler a',
      scheduler: jobData.scheduler || 'automatic',
      seed: jobData.seed || -1,
      batch_size: jobData.batch_size || 1,
      n_iter: jobData.n_iter || 1,
      restore_faces: jobData.restore_faces || false,
      tiling: jobData.tiling || false,
      do_not_save_samples: jobData.do_not_save_samples !== undefined ? jobData.do_not_save_samples : true,
      do_not_save_grid: jobData.do_not_save_grid !== undefined ? jobData.do_not_save_grid : true,
      eta: jobData.eta,
      denoising_strength: jobData.denoising_strength,
      s_min_uncond: jobData.s_min_uncond,
      s_churn: jobData.s_churn,
      s_tmax: jobData.s_tmax,
      s_tmin: jobData.s_tmin,
      s_noise: jobData.s_noise,
      override_settings: jobData.override_settings || {},
      override_settings_restore_afterwards: jobData.override_settings_restore_afterwards !== undefined ? jobData.override_settings_restore_afterwards : true,
      refiner_checkpoint: jobData.refiner_checkpoint,
      refiner_switch_at: jobData.refiner_switch_at,
      disable_extra_networks: jobData.disable_extra_networks || false,
      firstpass_image: jobData.firstpass_image,
      comments: jobData.comments || {},
    };
  }

  private async waitForService(maxAttempts: number = 60): Promise<void> {
    logger.info('Waiting for A1111 service to become available...');
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        await this.client.get('/sdapi/v1/options', { timeout: 5000 });
        logger.info(`A1111 service is available (attempt ${attempt})`);
        return;
      } catch (error) {
        if (attempt === maxAttempts) {
          throw new Error(`A1111 service not available after ${maxAttempts} attempts: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
        
        if (attempt % 10 === 0) {
          logger.info(`Still waiting for A1111 service... (attempt ${attempt}/${maxAttempts})`);
        }
        
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
  }

  private startHealthChecks(): void {
    // Perform health checks every 30 seconds
    this.healthCheckInterval = setInterval(async () => {
      try {
        const isHealthy = await this.checkHealth();
        if (!isHealthy) {
          logger.warn('A1111 health check failed');
        }
      } catch (error) {
        logger.debug('A1111 health check error:', error);
      }
    }, 30000);
  }
}