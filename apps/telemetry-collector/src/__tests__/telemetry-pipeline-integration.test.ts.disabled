import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import Redis from 'ioredis';
import { TelemetryEvent, OtelSpan } from '@emp/core';

/**
 * Telemetry Pipeline Integration Tests
 *
 * Tests the entire flow: API → Redis Stream → Collector → Dash0
 *
 * This test suite validates:
 * 1. Redis Stream connectivity and event storage
 * 2. Event format compatibility between API and Collector
 * 3. Collector processing and Dash0 forwarding
 * 4. Error handling and recovery scenarios
 *
 * Add new test cases here as we implement more event types:
 * - Job lifecycle events
 * - WebSocket connection events
 * - Redis operation events
 * - Error and exception events
 * - Performance monitoring events
 */

describe('Telemetry Pipeline Integration', () => {
  let redis: Redis;
  const streamKey = 'telemetry:events:test';
  const consumerGroup = 'test-consumers';
  const consumerId = 'test-consumer-1';

  beforeAll(async () => {
    // Connect to Redis
    redis = new Redis({
      host: 'localhost',
      port: 6379,
      maxRetriesPerRequest: 3,
    });

    // Clean up any existing test stream
    try {
      await redis.del(streamKey);
    } catch (error) {
      // Stream might not exist, that's ok
    }

    // Create consumer group
    try {
      await redis.xgroup('CREATE', streamKey, consumerGroup, '0', 'MKSTREAM');
    } catch (error) {
      // Group might already exist, that's ok
    }
  });

  afterAll(async () => {
    // Clean up test data
    try {
      await redis.del(streamKey);
      await redis.xgroup('DESTROY', streamKey, consumerGroup);
    } catch (error) {
      // Ignore cleanup errors
    }
    await redis.quit();
  });

  beforeEach(async () => {
    // Clear any pending messages
    try {
      await redis.xgroup('SETID', streamKey, consumerGroup, '$');
    } catch (error) {
      // Ignore if stream doesn't exist yet
    }
  });

  describe('Redis Stream Event Storage', () => {
    it('should store TelemetryEvent in Redis stream', async () => {
      const event: TelemetryEvent = {
        timestamp: Date.now(),
        service: 'test-service',
        eventType: 'integration.test',
        traceId: 'trace-123',
        data: { testField: 'testValue' }
      };

      // Add event to stream (simulating API behavior)
      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify(event)
      );

      expect(messageId).toBeTruthy();

      // Verify event can be read from stream
      const messages = await redis.xread('COUNT', 1, 'STREAMS', streamKey, '0');
      expect(messages).toHaveLength(1);
      expect(messages[0][1]).toHaveLength(1);

      const [id, fields] = messages[0][1][0];
      const eventData = JSON.parse(fields[3] as string); // data field
      expect(eventData.service).toBe('test-service');
      expect(eventData.eventType).toBe('integration.test');
      expect(eventData.traceId).toBe('trace-123');
    });

    it('should store OtelSpan in Redis stream', async () => {
      const span: OtelSpan = {
        traceId: 'trace-456',
        spanId: 'span-789',
        operationName: 'test.operation',
        startTime: Date.now() * 1_000_000, // nanoseconds
        status: { code: 1 },
        resource: {
          'service.name': 'test-service',
          'service.version': '1.0.0',
          'service.instance.id': 'test-instance',
          'deployment.environment': 'test'
        },
        attributes: { testAttribute: 'testValue' }
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'otel_span',
        'data', JSON.stringify(span)
      );

      expect(messageId).toBeTruthy();

      // Verify span can be read
      const messages = await redis.xread('COUNT', 1, 'STREAMS', streamKey, '0');
      expect(messages).toHaveLength(1);

      const [id, fields] = messages[0][1][0];
      const spanData = JSON.parse(fields[3] as string);
      expect(spanData.operationName).toBe('test.operation');
      expect(spanData.traceId).toBe('trace-456');
      expect(spanData.resource['service.name']).toBe('test-service');
    });
  });

  describe('Event Format Compatibility', () => {
    it('should handle malformed event data gracefully', async () => {
      // Add malformed event
      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', 'invalid json}'
      );

      expect(messageId).toBeTruthy();

      // Consumer should be able to handle this without crashing
      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      expect(messages).toHaveLength(1);
      // The actual error handling would be in the collector code
    });

    it('should handle missing required fields', async () => {
      const incompleteEvent = {
        service: 'test-service',
        // Missing timestamp, eventType, traceId
        data: {}
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify(incompleteEvent)
      );

      expect(messageId).toBeTruthy();

      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      expect(messages).toHaveLength(1);
    });

    it('should handle invalid timestamp values', async () => {
      const eventWithBadTimestamp: TelemetryEvent = {
        timestamp: NaN, // Invalid timestamp
        service: 'test-service',
        eventType: 'test.invalid.timestamp',
        traceId: 'trace-123',
        data: {}
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify(eventWithBadTimestamp)
      );

      expect(messageId).toBeTruthy();

      // This should be processable by the collector
      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      expect(messages).toHaveLength(1);
    });
  });

  describe('Consumer Group Functionality', () => {
    it('should consume events from consumer group', async () => {
      // Add multiple events
      const events = [
        { service: 'api', eventType: 'service.started', data: { port: 3331 } },
        { service: 'api', eventType: 'health.check', data: { status: 'healthy' } },
        { service: 'api', eventType: 'websocket.connection', data: { action: 'connect' } }
      ];

      for (const event of events) {
        await redis.xadd(
          streamKey,
          '*',
          'eventType', 'telemetry',
          'data', JSON.stringify({
            timestamp: Date.now(),
            traceId: `trace-${Math.random()}`,
            ...event
          })
        );
      }

      // Consume events
      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 3,
        'STREAMS', streamKey, '>'
      );

      expect(messages).toHaveLength(1);
      expect(messages[0][1]).toHaveLength(3);

      // Verify event types
      const consumedEvents = messages[0][1].map(([id, fields]) => {
        const eventData = JSON.parse(fields[3] as string);
        return eventData.eventType;
      });

      expect(consumedEvents).toContain('service.started');
      expect(consumedEvents).toContain('health.check');
      expect(consumedEvents).toContain('websocket.connection');
    });

    it('should handle pending messages correctly', async () => {
      // Add event
      await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify({
          timestamp: Date.now(),
          service: 'test',
          eventType: 'pending.test',
          traceId: 'trace-pending',
          data: {}
        })
      );

      // Read but don't acknowledge
      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      expect(messages).toHaveLength(1);
      const messageId = messages[0][1][0][0];

      // Check pending messages
      const pending = await redis.xpending(streamKey, consumerGroup);
      expect(pending[0]).toBe(1); // 1 pending message

      // Acknowledge the message
      const ackResult = await redis.xack(streamKey, consumerGroup, messageId);
      expect(ackResult).toBe(1);

      // Verify no pending messages
      const pendingAfter = await redis.xpending(streamKey, consumerGroup);
      expect(pendingAfter[0]).toBe(0);
    });
  });

  describe('Collector Health Integration', () => {
    it('should verify collector health endpoint responds', async () => {
      const healthUrl = 'http://localhost:9090/health';

      try {
        const response = await fetch(healthUrl);
        expect(response.ok).toBe(true);

        const health = await response.json();
        expect(health).toHaveProperty('status');
        expect(health.status).toBe('healthy');
      } catch (error) {
        // If collector isn't running, skip this test
        console.warn('Collector health check failed - collector may not be running');
      }
    });

    it('should verify collector stats endpoint responds', async () => {
      const statsUrl = 'http://localhost:9090/stats';

      try {
        const response = await fetch(statsUrl);
        expect(response.ok).toBe(true);

        const stats = await response.json();
        expect(stats).toHaveProperty('processed');
        expect(stats).toHaveProperty('pending');
        expect(typeof stats.processed).toBe('number');
        expect(typeof stats.pending).toBe('number');
      } catch (error) {
        console.warn('Collector stats check failed - collector may not be running');
      }
    });
  });

  describe('API Server Event Types', () => {
    /**
     * Test cases for specific event types from the API server.
     * Add new test cases here as we implement more event types.
     */

    it('should process service.started events', async () => {
      const event: TelemetryEvent = {
        timestamp: Date.now(),
        service: 'api',
        eventType: 'service.started',
        traceId: 'trace-service-start',
        data: { port: 3331, version: '1.0.0' }
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify(event)
      );

      expect(messageId).toBeTruthy();

      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      const eventData = JSON.parse(messages[0][1][0][1][3] as string);
      expect(eventData.eventType).toBe('service.started');
      expect(eventData.data.port).toBe(3331);
    });

    it('should process websocket.connection events', async () => {
      const event: TelemetryEvent = {
        timestamp: Date.now(),
        service: 'api',
        eventType: 'websocket.connection',
        traceId: 'trace-ws-connection',
        data: { socketId: 'socket-123', action: 'connect' }
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify(event)
      );

      expect(messageId).toBeTruthy();

      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      const eventData = JSON.parse(messages[0][1][0][1][3] as string);
      expect(eventData.eventType).toBe('websocket.connection');
      expect(eventData.data.socketId).toBe('socket-123');
    });

    it('should process redis.operation events', async () => {
      const event: TelemetryEvent = {
        timestamp: Date.now(),
        service: 'api',
        eventType: 'redis.operation',
        traceId: 'trace-redis-op',
        data: {
          operation: 'HMSET',
          key: 'machine:123',
          durationMs: 5
        }
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'telemetry',
        'data', JSON.stringify(event)
      );

      expect(messageId).toBeTruthy();

      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      const eventData = JSON.parse(messages[0][1][0][1][3] as string);
      expect(eventData.eventType).toBe('redis.operation');
      expect(eventData.data.operation).toBe('HMSET');
    });

    it('should process error events', async () => {
      const span: OtelSpan = {
        traceId: 'trace-error',
        spanId: 'span-error',
        operationName: 'error.uncaught',
        startTime: Date.now() * 1_000_000,
        status: { code: 2 }, // Error status
        resource: {
          'service.name': 'api',
          'service.version': '1.0.0',
          'service.instance.id': 'test-instance',
          'deployment.environment': 'test'
        },
        attributes: {
          'error.message': 'Test error message',
          'error.type': 'Error',
          'error.stack': 'Error: Test error\n  at test...'
        }
      };

      const messageId = await redis.xadd(
        streamKey,
        '*',
        'eventType', 'otel_span',
        'data', JSON.stringify(span)
      );

      expect(messageId).toBeTruthy();

      const messages = await redis.xreadgroup(
        'GROUP', consumerGroup, consumerId,
        'COUNT', 1,
        'STREAMS', streamKey, '>'
      );

      const spanData = JSON.parse(messages[0][1][0][1][3] as string);
      expect(spanData.operationName).toBe('error.uncaught');
      expect(spanData.status.code).toBe(2);
      expect(spanData.attributes['error.message']).toBe('Test error message');
    });
  });

  describe('End-to-End Pipeline Validation', () => {
    it('should process events through the entire pipeline', async () => {
      // This test requires the collector to be running
      const events: TelemetryEvent[] = [
        {
          timestamp: Date.now(),
          service: 'integration-test',
          eventType: 'pipeline.test.start',
          traceId: 'trace-e2e-1',
          data: { testPhase: 'start' }
        },
        {
          timestamp: Date.now() + 1000,
          service: 'integration-test',
          eventType: 'pipeline.test.middle',
          traceId: 'trace-e2e-1',
          data: { testPhase: 'middle' }
        },
        {
          timestamp: Date.now() + 2000,
          service: 'integration-test',
          eventType: 'pipeline.test.end',
          traceId: 'trace-e2e-1',
          data: { testPhase: 'end', success: true }
        }
      ];

      // Add events to the actual telemetry stream
      const realStreamKey = 'telemetry:events';
      for (const event of events) {
        await redis.xadd(
          realStreamKey,
          '*',
          'eventType', 'telemetry',
          'data', JSON.stringify(event)
        );
      }

      // Give collector time to process
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Check collector stats to see if events were processed
      try {
        const response = await fetch('http://localhost:9090/stats');
        if (response.ok) {
          const stats = await response.json();
          console.log('Collector stats after pipeline test:', stats);
          // Events should have been processed (exact number depends on what else is running)
          expect(stats.processed).toBeGreaterThan(0);
        }
      } catch (error) {
        console.warn('Could not verify collector processing - collector may not be running');
      }
    });
  });
});