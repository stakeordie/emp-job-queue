#!/bin/bash

# Generate complete docker-compose.yml with dynamic ports based on environment variables
# Usage: ./generate-docker-compose.sh

set -e

# Load environment variables from .env file if it exists
if [ -f .env ]; then
    set -a  # Automatically export all variables
    source .env
    set +a
fi

# Default values
CONTAINER_NAME=${MACHINE_CONTAINER_NAME:-basic-machine}
NUM_GPUS=${MACHINE_NUM_GPUS:-1}
EXPOSE_PORTS=${EXPOSE_PORTS:-false}
EXPOSED_HOST_PORT_BASE=${EXPOSED_HOST_PORT_BASE:-3188}
EXPOSED_CONTAINER_PORT_BASE=${EXPOSED_CONTAINER_PORT_BASE:-8188}
MACHINE_IMAGE=${MACHINE_IMAGE:-basic-machine:latest}

echo "ðŸ”§ Generating docker-compose.yml with:"
echo "   Container: $CONTAINER_NAME"
echo "   GPUs: $NUM_GPUS"
echo "   Expose Ports: $EXPOSE_PORTS"
if [ "$EXPOSE_PORTS" = "true" ]; then
    echo "   Port Base: $EXPOSED_HOST_PORT_BASE:$EXPOSED_CONTAINER_PORT_BASE"
fi

# Generate the compose file header
cat > docker-compose.yml << 'COMPOSE_EOF'
# This file is dynamically generated by ./generate-docker-compose.sh
# Run the script to regenerate after changing environment variables

services:
  basic-machine:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        CACHE_BUST: ${CACHE_BUST:-1}
        # Custom nodes build-time secrets
        CUSTOM_NODES_CACHE_BUST: ${CUSTOM_NODES_CACHE_BUST:-default}
COMPOSE_EOF

# Add build args only if they are set (non-empty)
BUILD_ARGS=(
  "AWS_ACCESS_KEY_ID"
  "AWS_SECRET_ACCESS_KEY_ENCODED" 
  "AWS_DEFAULT_REGION"
  "GOOGLE_APPLICATION_CREDENTIALS"
  "AZURE_STORAGE_ACCOUNT"
  "AZURE_STORAGE_KEY"
  "CLOUD_STORAGE_CONTAINER"
  "CLOUD_MODELS_CONTAINER"
  "CLOUD_STORAGE_TEST_CONTAINER"
  "CLOUD_PROVIDER"
  "STATIC_MODELS"
  "EMPROPS_DEBUG_LOGGING"
  "HF_TOKEN"
  "CIVITAI_TOKEN"
  "OLLAMA_HOST"
  "OLLAMA_PORT"
  "OLLAMA_DEFAULT_MODEL"
  "OPENAI_API_KEY"
)

for arg in "${BUILD_ARGS[@]}"; do
  if [ ! -z "${!arg}" ]; then
    echo "        $arg: \${$arg}" >> docker-compose.yml
  fi
done

# Complete the build section
cat >> docker-compose.yml << 'COMPOSE_EOF'
    image: ${MACHINE_IMAGE:-basic-machine:latest}
    platform: linux/amd64
    container_name: ${MACHINE_CONTAINER_NAME:-basic-machine}
    hostname: ${MACHINE_CONTAINER_NAME:-basic-machine}
    restart: "no"  # Controlled by API instead of Docker
    
    # Fast shutdown for elastic scaling
    stop_grace_period: 2s
    stop_signal: SIGTERM
COMPOSE_EOF

# Add ports section if EXPOSE_PORTS is true
if [ "$EXPOSE_PORTS" = "true" ]; then
    echo "    ports:" >> docker-compose.yml
    
    # Generate ComfyUI ports for each GPU
    for ((gpu=0; gpu<NUM_GPUS; gpu++)); do
        host_port=$((EXPOSED_HOST_PORT_BASE + gpu))
        container_port=$((EXPOSED_CONTAINER_PORT_BASE + gpu))
        echo "      - \"$host_port:$container_port\"  # ComfyUI GPU $gpu" >> docker-compose.yml
    done
    
    # Add other common ports
    echo "      - \"9092:\${HEALTH_PORT:-9090}\"    # Health check" >> docker-compose.yml
    echo "      - \"2224:\${SSH_PORT:-22}\"         # SSH access" >> docker-compose.yml
fi

# Add environment variables section
cat >> docker-compose.yml << 'COMPOSE_EOF'
    
    # Environment variables - only what machine interface actually needs
    environment:
      # Docker/GPU runtime
      - NODE_ENV=production
      - NVIDIA_VISIBLE_DEVICES=all
      - NVIDIA_DRIVER_CAPABILITIES=compute,utility
      
      # Machine identity and Redis connection (required)
      - MACHINE_ID=${MACHINE_ID}
      - MACHINE_CONTAINER_NAME=${MACHINE_CONTAINER_NAME}
      - HUB_REDIS_URL=${HUB_REDIS_URL}
      
      # Hardware configuration (required)
      - MACHINE_NUM_GPUS=${MACHINE_NUM_GPUS}
      - MACHINE_GPU_MEMORY_GB=${MACHINE_GPU_MEMORY_GB}
      - MACHINE_GPU_MODEL=${MACHINE_GPU_MODEL}
      
      # Service enablement flags (required)
      - MACHINE_ENABLE_COMFYUI=${MACHINE_ENABLE_COMFYUI}
      - MACHINE_ENABLE_REDIS_WORKERS=${MACHINE_ENABLE_REDIS_WORKERS}
      - MACHINE_ENABLE_SIMULATION=${MACHINE_ENABLE_SIMULATION}
      
      # Worker configuration (required)
      - WORKER_CONNECTORS=${WORKER_CONNECTORS}
      
      # Worker ComfyUI connection (for remote ComfyUI)
      - WORKER_COMFYUI_REMOTE=${WORKER_COMFYUI_REMOTE:-false}
      - WORKER_COMFYUI_HOST=${WORKER_COMFYUI_HOST:-localhost}
      - WORKER_COMFYUI_PORT=${WORKER_COMFYUI_PORT:-8188}
      - WORKER_COMFYUI_USERNAME=${WORKER_COMFYUI_USERNAME:-}
      - WORKER_COMFYUI_PASSWORD=${WORKER_COMFYUI_PASSWORD:-}
      
      # Optional configuration
      - WORKER_WEBSOCKET_AUTH_TOKEN=${WORKER_WEBSOCKET_AUTH_TOKEN:-}
      - MACHINE_ENABLE_NGINX=${MACHINE_ENABLE_NGINX:-false}
      - MACHINE_ENABLE_A1111=${MACHINE_ENABLE_A1111:-false}
      - MACHINE_ENABLE_OLLAMA=${MACHINE_ENABLE_OLLAMA:-false}
      - MACHINE_HEALTH_PORT=${MACHINE_HEALTH_PORT:-9090}
      - MACHINE_LOG_LEVEL=${MACHINE_LOG_LEVEL:-info}
      - MACHINE_TEST_MODE=${MACHINE_TEST_MODE:-false}
    
    # No volume mounts - use built-in ComfyUI installation from Docker image
    # volumes:
    #   - ./data:/workspace
    #   - ./data/logs:/workspace/logs
    #   - ./data/shared:/workspace/shared
      
    working_dir: /workspace
    
    # Resource limits based on environment
    deploy:
      resources:
        limits:
          memory: ${MEMORY_LIMIT:-8G}
        reservations:
          memory: ${MEMORY_RESERVATION:-2G}
COMPOSE_EOF

echo "âœ… Generated docker-compose.yml successfully!"
if [ "$EXPOSE_PORTS" = "true" ]; then
    echo "   ðŸ“‹ Exposed ComfyUI ports: $EXPOSED_HOST_PORT_BASE-$((EXPOSED_HOST_PORT_BASE + NUM_GPUS - 1))"
else
    echo "   ðŸ”’ No ports exposed (EXPOSE_PORTS=false)"
fi