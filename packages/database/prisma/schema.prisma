generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated"
  binaryTargets = ["native", "debian-openssl-3.0.x", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model assignment {
  id         BigInt   @id @default(autoincrement())
  user_id    String?  @db.Uuid
  address    String?
  token_id   String?
  created_at DateTime @default(now())
}

model collection {
  id                         String                       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  archived                   Boolean                      @default(false)
  batch_max_tokens           Int?
  batch_mint_enabled         Boolean                      @default(false)
  blockchain                 String?
  cover_image_url            String?
  data                       Json?
  description                String?
  editions                   Int?
  encryption_enabled         Boolean?
  images                     Json?
  is_current                 Boolean                      @default(true)
  price                      Float?
  project_id                 String                       @db.Uuid
  publish_date               DateTime?
  status                     String                       @default("draft")
  title                      String?
  updated_at                 DateTime                     @default(now())
  created_at                 DateTime                     @default(now())
  is_custodial               Boolean                      @default(false)
  custodied_for              String?                      @db.Uuid
  miniapp_cover_image        String?
  cast_hash                  String?
  social_link                social_link?                 @relation(fields: [custodied_for], references: [id])
  project                    project                      @relation(fields: [project_id], references: [id], onDelete: Cascade)
  collection_history         collection_history[]
  collection_preview         collection_preview?
  source_remix               collection_remix[]           @relation("source_collection")
  target_remix               collection_remix[]           @relation("target_collection")
  collection_sales_receivers collection_sales_receiver[]
  collection_sample_images   collection_sample_image[]
  collection_node            component[]
  miniapp_collection_config  miniapp_collection_config?
  miniapp_generation         miniapp_generation[]
  miniapp_payment            miniapp_payment[]
}

model collection_remix {
  id                            BigInt                      @id @default(autoincrement())
  source_collection_id          String                      @db.Uuid
  target_collection_id          String                      @db.Uuid
  created_at                    DateTime?                   @default(now())
  collection_preview_version_id BigInt?
  collection_preview_version    collection_preview_version? @relation(fields: [collection_preview_version_id], references: [id])
  source_collection             collection                  @relation("source_collection", fields: [source_collection_id], references: [id], onDelete: Cascade)
  target_collection             collection                  @relation("target_collection", fields: [target_collection_id], references: [id], onDelete: Cascade)
}

model event {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  event_name     String
  property_name  String
  property_value String?
  created_at     DateTime @default(now())
  user_id        String   @db.Uuid
  event_id       String   @db.Uuid
  event_type     String
}

model flat_file {
  id                   BigInt                @id(map: "flat-files_pkey") @default(autoincrement())
  created_at           DateTime?             @default(now())
  url                  String?
  hidden               Boolean?              @default(false)
  user_id              String                @db.Uuid
  name                 String
  gen_in_data          Json?
  gen_out_data         Json?
  mime_type            String?
  rel_id               String?
  rel_type             String?
  tags                 String[]              @default([])
  chat_message         chat_message[]
  component_flat_files component_flat_file[]
}

model component_flat_file {
  id           BigInt    @id @default(autoincrement())
  component_id BigInt
  flat_file_id BigInt
  component    component @relation(fields: [component_id], references: [id], onDelete: Cascade)
  flat_file    flat_file @relation(fields: [flat_file_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([component_id, flat_file_id])
}

model project {
  id                         String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created_at                 DateTime     @default(now())
  name                       String
  user_id                    String       @db.Uuid
  data                       Json?
  current_project_history_id String?      @db.Uuid
  version                    String?
  archived                   Boolean      @default(false)
  is_default                 Boolean      @default(false)
  collection                 collection[]
}

model project_history {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created_at DateTime @default(now())
  data       Json
  user_id    String   @db.Uuid
  project_id String   @db.Uuid
  name       String   @default("Untitled")
  images     Json?
}

model role {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id    String   @db.Uuid
  created_at DateTime @default(now())
  name       String
}

model wallet {
  id         BigInt    @id @default(autoincrement())
  created_at DateTime? @default(now())
  address    String    @unique
  user_id    String?   @db.Uuid
}

model credits_history {
  id          Int       @id @default(autoincrement())
  flow        String
  amount      Decimal
  credit_type String
  created_at  DateTime? @default(now())
  user_id     String    @db.Uuid
  comment     String?
}

model credits_balance {
  id          Int       @id @default(autoincrement())
  user_id     String    @db.Uuid
  created_at  DateTime? @default(now())
  updated_at  DateTime? @default(now())
  balance     Decimal
  credit_type String
}

model subscription {
  id                     String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  stripe_subscription_id String    @unique
  created_at             DateTime? @default(now())
  updated_at             DateTime? @default(now())
  user_id                String?   @db.Uuid
  status                 String
  stripe_product_id      String
  subscription_key       String
  cancel_at_period_end   Boolean
  current_period_end     DateTime
  current_period_start   DateTime
}

model customer {
  id                      String    @id @db.Uuid
  stripe_customer_id      String?   @unique
  created_at              DateTime? @default(now())
  updated_at              DateTime? @default(now())
  prefinery_referral_code String?
  has_migrated            Boolean   @default(false)
}

model product {
  id                Int       @id @default(autoincrement())
  name              String
  type              String
  stripe_price_id   String    @unique
  stripe_product_id String
  price             Decimal
  credits_quantity  Int?
  credits_type      String?
  active            Boolean
  created_at        DateTime? @default(now())
  updated_at        DateTime
  lookup_key        String    @unique
  rank              Int       @default(0)
  features          String?
}

model project_template {
  id                         BigInt                  @id @default(autoincrement())
  name                       String
  data                       Json
  created_at                 DateTime                @default(now())
  updated_at                 DateTime?               @default(now())
  current_project_history_id String?                 @db.Uuid
  project_template_save      project_template_save[]
}

model project_template_save {
  id                  BigInt           @id @default(autoincrement())
  name                String
  data                Json
  images              Json?
  created_at          DateTime         @default(now())
  updated_at          DateTime?        @default(now())
  project_template_id BigInt
  project_history_id  String?          @db.Uuid
  project_template    project_template @relation(fields: [project_template_id], references: [id], onDelete: Cascade)
}

model collection_reward {
  id                           Int                            @id @default(autoincrement())
  collection_id                String
  tag                          String
  credits                      Int
  enabled                      Boolean?
  created_at                   DateTime                       @default(now())
  updated_at                   DateTime?
  collection_reward_redemption collection_reward_redemption[]
}

model collection_reward_redemption {
  id                   Int               @id @default(autoincrement())
  user_id              String
  wallet_address       String
  token_id             String
  collection_reward_id Int
  created_at           DateTime          @default(now())
  collection_reward    collection_reward @relation(fields: [collection_reward_id], references: [id], onDelete: Cascade)
}

model collection_sales_receiver {
  id            Int        @id @default(autoincrement())
  collection_id String     @db.Uuid
  address       String
  value         Float
  type          String
  collection    collection @relation(fields: [collection_id], references: [id], onDelete: Cascade)

  @@map("collection_sales_receiver")
}

model collection_history {
  id            Int        @id @default(autoincrement())
  event         String
  current_value String
  new_value     String
  created_at    DateTime   @default(now())
  collection_id String     @db.Uuid
  collection    collection @relation(fields: [collection_id], references: [id], onDelete: Cascade)
}

model profile {
  id                 String    @id @db.Uuid
  profile_image      String?
  profile_preference String?
  created_at         DateTime? @default(now())
  updated_at         DateTime? @default(now())
  profile_username   String?
}

model collection_preview {
  id                         BigInt                       @id @default(autoincrement())
  enabled                    Boolean                      @default(false)
  max_generations            Int                          @default(0)
  total_generations          Int                          @default(0)
  collection_id              String                       @unique @db.Uuid
  access_level               String                       @default("PRIVATE")
  is_remixable               Boolean                      @default(false)
  farcaster_collection       Boolean                      @default(false)
  collection                 collection                   @relation(fields: [collection_id], references: [id], onDelete: Cascade)
  collection_preview_version collection_preview_version[]
}

model collection_preview_version {
  id                    BigInt             @id @default(autoincrement())
  version               Int                @default(1)
  collection_preview_id BigInt
  data                  Json
  is_latest             Boolean            @default(false)
  created_at            DateTime?          @default(now())
  collection_preview    collection_preview @relation(fields: [collection_preview_id], references: [id], onDelete: Cascade)
  collection_remix      collection_remix[]
}

model collection_sample_image {
  id            BigInt     @id @default(autoincrement())
  url           String
  collection_id String     @db.Uuid
  collection    collection @relation(fields: [collection_id], references: [id], onDelete: Cascade)

  @@map("collection_sample_image")
}

model chat {
  id           String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created_at   DateTime?      @default(now())
  entity_type  String
  entity_id    String
  chat_message chat_message[]
}

model chat_message {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created_at   DateTime?  @default(now())
  updated_at   DateTime?  @default(now())
  user_id      String     @db.Uuid
  content      String
  chat_id      String     @db.Uuid
  flat_file_id BigInt?
  chat         chat       @relation(fields: [chat_id], references: [id], onDelete: Cascade)
  flat_file    flat_file? @relation(fields: [flat_file_id], references: [id])
}

model socket_io_attachment {
  id         BigInt    @id @default(autoincrement())
  payload    Bytes
  created_at DateTime? @default(now())

  @@map("socket_io_attachment")
}

enum ComponentDeleteStatus {
  active
  deleted
}

model component {
  id                   BigInt                @id @default(autoincrement())
  collection_id        String                @db.Uuid
  created_at           DateTime?             @default(now())
  delete_status        ComponentDeleteStatus @default(active)
  collection           collection            @relation(fields: [collection_id], references: [id], onDelete: Cascade)
  component_flat_files component_flat_file[]
}

model workflow {
  id                    String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                  String                  @unique
  description           String?
  data                  Json?
  created_at            DateTime                @default(now())
  server_id             String?                 @db.Uuid
  output_mime_type      String?
  display               Boolean?                @default(false)
  label                 String?
  order                 Int?
  type                  String?
  est_gen_time          Json?                   @map("est_gen_time")
  machine_type          String?                 @map("machine_type")
  min_vram              Int?                    @map("min_vram")
  server                server?                 @relation(fields: [server_id], references: [id], onDelete: Cascade)
  workflow_custom_nodes workflow_custom_node[]
  workflow_models       WorkflowModel[]
}

model server {
  id         String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String     @unique
  url        String
  created_at DateTime   @default(now())
  updated_at DateTime   @updatedAt
  workflow   workflow[]
}

model form_config {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String   @unique
  data       Json
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model api_key {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  alias         String   @unique
  key           String   @unique
  workflow_name String
  user_id       String   @db.Uuid
  created_at    DateTime @default(now())
}

model user_api_key {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id    String    @db.Uuid
  key_hash   String    @unique @db.VarChar(255)
  name       String?   @db.VarChar(255)
  expires_at DateTime? @db.Timestamp(6)
  created_at DateTime  @default(now())
  is_active  Boolean   @default(true)

  @@index([user_id])
  @@map("user_api_key")
}

model job {
  id            String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  description   String?
  status        String        @default("pending")
  data          Json?
  progress      Int?
  error_message String?
  created_at    DateTime      @default(now())
  updated_at    DateTime      @updatedAt
  started_at    DateTime?
  completed_at  DateTime?
  user_id       String        @db.Uuid
  job_type      String
  priority      Int           @default(1)
  retry_count     Int           @default(0)
  max_retries     Int           @default(3)
  workflow_output String?

  // Evaluation fields
  is_cleanup_evaluated Boolean   @default(false)
  status_category      String?   // 'complete', 'incomplete', 'data_structure_issue'
  problem_type         String?   // 'missing_output', 'notification_failed', 'stuck_processing', etc.
  problem_details      Json?     // Detailed problem analysis
  evaluated_at         DateTime?
  resolution_needed    String?   // 'workflow_output_extraction', 'data_integrity_check', 'miniapp_generation_missing', etc.

  job_history     job_history[]
  steps           step[]
  job_retry_backup job_retry_backup[]

  @@index([is_cleanup_evaluated])
  @@index([status_category])
}

model job_retry_backup {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  original_job_id  String   @db.Uuid
  retry_attempt    Int
  original_data    Json?
  original_status  String
  original_workflow_output String?
  original_started_at      DateTime?
  original_completed_at    DateTime?
  backed_up_at     DateTime @default(now())
  job              job      @relation(fields: [original_job_id], references: [id], onDelete: Cascade)

  @@map("job_retry_backup")
}

model job_history {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  job_id        String   @db.Uuid
  status        String
  data          Json?
  created_at    DateTime @default(now())
  message       String?
  retry_attempt Int      @default(0)
  job           job      @relation(fields: [job_id], references: [id], onDelete: Cascade)
}

model step {
  id            String    @id @db.Uuid
  job_id        String    @db.Uuid
  step_name     String
  step_type     String    // 'delegated', 'local', 'test'
  status        String    @default("pending") // 'pending', 'processing', 'completed', 'failed'
  started_at    DateTime  @default(now())
  completed_at  DateTime?
  input_data    Json?
  output_data   Json?
  error_message String?
  step_order    Int?
  retry_attempt Int?
  job           job       @relation(fields: [job_id], references: [id], onDelete: Cascade)

  @@index([job_id])
  @@index([status])
}

model miniapp_user {
  id                     String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  farcaster_id           String                   @unique
  farcaster_username     String?
  farcaster_pfp          String?
  wallet_address         String?
  created_at             DateTime                 @default(now())
  updated_at             DateTime                 @updatedAt
  notification_token     String?
  split_address          String?
  swapper_address        String?
  miniapp_claim_activity miniapp_claim_activity[]
  miniapp_generation     miniapp_generation[]
  miniapp_payment        miniapp_payment[]
  social_link            social_link[]

  @@index([wallet_address])
}

model miniapp_collection_config {
  id                      String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  collection_id           String     @unique @db.Uuid
  price                   Float      @default(0.75)
  generations_per_payment Int        @default(3)
  is_active               Boolean    @default(true)
  is_visible              Boolean    @default(true)
  is_featured             Boolean    @default(false)
  created_at              DateTime   @default(now())
  updated_at              DateTime   @updatedAt
  max_retries             Int        @default(2)
  cast_hash               String?
  collection              collection @relation(fields: [collection_id], references: [id], onDelete: Cascade)
}

model miniapp_payment {
  id                  String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id             String               @db.Uuid
  collection_id       String               @db.Uuid
  amount              Float
  transaction_hash    String?              @unique
  payment_status      String               @default("pending")
  generations_allowed Int
  generations_used    Int                  @default(0)
  created_at          DateTime             @default(now())
  updated_at          DateTime             @updatedAt
  miniapp_generation  miniapp_generation[]
  collection          collection           @relation(fields: [collection_id], references: [id])
  miniapp_user        miniapp_user         @relation(fields: [user_id], references: [id])

  @@index([payment_status])
  @@index([user_id, collection_id])
}

model miniapp_generation {
  id              String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id         String           @db.Uuid
  collection_id   String           @db.Uuid
  payment_id      String?          @db.Uuid
  input_data      Json?
  output_url      String?
  output_data     Json?
  error_message   String?
  created_at      DateTime         @default(now())
  updated_at      DateTime         @updatedAt
  job_id          String?
  generated_image String?
  status          GenerationStatus @default(idle)
  retry_count     Int              @default(0)
  collection      collection       @relation(fields: [collection_id], references: [id])
  miniapp_payment miniapp_payment? @relation(fields: [payment_id], references: [id])
  miniapp_user    miniapp_user     @relation(fields: [user_id], references: [id])

  @@index([payment_id])
  @@index([status])
  @@index([user_id, collection_id])
}

model model {
  id             String          @id @default(cuid())
  name           String          @unique
  downloadUrl    String          @map("download_url")
  saveTo         String          @map("save_to")
  description    String?
  fileSize       String?         @map("file_size")
  hash           String?
  status         String          @default("available")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  authEnvVar     String?         @map("auth_env_var")
  isAuthReq      Boolean         @default(false) @map("is_auth_req")
  workflowModels WorkflowModel[]

  @@map("model")
}

model WorkflowModel {
  id         String   @id @default(cuid())
  workflowId String   @map("workflow_id") @db.Uuid
  modelId    String   @map("model_id")
  isRequired Boolean  @default(true) @map("is_required")
  createdAt  DateTime @default(now()) @map("created_at")
  model      model    @relation(fields: [modelId], references: [id], onDelete: Cascade)
  workflow   workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@unique([workflowId, modelId])
  @@map("workflow_model")
}

model component_flat_file_recover {
  id           BigInt   @id
  component_id BigInt
  flat_file_id BigInt
  recovered_at DateTime @default(now())
  issue_type   String
}

model social_link {
  id                    String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  social_org            social_org_enum
  identifier            String
  created_at            DateTime        @default(now())
  updated_at            DateTime        @default(now()) @updatedAt
  miniapp_user_id       String?         @db.Uuid
  custodial_collections collection[]
  miniapp_user          miniapp_user?   @relation(fields: [miniapp_user_id], references: [id])

  @@unique([social_org, identifier])
}

model custom_node {
  id                    String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                  String
  download_url          String
  description           String?
  is_env_required       Boolean                 @default(false)
  env_conf              Json?
  hash                  String?
  created_at            DateTime                @default(now())
  updated_at            DateTime                @default(now())
  install_settings      Json?
  is_default            Boolean                 @default(false)
  install_order         Int?
  workflow_custom_nodes workflow_custom_node[]

  @@map("custom_node")
}

model workflow_custom_node {
  id             BigInt       @id @default(autoincrement())
  workflow_id    String       @db.Uuid
  custom_node_id String       @db.Uuid
  created_at     DateTime     @default(now())
  custom_nodes   custom_node  @relation(fields: [custom_node_id], references: [id], onDelete: Cascade)
  workflow       workflow     @relation(fields: [workflow_id], references: [id], onDelete: Cascade)

  @@unique([workflow_id, custom_node_id])
  @@map("workflow_custom_node")
}

enum social_org_enum {
  farcaster
  twitter
  discord
  lens
  github
}

model cron_log {
  id                    String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  job_name              String
  status                String
  generations_processed Int      @default(0)
  payments_processed    Int      @default(0)
  total_amount          Float    @default(0)
  successful_splits     Int      @default(0)
  failed_splits         Int      @default(0)
  execution_time        DateTime @default(now())
  details               Json?
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt

  @@index([execution_time])
  @@index([job_name])
  @@index([status])
}

model miniapp_claim_activity {
  id               String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id          String       @db.Uuid
  split_address    String
  amount_claimed   Float
  transaction_hash String?
  claim_status     String       @default("pending")
  created_at       DateTime     @default(now())
  updated_at       DateTime     @updatedAt
  miniapp_user     miniapp_user @relation(fields: [user_id], references: [id])

  @@index([claim_status])
  @@index([split_address])
  @@index([user_id])
}

enum GenerationStatus {
  idle
  processing
  completed
  failed
}
