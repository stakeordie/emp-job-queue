
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model assignment
 * 
 */
export type assignment = $Result.DefaultSelection<Prisma.$assignmentPayload>
/**
 * Model collection
 * 
 */
export type collection = $Result.DefaultSelection<Prisma.$collectionPayload>
/**
 * Model collection_remix
 * 
 */
export type collection_remix = $Result.DefaultSelection<Prisma.$collection_remixPayload>
/**
 * Model event
 * 
 */
export type event = $Result.DefaultSelection<Prisma.$eventPayload>
/**
 * Model flat_file
 * 
 */
export type flat_file = $Result.DefaultSelection<Prisma.$flat_filePayload>
/**
 * Model component_flat_file
 * 
 */
export type component_flat_file = $Result.DefaultSelection<Prisma.$component_flat_filePayload>
/**
 * Model project
 * 
 */
export type project = $Result.DefaultSelection<Prisma.$projectPayload>
/**
 * Model project_history
 * 
 */
export type project_history = $Result.DefaultSelection<Prisma.$project_historyPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model wallet
 * 
 */
export type wallet = $Result.DefaultSelection<Prisma.$walletPayload>
/**
 * Model credits_history
 * 
 */
export type credits_history = $Result.DefaultSelection<Prisma.$credits_historyPayload>
/**
 * Model credits_balance
 * 
 */
export type credits_balance = $Result.DefaultSelection<Prisma.$credits_balancePayload>
/**
 * Model subscription
 * 
 */
export type subscription = $Result.DefaultSelection<Prisma.$subscriptionPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model project_template
 * 
 */
export type project_template = $Result.DefaultSelection<Prisma.$project_templatePayload>
/**
 * Model project_template_save
 * 
 */
export type project_template_save = $Result.DefaultSelection<Prisma.$project_template_savePayload>
/**
 * Model collection_reward
 * 
 */
export type collection_reward = $Result.DefaultSelection<Prisma.$collection_rewardPayload>
/**
 * Model collection_reward_redemption
 * 
 */
export type collection_reward_redemption = $Result.DefaultSelection<Prisma.$collection_reward_redemptionPayload>
/**
 * Model collection_sales_receivers
 * 
 */
export type collection_sales_receivers = $Result.DefaultSelection<Prisma.$collection_sales_receiversPayload>
/**
 * Model collection_history
 * 
 */
export type collection_history = $Result.DefaultSelection<Prisma.$collection_historyPayload>
/**
 * Model profile
 * 
 */
export type profile = $Result.DefaultSelection<Prisma.$profilePayload>
/**
 * Model collection_preview
 * 
 */
export type collection_preview = $Result.DefaultSelection<Prisma.$collection_previewPayload>
/**
 * Model collection_preview_version
 * 
 */
export type collection_preview_version = $Result.DefaultSelection<Prisma.$collection_preview_versionPayload>
/**
 * Model collection_sample_images
 * 
 */
export type collection_sample_images = $Result.DefaultSelection<Prisma.$collection_sample_imagesPayload>
/**
 * Model chat
 * 
 */
export type chat = $Result.DefaultSelection<Prisma.$chatPayload>
/**
 * Model chat_message
 * 
 */
export type chat_message = $Result.DefaultSelection<Prisma.$chat_messagePayload>
/**
 * Model socket_io_attachments
 * 
 */
export type socket_io_attachments = $Result.DefaultSelection<Prisma.$socket_io_attachmentsPayload>
/**
 * Model component
 * 
 */
export type component = $Result.DefaultSelection<Prisma.$componentPayload>
/**
 * Model workflow
 * 
 */
export type workflow = $Result.DefaultSelection<Prisma.$workflowPayload>
/**
 * Model server
 * 
 */
export type server = $Result.DefaultSelection<Prisma.$serverPayload>
/**
 * Model form_config
 * 
 */
export type form_config = $Result.DefaultSelection<Prisma.$form_configPayload>
/**
 * Model api_key
 * 
 */
export type api_key = $Result.DefaultSelection<Prisma.$api_keyPayload>
/**
 * Model user_api_keys
 * 
 */
export type user_api_keys = $Result.DefaultSelection<Prisma.$user_api_keysPayload>
/**
 * Model job
 * 
 */
export type job = $Result.DefaultSelection<Prisma.$jobPayload>
/**
 * Model job_history
 * 
 */
export type job_history = $Result.DefaultSelection<Prisma.$job_historyPayload>
/**
 * Model miniapp_user
 * 
 */
export type miniapp_user = $Result.DefaultSelection<Prisma.$miniapp_userPayload>
/**
 * Model miniapp_collection_config
 * 
 */
export type miniapp_collection_config = $Result.DefaultSelection<Prisma.$miniapp_collection_configPayload>
/**
 * Model miniapp_payment
 * 
 */
export type miniapp_payment = $Result.DefaultSelection<Prisma.$miniapp_paymentPayload>
/**
 * Model miniapp_generation
 * 
 */
export type miniapp_generation = $Result.DefaultSelection<Prisma.$miniapp_generationPayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model WorkflowModel
 * 
 */
export type WorkflowModel = $Result.DefaultSelection<Prisma.$WorkflowModelPayload>
/**
 * Model component_flat_file_recover
 * 
 */
export type component_flat_file_recover = $Result.DefaultSelection<Prisma.$component_flat_file_recoverPayload>
/**
 * Model social_link
 * 
 */
export type social_link = $Result.DefaultSelection<Prisma.$social_linkPayload>
/**
 * Model custom_nodes
 * 
 */
export type custom_nodes = $Result.DefaultSelection<Prisma.$custom_nodesPayload>
/**
 * Model workflow_custom_nodes
 * 
 */
export type workflow_custom_nodes = $Result.DefaultSelection<Prisma.$workflow_custom_nodesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GenerationStatus: {
  idle: 'idle',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed'
};

export type GenerationStatus = (typeof GenerationStatus)[keyof typeof GenerationStatus]


export const social_org_enum: {
  farcaster: 'farcaster',
  twitter: 'twitter',
  discord: 'discord',
  lens: 'lens',
  github: 'github'
};

export type social_org_enum = (typeof social_org_enum)[keyof typeof social_org_enum]

}

export type GenerationStatus = $Enums.GenerationStatus

export const GenerationStatus: typeof $Enums.GenerationStatus

export type social_org_enum = $Enums.social_org_enum

export const social_org_enum: typeof $Enums.social_org_enum

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assignments
 * const assignments = await prisma.assignment.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assignments
   * const assignments = await prisma.assignment.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.assignment`: Exposes CRUD operations for the **assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.assignmentDelegate<ExtArgs>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collection.findMany()
    * ```
    */
  get collection(): Prisma.collectionDelegate<ExtArgs>;

  /**
   * `prisma.collection_remix`: Exposes CRUD operations for the **collection_remix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_remixes
    * const collection_remixes = await prisma.collection_remix.findMany()
    * ```
    */
  get collection_remix(): Prisma.collection_remixDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.eventDelegate<ExtArgs>;

  /**
   * `prisma.flat_file`: Exposes CRUD operations for the **flat_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flat_files
    * const flat_files = await prisma.flat_file.findMany()
    * ```
    */
  get flat_file(): Prisma.flat_fileDelegate<ExtArgs>;

  /**
   * `prisma.component_flat_file`: Exposes CRUD operations for the **component_flat_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Component_flat_files
    * const component_flat_files = await prisma.component_flat_file.findMany()
    * ```
    */
  get component_flat_file(): Prisma.component_flat_fileDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.projectDelegate<ExtArgs>;

  /**
   * `prisma.project_history`: Exposes CRUD operations for the **project_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_histories
    * const project_histories = await prisma.project_history.findMany()
    * ```
    */
  get project_history(): Prisma.project_historyDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.walletDelegate<ExtArgs>;

  /**
   * `prisma.credits_history`: Exposes CRUD operations for the **credits_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credits_histories
    * const credits_histories = await prisma.credits_history.findMany()
    * ```
    */
  get credits_history(): Prisma.credits_historyDelegate<ExtArgs>;

  /**
   * `prisma.credits_balance`: Exposes CRUD operations for the **credits_balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credits_balances
    * const credits_balances = await prisma.credits_balance.findMany()
    * ```
    */
  get credits_balance(): Prisma.credits_balanceDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.subscriptionDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs>;

  /**
   * `prisma.project_template`: Exposes CRUD operations for the **project_template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_templates
    * const project_templates = await prisma.project_template.findMany()
    * ```
    */
  get project_template(): Prisma.project_templateDelegate<ExtArgs>;

  /**
   * `prisma.project_template_save`: Exposes CRUD operations for the **project_template_save** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_template_saves
    * const project_template_saves = await prisma.project_template_save.findMany()
    * ```
    */
  get project_template_save(): Prisma.project_template_saveDelegate<ExtArgs>;

  /**
   * `prisma.collection_reward`: Exposes CRUD operations for the **collection_reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_rewards
    * const collection_rewards = await prisma.collection_reward.findMany()
    * ```
    */
  get collection_reward(): Prisma.collection_rewardDelegate<ExtArgs>;

  /**
   * `prisma.collection_reward_redemption`: Exposes CRUD operations for the **collection_reward_redemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_reward_redemptions
    * const collection_reward_redemptions = await prisma.collection_reward_redemption.findMany()
    * ```
    */
  get collection_reward_redemption(): Prisma.collection_reward_redemptionDelegate<ExtArgs>;

  /**
   * `prisma.collection_sales_receivers`: Exposes CRUD operations for the **collection_sales_receivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_sales_receivers
    * const collection_sales_receivers = await prisma.collection_sales_receivers.findMany()
    * ```
    */
  get collection_sales_receivers(): Prisma.collection_sales_receiversDelegate<ExtArgs>;

  /**
   * `prisma.collection_history`: Exposes CRUD operations for the **collection_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_histories
    * const collection_histories = await prisma.collection_history.findMany()
    * ```
    */
  get collection_history(): Prisma.collection_historyDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs>;

  /**
   * `prisma.collection_preview`: Exposes CRUD operations for the **collection_preview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_previews
    * const collection_previews = await prisma.collection_preview.findMany()
    * ```
    */
  get collection_preview(): Prisma.collection_previewDelegate<ExtArgs>;

  /**
   * `prisma.collection_preview_version`: Exposes CRUD operations for the **collection_preview_version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_preview_versions
    * const collection_preview_versions = await prisma.collection_preview_version.findMany()
    * ```
    */
  get collection_preview_version(): Prisma.collection_preview_versionDelegate<ExtArgs>;

  /**
   * `prisma.collection_sample_images`: Exposes CRUD operations for the **collection_sample_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collection_sample_images
    * const collection_sample_images = await prisma.collection_sample_images.findMany()
    * ```
    */
  get collection_sample_images(): Prisma.collection_sample_imagesDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.chatDelegate<ExtArgs>;

  /**
   * `prisma.chat_message`: Exposes CRUD operations for the **chat_message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_messages
    * const chat_messages = await prisma.chat_message.findMany()
    * ```
    */
  get chat_message(): Prisma.chat_messageDelegate<ExtArgs>;

  /**
   * `prisma.socket_io_attachments`: Exposes CRUD operations for the **socket_io_attachments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Socket_io_attachments
    * const socket_io_attachments = await prisma.socket_io_attachments.findMany()
    * ```
    */
  get socket_io_attachments(): Prisma.socket_io_attachmentsDelegate<ExtArgs>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.componentDelegate<ExtArgs>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.workflowDelegate<ExtArgs>;

  /**
   * `prisma.server`: Exposes CRUD operations for the **server** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servers
    * const servers = await prisma.server.findMany()
    * ```
    */
  get server(): Prisma.serverDelegate<ExtArgs>;

  /**
   * `prisma.form_config`: Exposes CRUD operations for the **form_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Form_configs
    * const form_configs = await prisma.form_config.findMany()
    * ```
    */
  get form_config(): Prisma.form_configDelegate<ExtArgs>;

  /**
   * `prisma.api_key`: Exposes CRUD operations for the **api_key** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_keys
    * const api_keys = await prisma.api_key.findMany()
    * ```
    */
  get api_key(): Prisma.api_keyDelegate<ExtArgs>;

  /**
   * `prisma.user_api_keys`: Exposes CRUD operations for the **user_api_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_api_keys
    * const user_api_keys = await prisma.user_api_keys.findMany()
    * ```
    */
  get user_api_keys(): Prisma.user_api_keysDelegate<ExtArgs>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.jobDelegate<ExtArgs>;

  /**
   * `prisma.job_history`: Exposes CRUD operations for the **job_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_histories
    * const job_histories = await prisma.job_history.findMany()
    * ```
    */
  get job_history(): Prisma.job_historyDelegate<ExtArgs>;

  /**
   * `prisma.miniapp_user`: Exposes CRUD operations for the **miniapp_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Miniapp_users
    * const miniapp_users = await prisma.miniapp_user.findMany()
    * ```
    */
  get miniapp_user(): Prisma.miniapp_userDelegate<ExtArgs>;

  /**
   * `prisma.miniapp_collection_config`: Exposes CRUD operations for the **miniapp_collection_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Miniapp_collection_configs
    * const miniapp_collection_configs = await prisma.miniapp_collection_config.findMany()
    * ```
    */
  get miniapp_collection_config(): Prisma.miniapp_collection_configDelegate<ExtArgs>;

  /**
   * `prisma.miniapp_payment`: Exposes CRUD operations for the **miniapp_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Miniapp_payments
    * const miniapp_payments = await prisma.miniapp_payment.findMany()
    * ```
    */
  get miniapp_payment(): Prisma.miniapp_paymentDelegate<ExtArgs>;

  /**
   * `prisma.miniapp_generation`: Exposes CRUD operations for the **miniapp_generation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Miniapp_generations
    * const miniapp_generations = await prisma.miniapp_generation.findMany()
    * ```
    */
  get miniapp_generation(): Prisma.miniapp_generationDelegate<ExtArgs>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs>;

  /**
   * `prisma.workflowModel`: Exposes CRUD operations for the **WorkflowModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowModels
    * const workflowModels = await prisma.workflowModel.findMany()
    * ```
    */
  get workflowModel(): Prisma.WorkflowModelDelegate<ExtArgs>;

  /**
   * `prisma.component_flat_file_recover`: Exposes CRUD operations for the **component_flat_file_recover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Component_flat_file_recovers
    * const component_flat_file_recovers = await prisma.component_flat_file_recover.findMany()
    * ```
    */
  get component_flat_file_recover(): Prisma.component_flat_file_recoverDelegate<ExtArgs>;

  /**
   * `prisma.social_link`: Exposes CRUD operations for the **social_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Social_links
    * const social_links = await prisma.social_link.findMany()
    * ```
    */
  get social_link(): Prisma.social_linkDelegate<ExtArgs>;

  /**
   * `prisma.custom_nodes`: Exposes CRUD operations for the **custom_nodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Custom_nodes
    * const custom_nodes = await prisma.custom_nodes.findMany()
    * ```
    */
  get custom_nodes(): Prisma.custom_nodesDelegate<ExtArgs>;

  /**
   * `prisma.workflow_custom_nodes`: Exposes CRUD operations for the **workflow_custom_nodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflow_custom_nodes
    * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findMany()
    * ```
    */
  get workflow_custom_nodes(): Prisma.workflow_custom_nodesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    assignment: 'assignment',
    collection: 'collection',
    collection_remix: 'collection_remix',
    event: 'event',
    flat_file: 'flat_file',
    component_flat_file: 'component_flat_file',
    project: 'project',
    project_history: 'project_history',
    role: 'role',
    wallet: 'wallet',
    credits_history: 'credits_history',
    credits_balance: 'credits_balance',
    subscription: 'subscription',
    customer: 'customer',
    product: 'product',
    project_template: 'project_template',
    project_template_save: 'project_template_save',
    collection_reward: 'collection_reward',
    collection_reward_redemption: 'collection_reward_redemption',
    collection_sales_receivers: 'collection_sales_receivers',
    collection_history: 'collection_history',
    profile: 'profile',
    collection_preview: 'collection_preview',
    collection_preview_version: 'collection_preview_version',
    collection_sample_images: 'collection_sample_images',
    chat: 'chat',
    chat_message: 'chat_message',
    socket_io_attachments: 'socket_io_attachments',
    component: 'component',
    workflow: 'workflow',
    server: 'server',
    form_config: 'form_config',
    api_key: 'api_key',
    user_api_keys: 'user_api_keys',
    job: 'job',
    job_history: 'job_history',
    miniapp_user: 'miniapp_user',
    miniapp_collection_config: 'miniapp_collection_config',
    miniapp_payment: 'miniapp_payment',
    miniapp_generation: 'miniapp_generation',
    Model: 'Model',
    WorkflowModel: 'WorkflowModel',
    component_flat_file_recover: 'component_flat_file_recover',
    social_link: 'social_link',
    custom_nodes: 'custom_nodes',
    workflow_custom_nodes: 'workflow_custom_nodes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "assignment" | "collection" | "collection_remix" | "event" | "flat_file" | "component_flat_file" | "project" | "project_history" | "role" | "wallet" | "credits_history" | "credits_balance" | "subscription" | "customer" | "product" | "project_template" | "project_template_save" | "collection_reward" | "collection_reward_redemption" | "collection_sales_receivers" | "collection_history" | "profile" | "collection_preview" | "collection_preview_version" | "collection_sample_images" | "chat" | "chat_message" | "socket_io_attachments" | "component" | "workflow" | "server" | "form_config" | "api_key" | "user_api_keys" | "job" | "job_history" | "miniapp_user" | "miniapp_collection_config" | "miniapp_payment" | "miniapp_generation" | "model" | "workflowModel" | "component_flat_file_recover" | "social_link" | "custom_nodes" | "workflow_custom_nodes"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      assignment: {
        payload: Prisma.$assignmentPayload<ExtArgs>
        fields: Prisma.assignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          findFirst: {
            args: Prisma.assignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          findMany: {
            args: Prisma.assignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>[]
          }
          create: {
            args: Prisma.assignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          createMany: {
            args: Prisma.assignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>[]
          }
          delete: {
            args: Prisma.assignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          update: {
            args: Prisma.assignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          deleteMany: {
            args: Prisma.assignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.assignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.assignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.assignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      collection: {
        payload: Prisma.$collectionPayload<ExtArgs>
        fields: Prisma.collectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>
          }
          findFirst: {
            args: Prisma.collectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>
          }
          findMany: {
            args: Prisma.collectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>[]
          }
          create: {
            args: Prisma.collectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>
          }
          createMany: {
            args: Prisma.collectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>[]
          }
          delete: {
            args: Prisma.collectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>
          }
          update: {
            args: Prisma.collectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>
          }
          deleteMany: {
            args: Prisma.collectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionPayload>
          }
          aggregate: {
            args: Prisma.CollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection>
          }
          groupBy: {
            args: Prisma.collectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.collectionCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCountAggregateOutputType> | number
          }
        }
      }
      collection_remix: {
        payload: Prisma.$collection_remixPayload<ExtArgs>
        fields: Prisma.collection_remixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_remixFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_remixFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>
          }
          findFirst: {
            args: Prisma.collection_remixFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_remixFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>
          }
          findMany: {
            args: Prisma.collection_remixFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>[]
          }
          create: {
            args: Prisma.collection_remixCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>
          }
          createMany: {
            args: Prisma.collection_remixCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_remixCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>[]
          }
          delete: {
            args: Prisma.collection_remixDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>
          }
          update: {
            args: Prisma.collection_remixUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>
          }
          deleteMany: {
            args: Prisma.collection_remixDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_remixUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_remixUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_remixPayload>
          }
          aggregate: {
            args: Prisma.Collection_remixAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_remix>
          }
          groupBy: {
            args: Prisma.collection_remixGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_remixGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_remixCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_remixCountAggregateOutputType> | number
          }
        }
      }
      event: {
        payload: Prisma.$eventPayload<ExtArgs>
        fields: Prisma.eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findFirst: {
            args: Prisma.eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findMany: {
            args: Prisma.eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          create: {
            args: Prisma.eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          createMany: {
            args: Prisma.eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.eventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          delete: {
            args: Prisma.eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          update: {
            args: Prisma.eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          deleteMany: {
            args: Prisma.eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      flat_file: {
        payload: Prisma.$flat_filePayload<ExtArgs>
        fields: Prisma.flat_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flat_fileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flat_fileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>
          }
          findFirst: {
            args: Prisma.flat_fileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flat_fileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>
          }
          findMany: {
            args: Prisma.flat_fileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>[]
          }
          create: {
            args: Prisma.flat_fileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>
          }
          createMany: {
            args: Prisma.flat_fileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.flat_fileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>[]
          }
          delete: {
            args: Prisma.flat_fileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>
          }
          update: {
            args: Prisma.flat_fileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>
          }
          deleteMany: {
            args: Prisma.flat_fileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flat_fileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.flat_fileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flat_filePayload>
          }
          aggregate: {
            args: Prisma.Flat_fileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlat_file>
          }
          groupBy: {
            args: Prisma.flat_fileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Flat_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.flat_fileCountArgs<ExtArgs>
            result: $Utils.Optional<Flat_fileCountAggregateOutputType> | number
          }
        }
      }
      component_flat_file: {
        payload: Prisma.$component_flat_filePayload<ExtArgs>
        fields: Prisma.component_flat_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.component_flat_fileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.component_flat_fileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>
          }
          findFirst: {
            args: Prisma.component_flat_fileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.component_flat_fileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>
          }
          findMany: {
            args: Prisma.component_flat_fileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>[]
          }
          create: {
            args: Prisma.component_flat_fileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>
          }
          createMany: {
            args: Prisma.component_flat_fileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.component_flat_fileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>[]
          }
          delete: {
            args: Prisma.component_flat_fileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>
          }
          update: {
            args: Prisma.component_flat_fileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>
          }
          deleteMany: {
            args: Prisma.component_flat_fileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.component_flat_fileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.component_flat_fileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_filePayload>
          }
          aggregate: {
            args: Prisma.Component_flat_fileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent_flat_file>
          }
          groupBy: {
            args: Prisma.component_flat_fileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Component_flat_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.component_flat_fileCountArgs<ExtArgs>
            result: $Utils.Optional<Component_flat_fileCountAggregateOutputType> | number
          }
        }
      }
      project: {
        payload: Prisma.$projectPayload<ExtArgs>
        fields: Prisma.projectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>
          }
          findFirst: {
            args: Prisma.projectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>
          }
          findMany: {
            args: Prisma.projectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>[]
          }
          create: {
            args: Prisma.projectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>
          }
          createMany: {
            args: Prisma.projectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>[]
          }
          delete: {
            args: Prisma.projectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>
          }
          update: {
            args: Prisma.projectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>
          }
          deleteMany: {
            args: Prisma.projectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.projectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      project_history: {
        payload: Prisma.$project_historyPayload<ExtArgs>
        fields: Prisma.project_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.project_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.project_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>
          }
          findFirst: {
            args: Prisma.project_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.project_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>
          }
          findMany: {
            args: Prisma.project_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>[]
          }
          create: {
            args: Prisma.project_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>
          }
          createMany: {
            args: Prisma.project_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.project_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>[]
          }
          delete: {
            args: Prisma.project_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>
          }
          update: {
            args: Prisma.project_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>
          }
          deleteMany: {
            args: Prisma.project_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.project_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.project_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_historyPayload>
          }
          aggregate: {
            args: Prisma.Project_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject_history>
          }
          groupBy: {
            args: Prisma.project_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Project_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.project_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Project_historyCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      wallet: {
        payload: Prisma.$walletPayload<ExtArgs>
        fields: Prisma.walletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findFirst: {
            args: Prisma.walletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findMany: {
            args: Prisma.walletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>[]
          }
          create: {
            args: Prisma.walletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          createMany: {
            args: Prisma.walletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.walletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>[]
          }
          delete: {
            args: Prisma.walletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          update: {
            args: Prisma.walletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          deleteMany: {
            args: Prisma.walletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.walletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.walletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.walletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      credits_history: {
        payload: Prisma.$credits_historyPayload<ExtArgs>
        fields: Prisma.credits_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credits_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credits_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>
          }
          findFirst: {
            args: Prisma.credits_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credits_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>
          }
          findMany: {
            args: Prisma.credits_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>[]
          }
          create: {
            args: Prisma.credits_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>
          }
          createMany: {
            args: Prisma.credits_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.credits_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>[]
          }
          delete: {
            args: Prisma.credits_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>
          }
          update: {
            args: Prisma.credits_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>
          }
          deleteMany: {
            args: Prisma.credits_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credits_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.credits_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_historyPayload>
          }
          aggregate: {
            args: Prisma.Credits_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredits_history>
          }
          groupBy: {
            args: Prisma.credits_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Credits_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.credits_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Credits_historyCountAggregateOutputType> | number
          }
        }
      }
      credits_balance: {
        payload: Prisma.$credits_balancePayload<ExtArgs>
        fields: Prisma.credits_balanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credits_balanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credits_balanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>
          }
          findFirst: {
            args: Prisma.credits_balanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credits_balanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>
          }
          findMany: {
            args: Prisma.credits_balanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>[]
          }
          create: {
            args: Prisma.credits_balanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>
          }
          createMany: {
            args: Prisma.credits_balanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.credits_balanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>[]
          }
          delete: {
            args: Prisma.credits_balanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>
          }
          update: {
            args: Prisma.credits_balanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>
          }
          deleteMany: {
            args: Prisma.credits_balanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credits_balanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.credits_balanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credits_balancePayload>
          }
          aggregate: {
            args: Prisma.Credits_balanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredits_balance>
          }
          groupBy: {
            args: Prisma.credits_balanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Credits_balanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.credits_balanceCountArgs<ExtArgs>
            result: $Utils.Optional<Credits_balanceCountAggregateOutputType> | number
          }
        }
      }
      subscription: {
        payload: Prisma.$subscriptionPayload<ExtArgs>
        fields: Prisma.subscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findFirst: {
            args: Prisma.subscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findMany: {
            args: Prisma.subscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          create: {
            args: Prisma.subscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          createMany: {
            args: Prisma.subscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          delete: {
            args: Prisma.subscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          update: {
            args: Prisma.subscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.subscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      project_template: {
        payload: Prisma.$project_templatePayload<ExtArgs>
        fields: Prisma.project_templateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.project_templateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.project_templateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>
          }
          findFirst: {
            args: Prisma.project_templateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.project_templateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>
          }
          findMany: {
            args: Prisma.project_templateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>[]
          }
          create: {
            args: Prisma.project_templateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>
          }
          createMany: {
            args: Prisma.project_templateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.project_templateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>[]
          }
          delete: {
            args: Prisma.project_templateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>
          }
          update: {
            args: Prisma.project_templateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>
          }
          deleteMany: {
            args: Prisma.project_templateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.project_templateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.project_templateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_templatePayload>
          }
          aggregate: {
            args: Prisma.Project_templateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject_template>
          }
          groupBy: {
            args: Prisma.project_templateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Project_templateGroupByOutputType>[]
          }
          count: {
            args: Prisma.project_templateCountArgs<ExtArgs>
            result: $Utils.Optional<Project_templateCountAggregateOutputType> | number
          }
        }
      }
      project_template_save: {
        payload: Prisma.$project_template_savePayload<ExtArgs>
        fields: Prisma.project_template_saveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.project_template_saveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.project_template_saveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>
          }
          findFirst: {
            args: Prisma.project_template_saveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.project_template_saveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>
          }
          findMany: {
            args: Prisma.project_template_saveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>[]
          }
          create: {
            args: Prisma.project_template_saveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>
          }
          createMany: {
            args: Prisma.project_template_saveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.project_template_saveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>[]
          }
          delete: {
            args: Prisma.project_template_saveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>
          }
          update: {
            args: Prisma.project_template_saveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>
          }
          deleteMany: {
            args: Prisma.project_template_saveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.project_template_saveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.project_template_saveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_template_savePayload>
          }
          aggregate: {
            args: Prisma.Project_template_saveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject_template_save>
          }
          groupBy: {
            args: Prisma.project_template_saveGroupByArgs<ExtArgs>
            result: $Utils.Optional<Project_template_saveGroupByOutputType>[]
          }
          count: {
            args: Prisma.project_template_saveCountArgs<ExtArgs>
            result: $Utils.Optional<Project_template_saveCountAggregateOutputType> | number
          }
        }
      }
      collection_reward: {
        payload: Prisma.$collection_rewardPayload<ExtArgs>
        fields: Prisma.collection_rewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_rewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_rewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>
          }
          findFirst: {
            args: Prisma.collection_rewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_rewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>
          }
          findMany: {
            args: Prisma.collection_rewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>[]
          }
          create: {
            args: Prisma.collection_rewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>
          }
          createMany: {
            args: Prisma.collection_rewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_rewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>[]
          }
          delete: {
            args: Prisma.collection_rewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>
          }
          update: {
            args: Prisma.collection_rewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>
          }
          deleteMany: {
            args: Prisma.collection_rewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_rewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_rewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_rewardPayload>
          }
          aggregate: {
            args: Prisma.Collection_rewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_reward>
          }
          groupBy: {
            args: Prisma.collection_rewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_rewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_rewardCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_rewardCountAggregateOutputType> | number
          }
        }
      }
      collection_reward_redemption: {
        payload: Prisma.$collection_reward_redemptionPayload<ExtArgs>
        fields: Prisma.collection_reward_redemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_reward_redemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_reward_redemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>
          }
          findFirst: {
            args: Prisma.collection_reward_redemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_reward_redemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>
          }
          findMany: {
            args: Prisma.collection_reward_redemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>[]
          }
          create: {
            args: Prisma.collection_reward_redemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>
          }
          createMany: {
            args: Prisma.collection_reward_redemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_reward_redemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>[]
          }
          delete: {
            args: Prisma.collection_reward_redemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>
          }
          update: {
            args: Prisma.collection_reward_redemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>
          }
          deleteMany: {
            args: Prisma.collection_reward_redemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_reward_redemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_reward_redemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_reward_redemptionPayload>
          }
          aggregate: {
            args: Prisma.Collection_reward_redemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_reward_redemption>
          }
          groupBy: {
            args: Prisma.collection_reward_redemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_reward_redemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_reward_redemptionCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_reward_redemptionCountAggregateOutputType> | number
          }
        }
      }
      collection_sales_receivers: {
        payload: Prisma.$collection_sales_receiversPayload<ExtArgs>
        fields: Prisma.collection_sales_receiversFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_sales_receiversFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_sales_receiversFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>
          }
          findFirst: {
            args: Prisma.collection_sales_receiversFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_sales_receiversFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>
          }
          findMany: {
            args: Prisma.collection_sales_receiversFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>[]
          }
          create: {
            args: Prisma.collection_sales_receiversCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>
          }
          createMany: {
            args: Prisma.collection_sales_receiversCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_sales_receiversCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>[]
          }
          delete: {
            args: Prisma.collection_sales_receiversDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>
          }
          update: {
            args: Prisma.collection_sales_receiversUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>
          }
          deleteMany: {
            args: Prisma.collection_sales_receiversDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_sales_receiversUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_sales_receiversUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sales_receiversPayload>
          }
          aggregate: {
            args: Prisma.Collection_sales_receiversAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_sales_receivers>
          }
          groupBy: {
            args: Prisma.collection_sales_receiversGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_sales_receiversGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_sales_receiversCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_sales_receiversCountAggregateOutputType> | number
          }
        }
      }
      collection_history: {
        payload: Prisma.$collection_historyPayload<ExtArgs>
        fields: Prisma.collection_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>
          }
          findFirst: {
            args: Prisma.collection_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>
          }
          findMany: {
            args: Prisma.collection_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>[]
          }
          create: {
            args: Prisma.collection_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>
          }
          createMany: {
            args: Prisma.collection_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>[]
          }
          delete: {
            args: Prisma.collection_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>
          }
          update: {
            args: Prisma.collection_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>
          }
          deleteMany: {
            args: Prisma.collection_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_historyPayload>
          }
          aggregate: {
            args: Prisma.Collection_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_history>
          }
          groupBy: {
            args: Prisma.collection_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_historyCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: Prisma.$profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.profileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      collection_preview: {
        payload: Prisma.$collection_previewPayload<ExtArgs>
        fields: Prisma.collection_previewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_previewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_previewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>
          }
          findFirst: {
            args: Prisma.collection_previewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_previewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>
          }
          findMany: {
            args: Prisma.collection_previewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>[]
          }
          create: {
            args: Prisma.collection_previewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>
          }
          createMany: {
            args: Prisma.collection_previewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_previewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>[]
          }
          delete: {
            args: Prisma.collection_previewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>
          }
          update: {
            args: Prisma.collection_previewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>
          }
          deleteMany: {
            args: Prisma.collection_previewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_previewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_previewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_previewPayload>
          }
          aggregate: {
            args: Prisma.Collection_previewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_preview>
          }
          groupBy: {
            args: Prisma.collection_previewGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_previewGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_previewCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_previewCountAggregateOutputType> | number
          }
        }
      }
      collection_preview_version: {
        payload: Prisma.$collection_preview_versionPayload<ExtArgs>
        fields: Prisma.collection_preview_versionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_preview_versionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_preview_versionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>
          }
          findFirst: {
            args: Prisma.collection_preview_versionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_preview_versionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>
          }
          findMany: {
            args: Prisma.collection_preview_versionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>[]
          }
          create: {
            args: Prisma.collection_preview_versionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>
          }
          createMany: {
            args: Prisma.collection_preview_versionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_preview_versionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>[]
          }
          delete: {
            args: Prisma.collection_preview_versionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>
          }
          update: {
            args: Prisma.collection_preview_versionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>
          }
          deleteMany: {
            args: Prisma.collection_preview_versionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_preview_versionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_preview_versionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_preview_versionPayload>
          }
          aggregate: {
            args: Prisma.Collection_preview_versionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_preview_version>
          }
          groupBy: {
            args: Prisma.collection_preview_versionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_preview_versionGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_preview_versionCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_preview_versionCountAggregateOutputType> | number
          }
        }
      }
      collection_sample_images: {
        payload: Prisma.$collection_sample_imagesPayload<ExtArgs>
        fields: Prisma.collection_sample_imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collection_sample_imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collection_sample_imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>
          }
          findFirst: {
            args: Prisma.collection_sample_imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collection_sample_imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>
          }
          findMany: {
            args: Prisma.collection_sample_imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>[]
          }
          create: {
            args: Prisma.collection_sample_imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>
          }
          createMany: {
            args: Prisma.collection_sample_imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collection_sample_imagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>[]
          }
          delete: {
            args: Prisma.collection_sample_imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>
          }
          update: {
            args: Prisma.collection_sample_imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>
          }
          deleteMany: {
            args: Prisma.collection_sample_imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collection_sample_imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collection_sample_imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collection_sample_imagesPayload>
          }
          aggregate: {
            args: Prisma.Collection_sample_imagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection_sample_images>
          }
          groupBy: {
            args: Prisma.collection_sample_imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collection_sample_imagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.collection_sample_imagesCountArgs<ExtArgs>
            result: $Utils.Optional<Collection_sample_imagesCountAggregateOutputType> | number
          }
        }
      }
      chat: {
        payload: Prisma.$chatPayload<ExtArgs>
        fields: Prisma.chatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          findFirst: {
            args: Prisma.chatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          findMany: {
            args: Prisma.chatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>[]
          }
          create: {
            args: Prisma.chatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          createMany: {
            args: Prisma.chatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>[]
          }
          delete: {
            args: Prisma.chatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          update: {
            args: Prisma.chatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          deleteMany: {
            args: Prisma.chatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.chatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      chat_message: {
        payload: Prisma.$chat_messagePayload<ExtArgs>
        fields: Prisma.chat_messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>
          }
          findFirst: {
            args: Prisma.chat_messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>
          }
          findMany: {
            args: Prisma.chat_messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>[]
          }
          create: {
            args: Prisma.chat_messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>
          }
          createMany: {
            args: Prisma.chat_messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>[]
          }
          delete: {
            args: Prisma.chat_messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>
          }
          update: {
            args: Prisma.chat_messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>
          }
          deleteMany: {
            args: Prisma.chat_messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chat_messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagePayload>
          }
          aggregate: {
            args: Prisma.Chat_messageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_message>
          }
          groupBy: {
            args: Prisma.chat_messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_messageGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_messageCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_messageCountAggregateOutputType> | number
          }
        }
      }
      socket_io_attachments: {
        payload: Prisma.$socket_io_attachmentsPayload<ExtArgs>
        fields: Prisma.socket_io_attachmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.socket_io_attachmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.socket_io_attachmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>
          }
          findFirst: {
            args: Prisma.socket_io_attachmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.socket_io_attachmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>
          }
          findMany: {
            args: Prisma.socket_io_attachmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>[]
          }
          create: {
            args: Prisma.socket_io_attachmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>
          }
          createMany: {
            args: Prisma.socket_io_attachmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.socket_io_attachmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>[]
          }
          delete: {
            args: Prisma.socket_io_attachmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>
          }
          update: {
            args: Prisma.socket_io_attachmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>
          }
          deleteMany: {
            args: Prisma.socket_io_attachmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.socket_io_attachmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.socket_io_attachmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$socket_io_attachmentsPayload>
          }
          aggregate: {
            args: Prisma.Socket_io_attachmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocket_io_attachments>
          }
          groupBy: {
            args: Prisma.socket_io_attachmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Socket_io_attachmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.socket_io_attachmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Socket_io_attachmentsCountAggregateOutputType> | number
          }
        }
      }
      component: {
        payload: Prisma.$componentPayload<ExtArgs>
        fields: Prisma.componentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.componentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.componentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>
          }
          findFirst: {
            args: Prisma.componentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.componentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>
          }
          findMany: {
            args: Prisma.componentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>[]
          }
          create: {
            args: Prisma.componentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>
          }
          createMany: {
            args: Prisma.componentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.componentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>[]
          }
          delete: {
            args: Prisma.componentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>
          }
          update: {
            args: Prisma.componentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>
          }
          deleteMany: {
            args: Prisma.componentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.componentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.componentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$componentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.componentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.componentCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      workflow: {
        payload: Prisma.$workflowPayload<ExtArgs>
        fields: Prisma.workflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.workflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.workflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>
          }
          findFirst: {
            args: Prisma.workflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.workflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>
          }
          findMany: {
            args: Prisma.workflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>[]
          }
          create: {
            args: Prisma.workflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>
          }
          createMany: {
            args: Prisma.workflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.workflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>[]
          }
          delete: {
            args: Prisma.workflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>
          }
          update: {
            args: Prisma.workflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>
          }
          deleteMany: {
            args: Prisma.workflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.workflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.workflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.workflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.workflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      server: {
        payload: Prisma.$serverPayload<ExtArgs>
        fields: Prisma.serverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>
          }
          findFirst: {
            args: Prisma.serverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>
          }
          findMany: {
            args: Prisma.serverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>[]
          }
          create: {
            args: Prisma.serverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>
          }
          createMany: {
            args: Prisma.serverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.serverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>[]
          }
          delete: {
            args: Prisma.serverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>
          }
          update: {
            args: Prisma.serverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>
          }
          deleteMany: {
            args: Prisma.serverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverPayload>
          }
          aggregate: {
            args: Prisma.ServerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServer>
          }
          groupBy: {
            args: Prisma.serverGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServerGroupByOutputType>[]
          }
          count: {
            args: Prisma.serverCountArgs<ExtArgs>
            result: $Utils.Optional<ServerCountAggregateOutputType> | number
          }
        }
      }
      form_config: {
        payload: Prisma.$form_configPayload<ExtArgs>
        fields: Prisma.form_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.form_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.form_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>
          }
          findFirst: {
            args: Prisma.form_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.form_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>
          }
          findMany: {
            args: Prisma.form_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>[]
          }
          create: {
            args: Prisma.form_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>
          }
          createMany: {
            args: Prisma.form_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.form_configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>[]
          }
          delete: {
            args: Prisma.form_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>
          }
          update: {
            args: Prisma.form_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>
          }
          deleteMany: {
            args: Prisma.form_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.form_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.form_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$form_configPayload>
          }
          aggregate: {
            args: Prisma.Form_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm_config>
          }
          groupBy: {
            args: Prisma.form_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Form_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.form_configCountArgs<ExtArgs>
            result: $Utils.Optional<Form_configCountAggregateOutputType> | number
          }
        }
      }
      api_key: {
        payload: Prisma.$api_keyPayload<ExtArgs>
        fields: Prisma.api_keyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.api_keyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.api_keyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>
          }
          findFirst: {
            args: Prisma.api_keyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.api_keyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>
          }
          findMany: {
            args: Prisma.api_keyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>[]
          }
          create: {
            args: Prisma.api_keyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>
          }
          createMany: {
            args: Prisma.api_keyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.api_keyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>[]
          }
          delete: {
            args: Prisma.api_keyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>
          }
          update: {
            args: Prisma.api_keyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>
          }
          deleteMany: {
            args: Prisma.api_keyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.api_keyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.api_keyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_keyPayload>
          }
          aggregate: {
            args: Prisma.Api_keyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApi_key>
          }
          groupBy: {
            args: Prisma.api_keyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Api_keyGroupByOutputType>[]
          }
          count: {
            args: Prisma.api_keyCountArgs<ExtArgs>
            result: $Utils.Optional<Api_keyCountAggregateOutputType> | number
          }
        }
      }
      user_api_keys: {
        payload: Prisma.$user_api_keysPayload<ExtArgs>
        fields: Prisma.user_api_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_api_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_api_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>
          }
          findFirst: {
            args: Prisma.user_api_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_api_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>
          }
          findMany: {
            args: Prisma.user_api_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>[]
          }
          create: {
            args: Prisma.user_api_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>
          }
          createMany: {
            args: Prisma.user_api_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_api_keysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>[]
          }
          delete: {
            args: Prisma.user_api_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>
          }
          update: {
            args: Prisma.user_api_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>
          }
          deleteMany: {
            args: Prisma.user_api_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_api_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_api_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_api_keysPayload>
          }
          aggregate: {
            args: Prisma.User_api_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_api_keys>
          }
          groupBy: {
            args: Prisma.user_api_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_api_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_api_keysCountArgs<ExtArgs>
            result: $Utils.Optional<User_api_keysCountAggregateOutputType> | number
          }
        }
      }
      job: {
        payload: Prisma.$jobPayload<ExtArgs>
        fields: Prisma.jobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findFirst: {
            args: Prisma.jobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findMany: {
            args: Prisma.jobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          create: {
            args: Prisma.jobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          createMany: {
            args: Prisma.jobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          delete: {
            args: Prisma.jobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          update: {
            args: Prisma.jobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          deleteMany: {
            args: Prisma.jobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.jobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      job_history: {
        payload: Prisma.$job_historyPayload<ExtArgs>
        fields: Prisma.job_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>
          }
          findFirst: {
            args: Prisma.job_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>
          }
          findMany: {
            args: Prisma.job_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>[]
          }
          create: {
            args: Prisma.job_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>
          }
          createMany: {
            args: Prisma.job_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>[]
          }
          delete: {
            args: Prisma.job_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>
          }
          update: {
            args: Prisma.job_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>
          }
          deleteMany: {
            args: Prisma.job_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.job_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_historyPayload>
          }
          aggregate: {
            args: Prisma.Job_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_history>
          }
          groupBy: {
            args: Prisma.job_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Job_historyCountAggregateOutputType> | number
          }
        }
      }
      miniapp_user: {
        payload: Prisma.$miniapp_userPayload<ExtArgs>
        fields: Prisma.miniapp_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.miniapp_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.miniapp_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>
          }
          findFirst: {
            args: Prisma.miniapp_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.miniapp_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>
          }
          findMany: {
            args: Prisma.miniapp_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>[]
          }
          create: {
            args: Prisma.miniapp_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>
          }
          createMany: {
            args: Prisma.miniapp_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.miniapp_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>[]
          }
          delete: {
            args: Prisma.miniapp_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>
          }
          update: {
            args: Prisma.miniapp_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>
          }
          deleteMany: {
            args: Prisma.miniapp_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.miniapp_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.miniapp_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_userPayload>
          }
          aggregate: {
            args: Prisma.Miniapp_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiniapp_user>
          }
          groupBy: {
            args: Prisma.miniapp_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.miniapp_userCountArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_userCountAggregateOutputType> | number
          }
        }
      }
      miniapp_collection_config: {
        payload: Prisma.$miniapp_collection_configPayload<ExtArgs>
        fields: Prisma.miniapp_collection_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.miniapp_collection_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.miniapp_collection_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>
          }
          findFirst: {
            args: Prisma.miniapp_collection_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.miniapp_collection_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>
          }
          findMany: {
            args: Prisma.miniapp_collection_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>[]
          }
          create: {
            args: Prisma.miniapp_collection_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>
          }
          createMany: {
            args: Prisma.miniapp_collection_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.miniapp_collection_configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>[]
          }
          delete: {
            args: Prisma.miniapp_collection_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>
          }
          update: {
            args: Prisma.miniapp_collection_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>
          }
          deleteMany: {
            args: Prisma.miniapp_collection_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.miniapp_collection_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.miniapp_collection_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_collection_configPayload>
          }
          aggregate: {
            args: Prisma.Miniapp_collection_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiniapp_collection_config>
          }
          groupBy: {
            args: Prisma.miniapp_collection_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_collection_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.miniapp_collection_configCountArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_collection_configCountAggregateOutputType> | number
          }
        }
      }
      miniapp_payment: {
        payload: Prisma.$miniapp_paymentPayload<ExtArgs>
        fields: Prisma.miniapp_paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.miniapp_paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.miniapp_paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>
          }
          findFirst: {
            args: Prisma.miniapp_paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.miniapp_paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>
          }
          findMany: {
            args: Prisma.miniapp_paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>[]
          }
          create: {
            args: Prisma.miniapp_paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>
          }
          createMany: {
            args: Prisma.miniapp_paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.miniapp_paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>[]
          }
          delete: {
            args: Prisma.miniapp_paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>
          }
          update: {
            args: Prisma.miniapp_paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>
          }
          deleteMany: {
            args: Prisma.miniapp_paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.miniapp_paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.miniapp_paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_paymentPayload>
          }
          aggregate: {
            args: Prisma.Miniapp_paymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiniapp_payment>
          }
          groupBy: {
            args: Prisma.miniapp_paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_paymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.miniapp_paymentCountArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_paymentCountAggregateOutputType> | number
          }
        }
      }
      miniapp_generation: {
        payload: Prisma.$miniapp_generationPayload<ExtArgs>
        fields: Prisma.miniapp_generationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.miniapp_generationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.miniapp_generationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>
          }
          findFirst: {
            args: Prisma.miniapp_generationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.miniapp_generationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>
          }
          findMany: {
            args: Prisma.miniapp_generationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>[]
          }
          create: {
            args: Prisma.miniapp_generationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>
          }
          createMany: {
            args: Prisma.miniapp_generationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.miniapp_generationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>[]
          }
          delete: {
            args: Prisma.miniapp_generationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>
          }
          update: {
            args: Prisma.miniapp_generationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>
          }
          deleteMany: {
            args: Prisma.miniapp_generationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.miniapp_generationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.miniapp_generationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$miniapp_generationPayload>
          }
          aggregate: {
            args: Prisma.Miniapp_generationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiniapp_generation>
          }
          groupBy: {
            args: Prisma.miniapp_generationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_generationGroupByOutputType>[]
          }
          count: {
            args: Prisma.miniapp_generationCountArgs<ExtArgs>
            result: $Utils.Optional<Miniapp_generationCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      WorkflowModel: {
        payload: Prisma.$WorkflowModelPayload<ExtArgs>
        fields: Prisma.WorkflowModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>
          }
          findFirst: {
            args: Prisma.WorkflowModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>
          }
          findMany: {
            args: Prisma.WorkflowModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>[]
          }
          create: {
            args: Prisma.WorkflowModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>
          }
          createMany: {
            args: Prisma.WorkflowModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>[]
          }
          delete: {
            args: Prisma.WorkflowModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>
          }
          update: {
            args: Prisma.WorkflowModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowModelPayload>
          }
          aggregate: {
            args: Prisma.WorkflowModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowModel>
          }
          groupBy: {
            args: Prisma.WorkflowModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowModelCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowModelCountAggregateOutputType> | number
          }
        }
      }
      component_flat_file_recover: {
        payload: Prisma.$component_flat_file_recoverPayload<ExtArgs>
        fields: Prisma.component_flat_file_recoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.component_flat_file_recoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.component_flat_file_recoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>
          }
          findFirst: {
            args: Prisma.component_flat_file_recoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.component_flat_file_recoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>
          }
          findMany: {
            args: Prisma.component_flat_file_recoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>[]
          }
          create: {
            args: Prisma.component_flat_file_recoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>
          }
          createMany: {
            args: Prisma.component_flat_file_recoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.component_flat_file_recoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>[]
          }
          delete: {
            args: Prisma.component_flat_file_recoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>
          }
          update: {
            args: Prisma.component_flat_file_recoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>
          }
          deleteMany: {
            args: Prisma.component_flat_file_recoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.component_flat_file_recoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.component_flat_file_recoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$component_flat_file_recoverPayload>
          }
          aggregate: {
            args: Prisma.Component_flat_file_recoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent_flat_file_recover>
          }
          groupBy: {
            args: Prisma.component_flat_file_recoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<Component_flat_file_recoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.component_flat_file_recoverCountArgs<ExtArgs>
            result: $Utils.Optional<Component_flat_file_recoverCountAggregateOutputType> | number
          }
        }
      }
      social_link: {
        payload: Prisma.$social_linkPayload<ExtArgs>
        fields: Prisma.social_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.social_linkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.social_linkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>
          }
          findFirst: {
            args: Prisma.social_linkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.social_linkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>
          }
          findMany: {
            args: Prisma.social_linkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>[]
          }
          create: {
            args: Prisma.social_linkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>
          }
          createMany: {
            args: Prisma.social_linkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.social_linkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>[]
          }
          delete: {
            args: Prisma.social_linkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>
          }
          update: {
            args: Prisma.social_linkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>
          }
          deleteMany: {
            args: Prisma.social_linkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.social_linkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.social_linkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$social_linkPayload>
          }
          aggregate: {
            args: Prisma.Social_linkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocial_link>
          }
          groupBy: {
            args: Prisma.social_linkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Social_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.social_linkCountArgs<ExtArgs>
            result: $Utils.Optional<Social_linkCountAggregateOutputType> | number
          }
        }
      }
      custom_nodes: {
        payload: Prisma.$custom_nodesPayload<ExtArgs>
        fields: Prisma.custom_nodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.custom_nodesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.custom_nodesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>
          }
          findFirst: {
            args: Prisma.custom_nodesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.custom_nodesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>
          }
          findMany: {
            args: Prisma.custom_nodesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>[]
          }
          create: {
            args: Prisma.custom_nodesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>
          }
          createMany: {
            args: Prisma.custom_nodesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.custom_nodesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>[]
          }
          delete: {
            args: Prisma.custom_nodesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>
          }
          update: {
            args: Prisma.custom_nodesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>
          }
          deleteMany: {
            args: Prisma.custom_nodesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.custom_nodesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.custom_nodesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$custom_nodesPayload>
          }
          aggregate: {
            args: Prisma.Custom_nodesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustom_nodes>
          }
          groupBy: {
            args: Prisma.custom_nodesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Custom_nodesGroupByOutputType>[]
          }
          count: {
            args: Prisma.custom_nodesCountArgs<ExtArgs>
            result: $Utils.Optional<Custom_nodesCountAggregateOutputType> | number
          }
        }
      }
      workflow_custom_nodes: {
        payload: Prisma.$workflow_custom_nodesPayload<ExtArgs>
        fields: Prisma.workflow_custom_nodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.workflow_custom_nodesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.workflow_custom_nodesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>
          }
          findFirst: {
            args: Prisma.workflow_custom_nodesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.workflow_custom_nodesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>
          }
          findMany: {
            args: Prisma.workflow_custom_nodesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>[]
          }
          create: {
            args: Prisma.workflow_custom_nodesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>
          }
          createMany: {
            args: Prisma.workflow_custom_nodesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.workflow_custom_nodesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>[]
          }
          delete: {
            args: Prisma.workflow_custom_nodesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>
          }
          update: {
            args: Prisma.workflow_custom_nodesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>
          }
          deleteMany: {
            args: Prisma.workflow_custom_nodesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.workflow_custom_nodesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.workflow_custom_nodesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workflow_custom_nodesPayload>
          }
          aggregate: {
            args: Prisma.Workflow_custom_nodesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow_custom_nodes>
          }
          groupBy: {
            args: Prisma.workflow_custom_nodesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Workflow_custom_nodesGroupByOutputType>[]
          }
          count: {
            args: Prisma.workflow_custom_nodesCountArgs<ExtArgs>
            result: $Utils.Optional<Workflow_custom_nodesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CollectionCountOutputType
   */

  export type CollectionCountOutputType = {
    collection_history: number
    source_remix: number
    target_remix: number
    collection_sales_receivers: number
    collection_sample_images: number
    collection_node: number
    miniapp_generation: number
    miniapp_payment: number
  }

  export type CollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_history?: boolean | CollectionCountOutputTypeCountCollection_historyArgs
    source_remix?: boolean | CollectionCountOutputTypeCountSource_remixArgs
    target_remix?: boolean | CollectionCountOutputTypeCountTarget_remixArgs
    collection_sales_receivers?: boolean | CollectionCountOutputTypeCountCollection_sales_receiversArgs
    collection_sample_images?: boolean | CollectionCountOutputTypeCountCollection_sample_imagesArgs
    collection_node?: boolean | CollectionCountOutputTypeCountCollection_nodeArgs
    miniapp_generation?: boolean | CollectionCountOutputTypeCountMiniapp_generationArgs
    miniapp_payment?: boolean | CollectionCountOutputTypeCountMiniapp_paymentArgs
  }

  // Custom InputTypes
  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountCollection_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_historyWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountSource_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_remixWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountTarget_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_remixWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountCollection_sales_receiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_sales_receiversWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountCollection_sample_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_sample_imagesWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountCollection_nodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: componentWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountMiniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_generationWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountMiniapp_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_paymentWhereInput
  }


  /**
   * Count Type Flat_fileCountOutputType
   */

  export type Flat_fileCountOutputType = {
    chat_message: number
    component_flat_files: number
  }

  export type Flat_fileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_message?: boolean | Flat_fileCountOutputTypeCountChat_messageArgs
    component_flat_files?: boolean | Flat_fileCountOutputTypeCountComponent_flat_filesArgs
  }

  // Custom InputTypes
  /**
   * Flat_fileCountOutputType without action
   */
  export type Flat_fileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flat_fileCountOutputType
     */
    select?: Flat_fileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Flat_fileCountOutputType without action
   */
  export type Flat_fileCountOutputTypeCountChat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messageWhereInput
  }

  /**
   * Flat_fileCountOutputType without action
   */
  export type Flat_fileCountOutputTypeCountComponent_flat_filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: component_flat_fileWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    collection: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | ProjectCountOutputTypeCountCollectionArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectionWhereInput
  }


  /**
   * Count Type Project_templateCountOutputType
   */

  export type Project_templateCountOutputType = {
    project_template_save: number
  }

  export type Project_templateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_template_save?: boolean | Project_templateCountOutputTypeCountProject_template_saveArgs
  }

  // Custom InputTypes
  /**
   * Project_templateCountOutputType without action
   */
  export type Project_templateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project_templateCountOutputType
     */
    select?: Project_templateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Project_templateCountOutputType without action
   */
  export type Project_templateCountOutputTypeCountProject_template_saveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_template_saveWhereInput
  }


  /**
   * Count Type Collection_rewardCountOutputType
   */

  export type Collection_rewardCountOutputType = {
    collection_reward_redemption: number
  }

  export type Collection_rewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_reward_redemption?: boolean | Collection_rewardCountOutputTypeCountCollection_reward_redemptionArgs
  }

  // Custom InputTypes
  /**
   * Collection_rewardCountOutputType without action
   */
  export type Collection_rewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection_rewardCountOutputType
     */
    select?: Collection_rewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Collection_rewardCountOutputType without action
   */
  export type Collection_rewardCountOutputTypeCountCollection_reward_redemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_reward_redemptionWhereInput
  }


  /**
   * Count Type Collection_previewCountOutputType
   */

  export type Collection_previewCountOutputType = {
    collection_preview_version: number
  }

  export type Collection_previewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_preview_version?: boolean | Collection_previewCountOutputTypeCountCollection_preview_versionArgs
  }

  // Custom InputTypes
  /**
   * Collection_previewCountOutputType without action
   */
  export type Collection_previewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection_previewCountOutputType
     */
    select?: Collection_previewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Collection_previewCountOutputType without action
   */
  export type Collection_previewCountOutputTypeCountCollection_preview_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_preview_versionWhereInput
  }


  /**
   * Count Type Collection_preview_versionCountOutputType
   */

  export type Collection_preview_versionCountOutputType = {
    collection_remix: number
  }

  export type Collection_preview_versionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_remix?: boolean | Collection_preview_versionCountOutputTypeCountCollection_remixArgs
  }

  // Custom InputTypes
  /**
   * Collection_preview_versionCountOutputType without action
   */
  export type Collection_preview_versionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection_preview_versionCountOutputType
     */
    select?: Collection_preview_versionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Collection_preview_versionCountOutputType without action
   */
  export type Collection_preview_versionCountOutputTypeCountCollection_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_remixWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    chat_message: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_message?: boolean | ChatCountOutputTypeCountChat_messageArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountChat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messageWhereInput
  }


  /**
   * Count Type ComponentCountOutputType
   */

  export type ComponentCountOutputType = {
    component_flat_files: number
  }

  export type ComponentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component_flat_files?: boolean | ComponentCountOutputTypeCountComponent_flat_filesArgs
  }

  // Custom InputTypes
  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentCountOutputType
     */
    select?: ComponentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountComponent_flat_filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: component_flat_fileWhereInput
  }


  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    workflow_custom_nodes: number
    workflow_models: number
  }

  export type WorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow_custom_nodes?: boolean | WorkflowCountOutputTypeCountWorkflow_custom_nodesArgs
    workflow_models?: boolean | WorkflowCountOutputTypeCountWorkflow_modelsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountWorkflow_custom_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workflow_custom_nodesWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountWorkflow_modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowModelWhereInput
  }


  /**
   * Count Type ServerCountOutputType
   */

  export type ServerCountOutputType = {
    workflow: number
  }

  export type ServerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | ServerCountOutputTypeCountWorkflowArgs
  }

  // Custom InputTypes
  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServerCountOutputType
     */
    select?: ServerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServerCountOutputType without action
   */
  export type ServerCountOutputTypeCountWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workflowWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    job_history: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_history?: boolean | JobCountOutputTypeCountJob_historyArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_historyWhereInput
  }


  /**
   * Count Type Miniapp_userCountOutputType
   */

  export type Miniapp_userCountOutputType = {
    miniapp_generation: number
    miniapp_payment: number
    social_links: number
  }

  export type Miniapp_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniapp_generation?: boolean | Miniapp_userCountOutputTypeCountMiniapp_generationArgs
    miniapp_payment?: boolean | Miniapp_userCountOutputTypeCountMiniapp_paymentArgs
    social_links?: boolean | Miniapp_userCountOutputTypeCountSocial_linksArgs
  }

  // Custom InputTypes
  /**
   * Miniapp_userCountOutputType without action
   */
  export type Miniapp_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Miniapp_userCountOutputType
     */
    select?: Miniapp_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Miniapp_userCountOutputType without action
   */
  export type Miniapp_userCountOutputTypeCountMiniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_generationWhereInput
  }

  /**
   * Miniapp_userCountOutputType without action
   */
  export type Miniapp_userCountOutputTypeCountMiniapp_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_paymentWhereInput
  }

  /**
   * Miniapp_userCountOutputType without action
   */
  export type Miniapp_userCountOutputTypeCountSocial_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_linkWhereInput
  }


  /**
   * Count Type Miniapp_paymentCountOutputType
   */

  export type Miniapp_paymentCountOutputType = {
    miniapp_generation: number
  }

  export type Miniapp_paymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniapp_generation?: boolean | Miniapp_paymentCountOutputTypeCountMiniapp_generationArgs
  }

  // Custom InputTypes
  /**
   * Miniapp_paymentCountOutputType without action
   */
  export type Miniapp_paymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Miniapp_paymentCountOutputType
     */
    select?: Miniapp_paymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Miniapp_paymentCountOutputType without action
   */
  export type Miniapp_paymentCountOutputTypeCountMiniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_generationWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    workflowModels: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowModels?: boolean | ModelCountOutputTypeCountWorkflowModelsArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountWorkflowModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowModelWhereInput
  }


  /**
   * Count Type Social_linkCountOutputType
   */

  export type Social_linkCountOutputType = {
    custodial_collections: number
  }

  export type Social_linkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    custodial_collections?: boolean | Social_linkCountOutputTypeCountCustodial_collectionsArgs
  }

  // Custom InputTypes
  /**
   * Social_linkCountOutputType without action
   */
  export type Social_linkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social_linkCountOutputType
     */
    select?: Social_linkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Social_linkCountOutputType without action
   */
  export type Social_linkCountOutputTypeCountCustodial_collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectionWhereInput
  }


  /**
   * Count Type Custom_nodesCountOutputType
   */

  export type Custom_nodesCountOutputType = {
    workflow_custom_nodes: number
  }

  export type Custom_nodesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow_custom_nodes?: boolean | Custom_nodesCountOutputTypeCountWorkflow_custom_nodesArgs
  }

  // Custom InputTypes
  /**
   * Custom_nodesCountOutputType without action
   */
  export type Custom_nodesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Custom_nodesCountOutputType
     */
    select?: Custom_nodesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Custom_nodesCountOutputType without action
   */
  export type Custom_nodesCountOutputTypeCountWorkflow_custom_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workflow_custom_nodesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    id: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    id: bigint | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    address: string | null
    token_id: string | null
    created_at: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    address: string | null
    token_id: string | null
    created_at: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    user_id: number
    address: number
    token_id: number
    created_at: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    id?: true
  }

  export type AssignmentSumAggregateInputType = {
    id?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    user_id?: true
    address?: true
    token_id?: true
    created_at?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    user_id?: true
    address?: true
    token_id?: true
    created_at?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    user_id?: true
    address?: true
    token_id?: true
    created_at?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignment to aggregate.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type assignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentWhereInput
    orderBy?: assignmentOrderByWithAggregationInput | assignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: assignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: bigint
    user_id: string | null
    address: string | null
    token_id: string | null
    created_at: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends assignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type assignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    address?: boolean
    token_id?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["assignment"]>

  export type assignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    address?: boolean
    token_id?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["assignment"]>

  export type assignmentSelectScalar = {
    id?: boolean
    user_id?: boolean
    address?: boolean
    token_id?: boolean
    created_at?: boolean
  }


  export type $assignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assignment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: string | null
      address: string | null
      token_id: string | null
      created_at: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type assignmentGetPayload<S extends boolean | null | undefined | assignmentDefaultArgs> = $Result.GetResult<Prisma.$assignmentPayload, S>

  type assignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<assignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface assignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assignment'], meta: { name: 'assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {assignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assignmentFindUniqueArgs>(args: SelectSubset<T, assignmentFindUniqueArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {assignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, assignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assignmentFindFirstArgs>(args?: SelectSubset<T, assignmentFindFirstArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, assignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends assignmentFindManyArgs>(args?: SelectSubset<T, assignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assignment.
     * @param {assignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends assignmentCreateArgs>(args: SelectSubset<T, assignmentCreateArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assignments.
     * @param {assignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assignmentCreateManyArgs>(args?: SelectSubset<T, assignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {assignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, assignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Assignment.
     * @param {assignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends assignmentDeleteArgs>(args: SelectSubset<T, assignmentDeleteArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assignment.
     * @param {assignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assignmentUpdateArgs>(args: SelectSubset<T, assignmentUpdateArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assignments.
     * @param {assignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assignmentDeleteManyArgs>(args?: SelectSubset<T, assignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assignmentUpdateManyArgs>(args: SelectSubset<T, assignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {assignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends assignmentUpsertArgs>(args: SelectSubset<T, assignmentUpsertArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends assignmentCountArgs>(
      args?: Subset<T, assignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assignmentGroupByArgs['orderBy'] }
        : { orderBy?: assignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assignment model
   */
  readonly fields: assignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assignment model
   */ 
  interface assignmentFieldRefs {
    readonly id: FieldRef<"assignment", 'BigInt'>
    readonly user_id: FieldRef<"assignment", 'String'>
    readonly address: FieldRef<"assignment", 'String'>
    readonly token_id: FieldRef<"assignment", 'String'>
    readonly created_at: FieldRef<"assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * assignment findUnique
   */
  export type assignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment findUniqueOrThrow
   */
  export type assignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment findFirst
   */
  export type assignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * assignment findFirstOrThrow
   */
  export type assignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * assignment findMany
   */
  export type assignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assignments.
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * assignment create
   */
  export type assignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * The data needed to create a assignment.
     */
    data?: XOR<assignmentCreateInput, assignmentUncheckedCreateInput>
  }

  /**
   * assignment createMany
   */
  export type assignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assignments.
     */
    data: assignmentCreateManyInput | assignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assignment createManyAndReturn
   */
  export type assignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many assignments.
     */
    data: assignmentCreateManyInput | assignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assignment update
   */
  export type assignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * The data needed to update a assignment.
     */
    data: XOR<assignmentUpdateInput, assignmentUncheckedUpdateInput>
    /**
     * Choose, which assignment to update.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment updateMany
   */
  export type assignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentUpdateManyMutationInput, assignmentUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentWhereInput
  }

  /**
   * assignment upsert
   */
  export type assignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * The filter to search for the assignment to update in case it exists.
     */
    where: assignmentWhereUniqueInput
    /**
     * In case the assignment found by the `where` argument doesn't exist, create a new assignment with this data.
     */
    create: XOR<assignmentCreateInput, assignmentUncheckedCreateInput>
    /**
     * In case the assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assignmentUpdateInput, assignmentUncheckedUpdateInput>
  }

  /**
   * assignment delete
   */
  export type assignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Filter which assignment to delete.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment deleteMany
   */
  export type assignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignments to delete
     */
    where?: assignmentWhereInput
  }

  /**
   * assignment without action
   */
  export type assignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
  }


  /**
   * Model collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionAvgAggregateOutputType = {
    batch_max_tokens: number | null
    editions: number | null
    price: number | null
  }

  export type CollectionSumAggregateOutputType = {
    batch_max_tokens: number | null
    editions: number | null
    price: number | null
  }

  export type CollectionMinAggregateOutputType = {
    id: string | null
    archived: boolean | null
    batch_max_tokens: number | null
    batch_mint_enabled: boolean | null
    blockchain: string | null
    cover_image_url: string | null
    description: string | null
    editions: number | null
    encryption_enabled: boolean | null
    is_current: boolean | null
    price: number | null
    project_id: string | null
    publish_date: Date | null
    status: string | null
    title: string | null
    updated_at: Date | null
    created_at: Date | null
    is_custodial: boolean | null
    custodied_for: string | null
    miniapp_cover_image: string | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: string | null
    archived: boolean | null
    batch_max_tokens: number | null
    batch_mint_enabled: boolean | null
    blockchain: string | null
    cover_image_url: string | null
    description: string | null
    editions: number | null
    encryption_enabled: boolean | null
    is_current: boolean | null
    price: number | null
    project_id: string | null
    publish_date: Date | null
    status: string | null
    title: string | null
    updated_at: Date | null
    created_at: Date | null
    is_custodial: boolean | null
    custodied_for: string | null
    miniapp_cover_image: string | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    archived: number
    batch_max_tokens: number
    batch_mint_enabled: number
    blockchain: number
    cover_image_url: number
    data: number
    description: number
    editions: number
    encryption_enabled: number
    images: number
    is_current: number
    price: number
    project_id: number
    publish_date: number
    status: number
    title: number
    updated_at: number
    created_at: number
    is_custodial: number
    custodied_for: number
    miniapp_cover_image: number
    _all: number
  }


  export type CollectionAvgAggregateInputType = {
    batch_max_tokens?: true
    editions?: true
    price?: true
  }

  export type CollectionSumAggregateInputType = {
    batch_max_tokens?: true
    editions?: true
    price?: true
  }

  export type CollectionMinAggregateInputType = {
    id?: true
    archived?: true
    batch_max_tokens?: true
    batch_mint_enabled?: true
    blockchain?: true
    cover_image_url?: true
    description?: true
    editions?: true
    encryption_enabled?: true
    is_current?: true
    price?: true
    project_id?: true
    publish_date?: true
    status?: true
    title?: true
    updated_at?: true
    created_at?: true
    is_custodial?: true
    custodied_for?: true
    miniapp_cover_image?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    archived?: true
    batch_max_tokens?: true
    batch_mint_enabled?: true
    blockchain?: true
    cover_image_url?: true
    description?: true
    editions?: true
    encryption_enabled?: true
    is_current?: true
    price?: true
    project_id?: true
    publish_date?: true
    status?: true
    title?: true
    updated_at?: true
    created_at?: true
    is_custodial?: true
    custodied_for?: true
    miniapp_cover_image?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    archived?: true
    batch_max_tokens?: true
    batch_mint_enabled?: true
    blockchain?: true
    cover_image_url?: true
    data?: true
    description?: true
    editions?: true
    encryption_enabled?: true
    images?: true
    is_current?: true
    price?: true
    project_id?: true
    publish_date?: true
    status?: true
    title?: true
    updated_at?: true
    created_at?: true
    is_custodial?: true
    custodied_for?: true
    miniapp_cover_image?: true
    _all?: true
  }

  export type CollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection to aggregate.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionOrderByWithRelationInput | collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type collectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectionWhereInput
    orderBy?: collectionOrderByWithAggregationInput | collectionOrderByWithAggregationInput[]
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum
    having?: collectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _avg?: CollectionAvgAggregateInputType
    _sum?: CollectionSumAggregateInputType
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }

  export type CollectionGroupByOutputType = {
    id: string
    archived: boolean
    batch_max_tokens: number | null
    batch_mint_enabled: boolean
    blockchain: string | null
    cover_image_url: string | null
    data: JsonValue | null
    description: string | null
    editions: number | null
    encryption_enabled: boolean | null
    images: JsonValue | null
    is_current: boolean
    price: number | null
    project_id: string
    publish_date: Date | null
    status: string
    title: string | null
    updated_at: Date
    created_at: Date
    is_custodial: boolean
    custodied_for: string | null
    miniapp_cover_image: string | null
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends collectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type collectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    archived?: boolean
    batch_max_tokens?: boolean
    batch_mint_enabled?: boolean
    blockchain?: boolean
    cover_image_url?: boolean
    data?: boolean
    description?: boolean
    editions?: boolean
    encryption_enabled?: boolean
    images?: boolean
    is_current?: boolean
    price?: boolean
    project_id?: boolean
    publish_date?: boolean
    status?: boolean
    title?: boolean
    updated_at?: boolean
    created_at?: boolean
    is_custodial?: boolean
    custodied_for?: boolean
    miniapp_cover_image?: boolean
    social_link?: boolean | collection$social_linkArgs<ExtArgs>
    project?: boolean | projectDefaultArgs<ExtArgs>
    collection_history?: boolean | collection$collection_historyArgs<ExtArgs>
    collection_preview?: boolean | collection$collection_previewArgs<ExtArgs>
    source_remix?: boolean | collection$source_remixArgs<ExtArgs>
    target_remix?: boolean | collection$target_remixArgs<ExtArgs>
    collection_sales_receivers?: boolean | collection$collection_sales_receiversArgs<ExtArgs>
    collection_sample_images?: boolean | collection$collection_sample_imagesArgs<ExtArgs>
    collection_node?: boolean | collection$collection_nodeArgs<ExtArgs>
    miniapp_collection_config?: boolean | collection$miniapp_collection_configArgs<ExtArgs>
    miniapp_generation?: boolean | collection$miniapp_generationArgs<ExtArgs>
    miniapp_payment?: boolean | collection$miniapp_paymentArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type collectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    archived?: boolean
    batch_max_tokens?: boolean
    batch_mint_enabled?: boolean
    blockchain?: boolean
    cover_image_url?: boolean
    data?: boolean
    description?: boolean
    editions?: boolean
    encryption_enabled?: boolean
    images?: boolean
    is_current?: boolean
    price?: boolean
    project_id?: boolean
    publish_date?: boolean
    status?: boolean
    title?: boolean
    updated_at?: boolean
    created_at?: boolean
    is_custodial?: boolean
    custodied_for?: boolean
    miniapp_cover_image?: boolean
    social_link?: boolean | collection$social_linkArgs<ExtArgs>
    project?: boolean | projectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type collectionSelectScalar = {
    id?: boolean
    archived?: boolean
    batch_max_tokens?: boolean
    batch_mint_enabled?: boolean
    blockchain?: boolean
    cover_image_url?: boolean
    data?: boolean
    description?: boolean
    editions?: boolean
    encryption_enabled?: boolean
    images?: boolean
    is_current?: boolean
    price?: boolean
    project_id?: boolean
    publish_date?: boolean
    status?: boolean
    title?: boolean
    updated_at?: boolean
    created_at?: boolean
    is_custodial?: boolean
    custodied_for?: boolean
    miniapp_cover_image?: boolean
  }

  export type collectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social_link?: boolean | collection$social_linkArgs<ExtArgs>
    project?: boolean | projectDefaultArgs<ExtArgs>
    collection_history?: boolean | collection$collection_historyArgs<ExtArgs>
    collection_preview?: boolean | collection$collection_previewArgs<ExtArgs>
    source_remix?: boolean | collection$source_remixArgs<ExtArgs>
    target_remix?: boolean | collection$target_remixArgs<ExtArgs>
    collection_sales_receivers?: boolean | collection$collection_sales_receiversArgs<ExtArgs>
    collection_sample_images?: boolean | collection$collection_sample_imagesArgs<ExtArgs>
    collection_node?: boolean | collection$collection_nodeArgs<ExtArgs>
    miniapp_collection_config?: boolean | collection$miniapp_collection_configArgs<ExtArgs>
    miniapp_generation?: boolean | collection$miniapp_generationArgs<ExtArgs>
    miniapp_payment?: boolean | collection$miniapp_paymentArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type collectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social_link?: boolean | collection$social_linkArgs<ExtArgs>
    project?: boolean | projectDefaultArgs<ExtArgs>
  }

  export type $collectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection"
    objects: {
      social_link: Prisma.$social_linkPayload<ExtArgs> | null
      project: Prisma.$projectPayload<ExtArgs>
      collection_history: Prisma.$collection_historyPayload<ExtArgs>[]
      collection_preview: Prisma.$collection_previewPayload<ExtArgs> | null
      source_remix: Prisma.$collection_remixPayload<ExtArgs>[]
      target_remix: Prisma.$collection_remixPayload<ExtArgs>[]
      collection_sales_receivers: Prisma.$collection_sales_receiversPayload<ExtArgs>[]
      collection_sample_images: Prisma.$collection_sample_imagesPayload<ExtArgs>[]
      collection_node: Prisma.$componentPayload<ExtArgs>[]
      miniapp_collection_config: Prisma.$miniapp_collection_configPayload<ExtArgs> | null
      miniapp_generation: Prisma.$miniapp_generationPayload<ExtArgs>[]
      miniapp_payment: Prisma.$miniapp_paymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      archived: boolean
      batch_max_tokens: number | null
      batch_mint_enabled: boolean
      blockchain: string | null
      cover_image_url: string | null
      data: Prisma.JsonValue | null
      description: string | null
      editions: number | null
      encryption_enabled: boolean | null
      images: Prisma.JsonValue | null
      is_current: boolean
      price: number | null
      project_id: string
      publish_date: Date | null
      status: string
      title: string | null
      updated_at: Date
      created_at: Date
      is_custodial: boolean
      custodied_for: string | null
      miniapp_cover_image: string | null
    }, ExtArgs["result"]["collection"]>
    composites: {}
  }

  type collectionGetPayload<S extends boolean | null | undefined | collectionDefaultArgs> = $Result.GetResult<Prisma.$collectionPayload, S>

  type collectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface collectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection'], meta: { name: 'collection' } }
    /**
     * Find zero or one Collection that matches the filter.
     * @param {collectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collectionFindUniqueArgs>(args: SelectSubset<T, collectionFindUniqueArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collectionFindUniqueOrThrowArgs>(args: SelectSubset<T, collectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collectionFindFirstArgs>(args?: SelectSubset<T, collectionFindFirstArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collectionFindFirstOrThrowArgs>(args?: SelectSubset<T, collectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collectionFindManyArgs>(args?: SelectSubset<T, collectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection.
     * @param {collectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
     */
    create<T extends collectionCreateArgs>(args: SelectSubset<T, collectionCreateArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collections.
     * @param {collectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collectionCreateManyArgs>(args?: SelectSubset<T, collectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {collectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collectionCreateManyAndReturnArgs>(args?: SelectSubset<T, collectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection.
     * @param {collectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
     */
    delete<T extends collectionDeleteArgs>(args: SelectSubset<T, collectionDeleteArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection.
     * @param {collectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collectionUpdateArgs>(args: SelectSubset<T, collectionUpdateArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collections.
     * @param {collectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collectionDeleteManyArgs>(args?: SelectSubset<T, collectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collectionUpdateManyArgs>(args: SelectSubset<T, collectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection.
     * @param {collectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends collectionUpsertArgs>(args: SelectSubset<T, collectionUpsertArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends collectionCountArgs>(
      args?: Subset<T, collectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collectionGroupByArgs['orderBy'] }
        : { orderBy?: collectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection model
   */
  readonly fields: collectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    social_link<T extends collection$social_linkArgs<ExtArgs> = {}>(args?: Subset<T, collection$social_linkArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends projectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projectDefaultArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    collection_history<T extends collection$collection_historyArgs<ExtArgs> = {}>(args?: Subset<T, collection$collection_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "findMany"> | Null>
    collection_preview<T extends collection$collection_previewArgs<ExtArgs> = {}>(args?: Subset<T, collection$collection_previewArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    source_remix<T extends collection$source_remixArgs<ExtArgs> = {}>(args?: Subset<T, collection$source_remixArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findMany"> | Null>
    target_remix<T extends collection$target_remixArgs<ExtArgs> = {}>(args?: Subset<T, collection$target_remixArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findMany"> | Null>
    collection_sales_receivers<T extends collection$collection_sales_receiversArgs<ExtArgs> = {}>(args?: Subset<T, collection$collection_sales_receiversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "findMany"> | Null>
    collection_sample_images<T extends collection$collection_sample_imagesArgs<ExtArgs> = {}>(args?: Subset<T, collection$collection_sample_imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "findMany"> | Null>
    collection_node<T extends collection$collection_nodeArgs<ExtArgs> = {}>(args?: Subset<T, collection$collection_nodeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findMany"> | Null>
    miniapp_collection_config<T extends collection$miniapp_collection_configArgs<ExtArgs> = {}>(args?: Subset<T, collection$miniapp_collection_configArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    miniapp_generation<T extends collection$miniapp_generationArgs<ExtArgs> = {}>(args?: Subset<T, collection$miniapp_generationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findMany"> | Null>
    miniapp_payment<T extends collection$miniapp_paymentArgs<ExtArgs> = {}>(args?: Subset<T, collection$miniapp_paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection model
   */ 
  interface collectionFieldRefs {
    readonly id: FieldRef<"collection", 'String'>
    readonly archived: FieldRef<"collection", 'Boolean'>
    readonly batch_max_tokens: FieldRef<"collection", 'Int'>
    readonly batch_mint_enabled: FieldRef<"collection", 'Boolean'>
    readonly blockchain: FieldRef<"collection", 'String'>
    readonly cover_image_url: FieldRef<"collection", 'String'>
    readonly data: FieldRef<"collection", 'Json'>
    readonly description: FieldRef<"collection", 'String'>
    readonly editions: FieldRef<"collection", 'Int'>
    readonly encryption_enabled: FieldRef<"collection", 'Boolean'>
    readonly images: FieldRef<"collection", 'Json'>
    readonly is_current: FieldRef<"collection", 'Boolean'>
    readonly price: FieldRef<"collection", 'Float'>
    readonly project_id: FieldRef<"collection", 'String'>
    readonly publish_date: FieldRef<"collection", 'DateTime'>
    readonly status: FieldRef<"collection", 'String'>
    readonly title: FieldRef<"collection", 'String'>
    readonly updated_at: FieldRef<"collection", 'DateTime'>
    readonly created_at: FieldRef<"collection", 'DateTime'>
    readonly is_custodial: FieldRef<"collection", 'Boolean'>
    readonly custodied_for: FieldRef<"collection", 'String'>
    readonly miniapp_cover_image: FieldRef<"collection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collection findUnique
   */
  export type collectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * Filter, which collection to fetch.
     */
    where: collectionWhereUniqueInput
  }

  /**
   * collection findUniqueOrThrow
   */
  export type collectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * Filter, which collection to fetch.
     */
    where: collectionWhereUniqueInput
  }

  /**
   * collection findFirst
   */
  export type collectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * Filter, which collection to fetch.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionOrderByWithRelationInput | collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections.
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * collection findFirstOrThrow
   */
  export type collectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * Filter, which collection to fetch.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionOrderByWithRelationInput | collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections.
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * collection findMany
   */
  export type collectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * Filter, which collections to fetch.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: collectionOrderByWithRelationInput | collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collections.
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * collection create
   */
  export type collectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * The data needed to create a collection.
     */
    data: XOR<collectionCreateInput, collectionUncheckedCreateInput>
  }

  /**
   * collection createMany
   */
  export type collectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collections.
     */
    data: collectionCreateManyInput | collectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection createManyAndReturn
   */
  export type collectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collections.
     */
    data: collectionCreateManyInput | collectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection update
   */
  export type collectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * The data needed to update a collection.
     */
    data: XOR<collectionUpdateInput, collectionUncheckedUpdateInput>
    /**
     * Choose, which collection to update.
     */
    where: collectionWhereUniqueInput
  }

  /**
   * collection updateMany
   */
  export type collectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collections.
     */
    data: XOR<collectionUpdateManyMutationInput, collectionUncheckedUpdateManyInput>
    /**
     * Filter which collections to update
     */
    where?: collectionWhereInput
  }

  /**
   * collection upsert
   */
  export type collectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * The filter to search for the collection to update in case it exists.
     */
    where: collectionWhereUniqueInput
    /**
     * In case the collection found by the `where` argument doesn't exist, create a new collection with this data.
     */
    create: XOR<collectionCreateInput, collectionUncheckedCreateInput>
    /**
     * In case the collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collectionUpdateInput, collectionUncheckedUpdateInput>
  }

  /**
   * collection delete
   */
  export type collectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    /**
     * Filter which collection to delete.
     */
    where: collectionWhereUniqueInput
  }

  /**
   * collection deleteMany
   */
  export type collectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collections to delete
     */
    where?: collectionWhereInput
  }

  /**
   * collection.social_link
   */
  export type collection$social_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    where?: social_linkWhereInput
  }

  /**
   * collection.collection_history
   */
  export type collection$collection_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    where?: collection_historyWhereInput
    orderBy?: collection_historyOrderByWithRelationInput | collection_historyOrderByWithRelationInput[]
    cursor?: collection_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_historyScalarFieldEnum | Collection_historyScalarFieldEnum[]
  }

  /**
   * collection.collection_preview
   */
  export type collection$collection_previewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    where?: collection_previewWhereInput
  }

  /**
   * collection.source_remix
   */
  export type collection$source_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    where?: collection_remixWhereInput
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    cursor?: collection_remixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_remixScalarFieldEnum | Collection_remixScalarFieldEnum[]
  }

  /**
   * collection.target_remix
   */
  export type collection$target_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    where?: collection_remixWhereInput
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    cursor?: collection_remixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_remixScalarFieldEnum | Collection_remixScalarFieldEnum[]
  }

  /**
   * collection.collection_sales_receivers
   */
  export type collection$collection_sales_receiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    where?: collection_sales_receiversWhereInput
    orderBy?: collection_sales_receiversOrderByWithRelationInput | collection_sales_receiversOrderByWithRelationInput[]
    cursor?: collection_sales_receiversWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_sales_receiversScalarFieldEnum | Collection_sales_receiversScalarFieldEnum[]
  }

  /**
   * collection.collection_sample_images
   */
  export type collection$collection_sample_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    where?: collection_sample_imagesWhereInput
    orderBy?: collection_sample_imagesOrderByWithRelationInput | collection_sample_imagesOrderByWithRelationInput[]
    cursor?: collection_sample_imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_sample_imagesScalarFieldEnum | Collection_sample_imagesScalarFieldEnum[]
  }

  /**
   * collection.collection_node
   */
  export type collection$collection_nodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    where?: componentWhereInput
    orderBy?: componentOrderByWithRelationInput | componentOrderByWithRelationInput[]
    cursor?: componentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * collection.miniapp_collection_config
   */
  export type collection$miniapp_collection_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    where?: miniapp_collection_configWhereInput
  }

  /**
   * collection.miniapp_generation
   */
  export type collection$miniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    where?: miniapp_generationWhereInput
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    cursor?: miniapp_generationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Miniapp_generationScalarFieldEnum | Miniapp_generationScalarFieldEnum[]
  }

  /**
   * collection.miniapp_payment
   */
  export type collection$miniapp_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    where?: miniapp_paymentWhereInput
    orderBy?: miniapp_paymentOrderByWithRelationInput | miniapp_paymentOrderByWithRelationInput[]
    cursor?: miniapp_paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Miniapp_paymentScalarFieldEnum | Miniapp_paymentScalarFieldEnum[]
  }

  /**
   * collection without action
   */
  export type collectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
  }


  /**
   * Model collection_remix
   */

  export type AggregateCollection_remix = {
    _count: Collection_remixCountAggregateOutputType | null
    _avg: Collection_remixAvgAggregateOutputType | null
    _sum: Collection_remixSumAggregateOutputType | null
    _min: Collection_remixMinAggregateOutputType | null
    _max: Collection_remixMaxAggregateOutputType | null
  }

  export type Collection_remixAvgAggregateOutputType = {
    id: number | null
    collection_preview_version_id: number | null
  }

  export type Collection_remixSumAggregateOutputType = {
    id: bigint | null
    collection_preview_version_id: bigint | null
  }

  export type Collection_remixMinAggregateOutputType = {
    id: bigint | null
    source_collection_id: string | null
    target_collection_id: string | null
    created_at: Date | null
    collection_preview_version_id: bigint | null
  }

  export type Collection_remixMaxAggregateOutputType = {
    id: bigint | null
    source_collection_id: string | null
    target_collection_id: string | null
    created_at: Date | null
    collection_preview_version_id: bigint | null
  }

  export type Collection_remixCountAggregateOutputType = {
    id: number
    source_collection_id: number
    target_collection_id: number
    created_at: number
    collection_preview_version_id: number
    _all: number
  }


  export type Collection_remixAvgAggregateInputType = {
    id?: true
    collection_preview_version_id?: true
  }

  export type Collection_remixSumAggregateInputType = {
    id?: true
    collection_preview_version_id?: true
  }

  export type Collection_remixMinAggregateInputType = {
    id?: true
    source_collection_id?: true
    target_collection_id?: true
    created_at?: true
    collection_preview_version_id?: true
  }

  export type Collection_remixMaxAggregateInputType = {
    id?: true
    source_collection_id?: true
    target_collection_id?: true
    created_at?: true
    collection_preview_version_id?: true
  }

  export type Collection_remixCountAggregateInputType = {
    id?: true
    source_collection_id?: true
    target_collection_id?: true
    created_at?: true
    collection_preview_version_id?: true
    _all?: true
  }

  export type Collection_remixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_remix to aggregate.
     */
    where?: collection_remixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_remixes to fetch.
     */
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_remixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_remixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_remixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_remixes
    **/
    _count?: true | Collection_remixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_remixAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_remixSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_remixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_remixMaxAggregateInputType
  }

  export type GetCollection_remixAggregateType<T extends Collection_remixAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_remix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_remix[P]>
      : GetScalarType<T[P], AggregateCollection_remix[P]>
  }




  export type collection_remixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_remixWhereInput
    orderBy?: collection_remixOrderByWithAggregationInput | collection_remixOrderByWithAggregationInput[]
    by: Collection_remixScalarFieldEnum[] | Collection_remixScalarFieldEnum
    having?: collection_remixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_remixCountAggregateInputType | true
    _avg?: Collection_remixAvgAggregateInputType
    _sum?: Collection_remixSumAggregateInputType
    _min?: Collection_remixMinAggregateInputType
    _max?: Collection_remixMaxAggregateInputType
  }

  export type Collection_remixGroupByOutputType = {
    id: bigint
    source_collection_id: string
    target_collection_id: string
    created_at: Date | null
    collection_preview_version_id: bigint | null
    _count: Collection_remixCountAggregateOutputType | null
    _avg: Collection_remixAvgAggregateOutputType | null
    _sum: Collection_remixSumAggregateOutputType | null
    _min: Collection_remixMinAggregateOutputType | null
    _max: Collection_remixMaxAggregateOutputType | null
  }

  type GetCollection_remixGroupByPayload<T extends collection_remixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_remixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_remixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_remixGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_remixGroupByOutputType[P]>
        }
      >
    >


  export type collection_remixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source_collection_id?: boolean
    target_collection_id?: boolean
    created_at?: boolean
    collection_preview_version_id?: boolean
    collection_preview_version?: boolean | collection_remix$collection_preview_versionArgs<ExtArgs>
    source_collection?: boolean | collectionDefaultArgs<ExtArgs>
    target_collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_remix"]>

  export type collection_remixSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source_collection_id?: boolean
    target_collection_id?: boolean
    created_at?: boolean
    collection_preview_version_id?: boolean
    collection_preview_version?: boolean | collection_remix$collection_preview_versionArgs<ExtArgs>
    source_collection?: boolean | collectionDefaultArgs<ExtArgs>
    target_collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_remix"]>

  export type collection_remixSelectScalar = {
    id?: boolean
    source_collection_id?: boolean
    target_collection_id?: boolean
    created_at?: boolean
    collection_preview_version_id?: boolean
  }

  export type collection_remixInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_preview_version?: boolean | collection_remix$collection_preview_versionArgs<ExtArgs>
    source_collection?: boolean | collectionDefaultArgs<ExtArgs>
    target_collection?: boolean | collectionDefaultArgs<ExtArgs>
  }
  export type collection_remixIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_preview_version?: boolean | collection_remix$collection_preview_versionArgs<ExtArgs>
    source_collection?: boolean | collectionDefaultArgs<ExtArgs>
    target_collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $collection_remixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_remix"
    objects: {
      collection_preview_version: Prisma.$collection_preview_versionPayload<ExtArgs> | null
      source_collection: Prisma.$collectionPayload<ExtArgs>
      target_collection: Prisma.$collectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      source_collection_id: string
      target_collection_id: string
      created_at: Date | null
      collection_preview_version_id: bigint | null
    }, ExtArgs["result"]["collection_remix"]>
    composites: {}
  }

  type collection_remixGetPayload<S extends boolean | null | undefined | collection_remixDefaultArgs> = $Result.GetResult<Prisma.$collection_remixPayload, S>

  type collection_remixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_remixFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_remixCountAggregateInputType | true
    }

  export interface collection_remixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_remix'], meta: { name: 'collection_remix' } }
    /**
     * Find zero or one Collection_remix that matches the filter.
     * @param {collection_remixFindUniqueArgs} args - Arguments to find a Collection_remix
     * @example
     * // Get one Collection_remix
     * const collection_remix = await prisma.collection_remix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_remixFindUniqueArgs>(args: SelectSubset<T, collection_remixFindUniqueArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_remix that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_remixFindUniqueOrThrowArgs} args - Arguments to find a Collection_remix
     * @example
     * // Get one Collection_remix
     * const collection_remix = await prisma.collection_remix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_remixFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_remixFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_remix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_remixFindFirstArgs} args - Arguments to find a Collection_remix
     * @example
     * // Get one Collection_remix
     * const collection_remix = await prisma.collection_remix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_remixFindFirstArgs>(args?: SelectSubset<T, collection_remixFindFirstArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_remix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_remixFindFirstOrThrowArgs} args - Arguments to find a Collection_remix
     * @example
     * // Get one Collection_remix
     * const collection_remix = await prisma.collection_remix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_remixFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_remixFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_remixes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_remixFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_remixes
     * const collection_remixes = await prisma.collection_remix.findMany()
     * 
     * // Get first 10 Collection_remixes
     * const collection_remixes = await prisma.collection_remix.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_remixWithIdOnly = await prisma.collection_remix.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_remixFindManyArgs>(args?: SelectSubset<T, collection_remixFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_remix.
     * @param {collection_remixCreateArgs} args - Arguments to create a Collection_remix.
     * @example
     * // Create one Collection_remix
     * const Collection_remix = await prisma.collection_remix.create({
     *   data: {
     *     // ... data to create a Collection_remix
     *   }
     * })
     * 
     */
    create<T extends collection_remixCreateArgs>(args: SelectSubset<T, collection_remixCreateArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_remixes.
     * @param {collection_remixCreateManyArgs} args - Arguments to create many Collection_remixes.
     * @example
     * // Create many Collection_remixes
     * const collection_remix = await prisma.collection_remix.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_remixCreateManyArgs>(args?: SelectSubset<T, collection_remixCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_remixes and returns the data saved in the database.
     * @param {collection_remixCreateManyAndReturnArgs} args - Arguments to create many Collection_remixes.
     * @example
     * // Create many Collection_remixes
     * const collection_remix = await prisma.collection_remix.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_remixes and only return the `id`
     * const collection_remixWithIdOnly = await prisma.collection_remix.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_remixCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_remixCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_remix.
     * @param {collection_remixDeleteArgs} args - Arguments to delete one Collection_remix.
     * @example
     * // Delete one Collection_remix
     * const Collection_remix = await prisma.collection_remix.delete({
     *   where: {
     *     // ... filter to delete one Collection_remix
     *   }
     * })
     * 
     */
    delete<T extends collection_remixDeleteArgs>(args: SelectSubset<T, collection_remixDeleteArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_remix.
     * @param {collection_remixUpdateArgs} args - Arguments to update one Collection_remix.
     * @example
     * // Update one Collection_remix
     * const collection_remix = await prisma.collection_remix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_remixUpdateArgs>(args: SelectSubset<T, collection_remixUpdateArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_remixes.
     * @param {collection_remixDeleteManyArgs} args - Arguments to filter Collection_remixes to delete.
     * @example
     * // Delete a few Collection_remixes
     * const { count } = await prisma.collection_remix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_remixDeleteManyArgs>(args?: SelectSubset<T, collection_remixDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_remixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_remixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_remixes
     * const collection_remix = await prisma.collection_remix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_remixUpdateManyArgs>(args: SelectSubset<T, collection_remixUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_remix.
     * @param {collection_remixUpsertArgs} args - Arguments to update or create a Collection_remix.
     * @example
     * // Update or create a Collection_remix
     * const collection_remix = await prisma.collection_remix.upsert({
     *   create: {
     *     // ... data to create a Collection_remix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_remix we want to update
     *   }
     * })
     */
    upsert<T extends collection_remixUpsertArgs>(args: SelectSubset<T, collection_remixUpsertArgs<ExtArgs>>): Prisma__collection_remixClient<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_remixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_remixCountArgs} args - Arguments to filter Collection_remixes to count.
     * @example
     * // Count the number of Collection_remixes
     * const count = await prisma.collection_remix.count({
     *   where: {
     *     // ... the filter for the Collection_remixes we want to count
     *   }
     * })
    **/
    count<T extends collection_remixCountArgs>(
      args?: Subset<T, collection_remixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_remixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_remix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_remixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_remixAggregateArgs>(args: Subset<T, Collection_remixAggregateArgs>): Prisma.PrismaPromise<GetCollection_remixAggregateType<T>>

    /**
     * Group by Collection_remix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_remixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_remixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_remixGroupByArgs['orderBy'] }
        : { orderBy?: collection_remixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_remixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_remixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_remix model
   */
  readonly fields: collection_remixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_remix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_remixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_preview_version<T extends collection_remix$collection_preview_versionArgs<ExtArgs> = {}>(args?: Subset<T, collection_remix$collection_preview_versionArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    source_collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    target_collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_remix model
   */ 
  interface collection_remixFieldRefs {
    readonly id: FieldRef<"collection_remix", 'BigInt'>
    readonly source_collection_id: FieldRef<"collection_remix", 'String'>
    readonly target_collection_id: FieldRef<"collection_remix", 'String'>
    readonly created_at: FieldRef<"collection_remix", 'DateTime'>
    readonly collection_preview_version_id: FieldRef<"collection_remix", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * collection_remix findUnique
   */
  export type collection_remixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * Filter, which collection_remix to fetch.
     */
    where: collection_remixWhereUniqueInput
  }

  /**
   * collection_remix findUniqueOrThrow
   */
  export type collection_remixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * Filter, which collection_remix to fetch.
     */
    where: collection_remixWhereUniqueInput
  }

  /**
   * collection_remix findFirst
   */
  export type collection_remixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * Filter, which collection_remix to fetch.
     */
    where?: collection_remixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_remixes to fetch.
     */
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_remixes.
     */
    cursor?: collection_remixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_remixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_remixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_remixes.
     */
    distinct?: Collection_remixScalarFieldEnum | Collection_remixScalarFieldEnum[]
  }

  /**
   * collection_remix findFirstOrThrow
   */
  export type collection_remixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * Filter, which collection_remix to fetch.
     */
    where?: collection_remixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_remixes to fetch.
     */
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_remixes.
     */
    cursor?: collection_remixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_remixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_remixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_remixes.
     */
    distinct?: Collection_remixScalarFieldEnum | Collection_remixScalarFieldEnum[]
  }

  /**
   * collection_remix findMany
   */
  export type collection_remixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * Filter, which collection_remixes to fetch.
     */
    where?: collection_remixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_remixes to fetch.
     */
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_remixes.
     */
    cursor?: collection_remixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_remixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_remixes.
     */
    skip?: number
    distinct?: Collection_remixScalarFieldEnum | Collection_remixScalarFieldEnum[]
  }

  /**
   * collection_remix create
   */
  export type collection_remixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_remix.
     */
    data: XOR<collection_remixCreateInput, collection_remixUncheckedCreateInput>
  }

  /**
   * collection_remix createMany
   */
  export type collection_remixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_remixes.
     */
    data: collection_remixCreateManyInput | collection_remixCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_remix createManyAndReturn
   */
  export type collection_remixCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_remixes.
     */
    data: collection_remixCreateManyInput | collection_remixCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_remix update
   */
  export type collection_remixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_remix.
     */
    data: XOR<collection_remixUpdateInput, collection_remixUncheckedUpdateInput>
    /**
     * Choose, which collection_remix to update.
     */
    where: collection_remixWhereUniqueInput
  }

  /**
   * collection_remix updateMany
   */
  export type collection_remixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_remixes.
     */
    data: XOR<collection_remixUpdateManyMutationInput, collection_remixUncheckedUpdateManyInput>
    /**
     * Filter which collection_remixes to update
     */
    where?: collection_remixWhereInput
  }

  /**
   * collection_remix upsert
   */
  export type collection_remixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_remix to update in case it exists.
     */
    where: collection_remixWhereUniqueInput
    /**
     * In case the collection_remix found by the `where` argument doesn't exist, create a new collection_remix with this data.
     */
    create: XOR<collection_remixCreateInput, collection_remixUncheckedCreateInput>
    /**
     * In case the collection_remix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_remixUpdateInput, collection_remixUncheckedUpdateInput>
  }

  /**
   * collection_remix delete
   */
  export type collection_remixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    /**
     * Filter which collection_remix to delete.
     */
    where: collection_remixWhereUniqueInput
  }

  /**
   * collection_remix deleteMany
   */
  export type collection_remixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_remixes to delete
     */
    where?: collection_remixWhereInput
  }

  /**
   * collection_remix.collection_preview_version
   */
  export type collection_remix$collection_preview_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    where?: collection_preview_versionWhereInput
  }

  /**
   * collection_remix without action
   */
  export type collection_remixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
  }


  /**
   * Model event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    event_name: string | null
    property_name: string | null
    property_value: string | null
    created_at: Date | null
    user_id: string | null
    event_id: string | null
    event_type: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    event_name: string | null
    property_name: string | null
    property_value: string | null
    created_at: Date | null
    user_id: string | null
    event_id: string | null
    event_type: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    event_name: number
    property_name: number
    property_value: number
    created_at: number
    user_id: number
    event_id: number
    event_type: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    event_name?: true
    property_name?: true
    property_value?: true
    created_at?: true
    user_id?: true
    event_id?: true
    event_type?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    event_name?: true
    property_name?: true
    property_value?: true
    created_at?: true
    user_id?: true
    event_id?: true
    event_type?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    event_name?: true
    property_name?: true
    property_value?: true
    created_at?: true
    user_id?: true
    event_id?: true
    event_type?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event to aggregate.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
    orderBy?: eventOrderByWithAggregationInput | eventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    event_name: string
    property_name: string
    property_value: string | null
    created_at: Date
    user_id: string
    event_id: string
    event_type: string
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_name?: boolean
    property_name?: boolean
    property_value?: boolean
    created_at?: boolean
    user_id?: boolean
    event_id?: boolean
    event_type?: boolean
  }, ExtArgs["result"]["event"]>

  export type eventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_name?: boolean
    property_name?: boolean
    property_value?: boolean
    created_at?: boolean
    user_id?: boolean
    event_id?: boolean
    event_type?: boolean
  }, ExtArgs["result"]["event"]>

  export type eventSelectScalar = {
    id?: boolean
    event_name?: boolean
    property_name?: boolean
    property_value?: boolean
    created_at?: boolean
    user_id?: boolean
    event_id?: boolean
    event_type?: boolean
  }


  export type $eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      event_name: string
      property_name: string
      property_value: string | null
      created_at: Date
      user_id: string
      event_id: string
      event_type: string
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type eventGetPayload<S extends boolean | null | undefined | eventDefaultArgs> = $Result.GetResult<Prisma.$eventPayload, S>

  type eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event'], meta: { name: 'event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {eventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventFindUniqueArgs>(args: SelectSubset<T, eventFindUniqueArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventFindUniqueOrThrowArgs>(args: SelectSubset<T, eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventFindFirstArgs>(args?: SelectSubset<T, eventFindFirstArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventFindFirstOrThrowArgs>(args?: SelectSubset<T, eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventFindManyArgs>(args?: SelectSubset<T, eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {eventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends eventCreateArgs>(args: SelectSubset<T, eventCreateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {eventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventCreateManyArgs>(args?: SelectSubset<T, eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {eventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends eventCreateManyAndReturnArgs>(args?: SelectSubset<T, eventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {eventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends eventDeleteArgs>(args: SelectSubset<T, eventDeleteArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {eventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventUpdateArgs>(args: SelectSubset<T, eventUpdateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventDeleteManyArgs>(args?: SelectSubset<T, eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventUpdateManyArgs>(args: SelectSubset<T, eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {eventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends eventUpsertArgs>(args: SelectSubset<T, eventUpsertArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventCountArgs>(
      args?: Subset<T, eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventGroupByArgs['orderBy'] }
        : { orderBy?: eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event model
   */
  readonly fields: eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the event model
   */ 
  interface eventFieldRefs {
    readonly id: FieldRef<"event", 'String'>
    readonly event_name: FieldRef<"event", 'String'>
    readonly property_name: FieldRef<"event", 'String'>
    readonly property_value: FieldRef<"event", 'String'>
    readonly created_at: FieldRef<"event", 'DateTime'>
    readonly user_id: FieldRef<"event", 'String'>
    readonly event_id: FieldRef<"event", 'String'>
    readonly event_type: FieldRef<"event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * event findUnique
   */
  export type eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findUniqueOrThrow
   */
  export type eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findFirst
   */
  export type eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findFirstOrThrow
   */
  export type eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findMany
   */
  export type eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event create
   */
  export type eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * The data needed to create a event.
     */
    data: XOR<eventCreateInput, eventUncheckedCreateInput>
  }

  /**
   * event createMany
   */
  export type eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event createManyAndReturn
   */
  export type eventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event update
   */
  export type eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * The data needed to update a event.
     */
    data: XOR<eventUpdateInput, eventUncheckedUpdateInput>
    /**
     * Choose, which event to update.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event updateMany
   */
  export type eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventWhereInput
  }

  /**
   * event upsert
   */
  export type eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * The filter to search for the event to update in case it exists.
     */
    where: eventWhereUniqueInput
    /**
     * In case the event found by the `where` argument doesn't exist, create a new event with this data.
     */
    create: XOR<eventCreateInput, eventUncheckedCreateInput>
    /**
     * In case the event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventUpdateInput, eventUncheckedUpdateInput>
  }

  /**
   * event delete
   */
  export type eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Filter which event to delete.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event deleteMany
   */
  export type eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventWhereInput
  }

  /**
   * event without action
   */
  export type eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
  }


  /**
   * Model flat_file
   */

  export type AggregateFlat_file = {
    _count: Flat_fileCountAggregateOutputType | null
    _avg: Flat_fileAvgAggregateOutputType | null
    _sum: Flat_fileSumAggregateOutputType | null
    _min: Flat_fileMinAggregateOutputType | null
    _max: Flat_fileMaxAggregateOutputType | null
  }

  export type Flat_fileAvgAggregateOutputType = {
    id: number | null
  }

  export type Flat_fileSumAggregateOutputType = {
    id: bigint | null
  }

  export type Flat_fileMinAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    url: string | null
    hidden: boolean | null
    user_id: string | null
    name: string | null
    mime_type: string | null
    rel_id: string | null
    rel_type: string | null
  }

  export type Flat_fileMaxAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    url: string | null
    hidden: boolean | null
    user_id: string | null
    name: string | null
    mime_type: string | null
    rel_id: string | null
    rel_type: string | null
  }

  export type Flat_fileCountAggregateOutputType = {
    id: number
    created_at: number
    url: number
    hidden: number
    user_id: number
    name: number
    gen_in_data: number
    gen_out_data: number
    mime_type: number
    rel_id: number
    rel_type: number
    tags: number
    _all: number
  }


  export type Flat_fileAvgAggregateInputType = {
    id?: true
  }

  export type Flat_fileSumAggregateInputType = {
    id?: true
  }

  export type Flat_fileMinAggregateInputType = {
    id?: true
    created_at?: true
    url?: true
    hidden?: true
    user_id?: true
    name?: true
    mime_type?: true
    rel_id?: true
    rel_type?: true
  }

  export type Flat_fileMaxAggregateInputType = {
    id?: true
    created_at?: true
    url?: true
    hidden?: true
    user_id?: true
    name?: true
    mime_type?: true
    rel_id?: true
    rel_type?: true
  }

  export type Flat_fileCountAggregateInputType = {
    id?: true
    created_at?: true
    url?: true
    hidden?: true
    user_id?: true
    name?: true
    gen_in_data?: true
    gen_out_data?: true
    mime_type?: true
    rel_id?: true
    rel_type?: true
    tags?: true
    _all?: true
  }

  export type Flat_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flat_file to aggregate.
     */
    where?: flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flat_files to fetch.
     */
    orderBy?: flat_fileOrderByWithRelationInput | flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flat_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flat_files
    **/
    _count?: true | Flat_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Flat_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Flat_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Flat_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Flat_fileMaxAggregateInputType
  }

  export type GetFlat_fileAggregateType<T extends Flat_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateFlat_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlat_file[P]>
      : GetScalarType<T[P], AggregateFlat_file[P]>
  }




  export type flat_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flat_fileWhereInput
    orderBy?: flat_fileOrderByWithAggregationInput | flat_fileOrderByWithAggregationInput[]
    by: Flat_fileScalarFieldEnum[] | Flat_fileScalarFieldEnum
    having?: flat_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Flat_fileCountAggregateInputType | true
    _avg?: Flat_fileAvgAggregateInputType
    _sum?: Flat_fileSumAggregateInputType
    _min?: Flat_fileMinAggregateInputType
    _max?: Flat_fileMaxAggregateInputType
  }

  export type Flat_fileGroupByOutputType = {
    id: bigint
    created_at: Date | null
    url: string | null
    hidden: boolean | null
    user_id: string
    name: string
    gen_in_data: JsonValue | null
    gen_out_data: JsonValue | null
    mime_type: string | null
    rel_id: string | null
    rel_type: string | null
    tags: string[]
    _count: Flat_fileCountAggregateOutputType | null
    _avg: Flat_fileAvgAggregateOutputType | null
    _sum: Flat_fileSumAggregateOutputType | null
    _min: Flat_fileMinAggregateOutputType | null
    _max: Flat_fileMaxAggregateOutputType | null
  }

  type GetFlat_fileGroupByPayload<T extends flat_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Flat_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Flat_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Flat_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Flat_fileGroupByOutputType[P]>
        }
      >
    >


  export type flat_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    url?: boolean
    hidden?: boolean
    user_id?: boolean
    name?: boolean
    gen_in_data?: boolean
    gen_out_data?: boolean
    mime_type?: boolean
    rel_id?: boolean
    rel_type?: boolean
    tags?: boolean
    chat_message?: boolean | flat_file$chat_messageArgs<ExtArgs>
    component_flat_files?: boolean | flat_file$component_flat_filesArgs<ExtArgs>
    _count?: boolean | Flat_fileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flat_file"]>

  export type flat_fileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    url?: boolean
    hidden?: boolean
    user_id?: boolean
    name?: boolean
    gen_in_data?: boolean
    gen_out_data?: boolean
    mime_type?: boolean
    rel_id?: boolean
    rel_type?: boolean
    tags?: boolean
  }, ExtArgs["result"]["flat_file"]>

  export type flat_fileSelectScalar = {
    id?: boolean
    created_at?: boolean
    url?: boolean
    hidden?: boolean
    user_id?: boolean
    name?: boolean
    gen_in_data?: boolean
    gen_out_data?: boolean
    mime_type?: boolean
    rel_id?: boolean
    rel_type?: boolean
    tags?: boolean
  }

  export type flat_fileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_message?: boolean | flat_file$chat_messageArgs<ExtArgs>
    component_flat_files?: boolean | flat_file$component_flat_filesArgs<ExtArgs>
    _count?: boolean | Flat_fileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type flat_fileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $flat_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flat_file"
    objects: {
      chat_message: Prisma.$chat_messagePayload<ExtArgs>[]
      component_flat_files: Prisma.$component_flat_filePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      created_at: Date | null
      url: string | null
      hidden: boolean | null
      user_id: string
      name: string
      gen_in_data: Prisma.JsonValue | null
      gen_out_data: Prisma.JsonValue | null
      mime_type: string | null
      rel_id: string | null
      rel_type: string | null
      tags: string[]
    }, ExtArgs["result"]["flat_file"]>
    composites: {}
  }

  type flat_fileGetPayload<S extends boolean | null | undefined | flat_fileDefaultArgs> = $Result.GetResult<Prisma.$flat_filePayload, S>

  type flat_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<flat_fileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Flat_fileCountAggregateInputType | true
    }

  export interface flat_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flat_file'], meta: { name: 'flat_file' } }
    /**
     * Find zero or one Flat_file that matches the filter.
     * @param {flat_fileFindUniqueArgs} args - Arguments to find a Flat_file
     * @example
     * // Get one Flat_file
     * const flat_file = await prisma.flat_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flat_fileFindUniqueArgs>(args: SelectSubset<T, flat_fileFindUniqueArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Flat_file that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {flat_fileFindUniqueOrThrowArgs} args - Arguments to find a Flat_file
     * @example
     * // Get one Flat_file
     * const flat_file = await prisma.flat_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flat_fileFindUniqueOrThrowArgs>(args: SelectSubset<T, flat_fileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Flat_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flat_fileFindFirstArgs} args - Arguments to find a Flat_file
     * @example
     * // Get one Flat_file
     * const flat_file = await prisma.flat_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flat_fileFindFirstArgs>(args?: SelectSubset<T, flat_fileFindFirstArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Flat_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flat_fileFindFirstOrThrowArgs} args - Arguments to find a Flat_file
     * @example
     * // Get one Flat_file
     * const flat_file = await prisma.flat_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flat_fileFindFirstOrThrowArgs>(args?: SelectSubset<T, flat_fileFindFirstOrThrowArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Flat_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flat_fileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flat_files
     * const flat_files = await prisma.flat_file.findMany()
     * 
     * // Get first 10 Flat_files
     * const flat_files = await prisma.flat_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flat_fileWithIdOnly = await prisma.flat_file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends flat_fileFindManyArgs>(args?: SelectSubset<T, flat_fileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Flat_file.
     * @param {flat_fileCreateArgs} args - Arguments to create a Flat_file.
     * @example
     * // Create one Flat_file
     * const Flat_file = await prisma.flat_file.create({
     *   data: {
     *     // ... data to create a Flat_file
     *   }
     * })
     * 
     */
    create<T extends flat_fileCreateArgs>(args: SelectSubset<T, flat_fileCreateArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Flat_files.
     * @param {flat_fileCreateManyArgs} args - Arguments to create many Flat_files.
     * @example
     * // Create many Flat_files
     * const flat_file = await prisma.flat_file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flat_fileCreateManyArgs>(args?: SelectSubset<T, flat_fileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flat_files and returns the data saved in the database.
     * @param {flat_fileCreateManyAndReturnArgs} args - Arguments to create many Flat_files.
     * @example
     * // Create many Flat_files
     * const flat_file = await prisma.flat_file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flat_files and only return the `id`
     * const flat_fileWithIdOnly = await prisma.flat_file.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends flat_fileCreateManyAndReturnArgs>(args?: SelectSubset<T, flat_fileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Flat_file.
     * @param {flat_fileDeleteArgs} args - Arguments to delete one Flat_file.
     * @example
     * // Delete one Flat_file
     * const Flat_file = await prisma.flat_file.delete({
     *   where: {
     *     // ... filter to delete one Flat_file
     *   }
     * })
     * 
     */
    delete<T extends flat_fileDeleteArgs>(args: SelectSubset<T, flat_fileDeleteArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Flat_file.
     * @param {flat_fileUpdateArgs} args - Arguments to update one Flat_file.
     * @example
     * // Update one Flat_file
     * const flat_file = await prisma.flat_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flat_fileUpdateArgs>(args: SelectSubset<T, flat_fileUpdateArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Flat_files.
     * @param {flat_fileDeleteManyArgs} args - Arguments to filter Flat_files to delete.
     * @example
     * // Delete a few Flat_files
     * const { count } = await prisma.flat_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flat_fileDeleteManyArgs>(args?: SelectSubset<T, flat_fileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flat_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flat_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flat_files
     * const flat_file = await prisma.flat_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flat_fileUpdateManyArgs>(args: SelectSubset<T, flat_fileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flat_file.
     * @param {flat_fileUpsertArgs} args - Arguments to update or create a Flat_file.
     * @example
     * // Update or create a Flat_file
     * const flat_file = await prisma.flat_file.upsert({
     *   create: {
     *     // ... data to create a Flat_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flat_file we want to update
     *   }
     * })
     */
    upsert<T extends flat_fileUpsertArgs>(args: SelectSubset<T, flat_fileUpsertArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Flat_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flat_fileCountArgs} args - Arguments to filter Flat_files to count.
     * @example
     * // Count the number of Flat_files
     * const count = await prisma.flat_file.count({
     *   where: {
     *     // ... the filter for the Flat_files we want to count
     *   }
     * })
    **/
    count<T extends flat_fileCountArgs>(
      args?: Subset<T, flat_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Flat_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flat_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Flat_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Flat_fileAggregateArgs>(args: Subset<T, Flat_fileAggregateArgs>): Prisma.PrismaPromise<GetFlat_fileAggregateType<T>>

    /**
     * Group by Flat_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flat_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flat_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flat_fileGroupByArgs['orderBy'] }
        : { orderBy?: flat_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flat_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlat_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flat_file model
   */
  readonly fields: flat_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flat_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flat_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_message<T extends flat_file$chat_messageArgs<ExtArgs> = {}>(args?: Subset<T, flat_file$chat_messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findMany"> | Null>
    component_flat_files<T extends flat_file$component_flat_filesArgs<ExtArgs> = {}>(args?: Subset<T, flat_file$component_flat_filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flat_file model
   */ 
  interface flat_fileFieldRefs {
    readonly id: FieldRef<"flat_file", 'BigInt'>
    readonly created_at: FieldRef<"flat_file", 'DateTime'>
    readonly url: FieldRef<"flat_file", 'String'>
    readonly hidden: FieldRef<"flat_file", 'Boolean'>
    readonly user_id: FieldRef<"flat_file", 'String'>
    readonly name: FieldRef<"flat_file", 'String'>
    readonly gen_in_data: FieldRef<"flat_file", 'Json'>
    readonly gen_out_data: FieldRef<"flat_file", 'Json'>
    readonly mime_type: FieldRef<"flat_file", 'String'>
    readonly rel_id: FieldRef<"flat_file", 'String'>
    readonly rel_type: FieldRef<"flat_file", 'String'>
    readonly tags: FieldRef<"flat_file", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * flat_file findUnique
   */
  export type flat_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which flat_file to fetch.
     */
    where: flat_fileWhereUniqueInput
  }

  /**
   * flat_file findUniqueOrThrow
   */
  export type flat_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which flat_file to fetch.
     */
    where: flat_fileWhereUniqueInput
  }

  /**
   * flat_file findFirst
   */
  export type flat_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which flat_file to fetch.
     */
    where?: flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flat_files to fetch.
     */
    orderBy?: flat_fileOrderByWithRelationInput | flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flat_files.
     */
    cursor?: flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flat_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flat_files.
     */
    distinct?: Flat_fileScalarFieldEnum | Flat_fileScalarFieldEnum[]
  }

  /**
   * flat_file findFirstOrThrow
   */
  export type flat_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which flat_file to fetch.
     */
    where?: flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flat_files to fetch.
     */
    orderBy?: flat_fileOrderByWithRelationInput | flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flat_files.
     */
    cursor?: flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flat_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flat_files.
     */
    distinct?: Flat_fileScalarFieldEnum | Flat_fileScalarFieldEnum[]
  }

  /**
   * flat_file findMany
   */
  export type flat_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which flat_files to fetch.
     */
    where?: flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flat_files to fetch.
     */
    orderBy?: flat_fileOrderByWithRelationInput | flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flat_files.
     */
    cursor?: flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flat_files.
     */
    skip?: number
    distinct?: Flat_fileScalarFieldEnum | Flat_fileScalarFieldEnum[]
  }

  /**
   * flat_file create
   */
  export type flat_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * The data needed to create a flat_file.
     */
    data: XOR<flat_fileCreateInput, flat_fileUncheckedCreateInput>
  }

  /**
   * flat_file createMany
   */
  export type flat_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flat_files.
     */
    data: flat_fileCreateManyInput | flat_fileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flat_file createManyAndReturn
   */
  export type flat_fileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many flat_files.
     */
    data: flat_fileCreateManyInput | flat_fileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flat_file update
   */
  export type flat_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * The data needed to update a flat_file.
     */
    data: XOR<flat_fileUpdateInput, flat_fileUncheckedUpdateInput>
    /**
     * Choose, which flat_file to update.
     */
    where: flat_fileWhereUniqueInput
  }

  /**
   * flat_file updateMany
   */
  export type flat_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flat_files.
     */
    data: XOR<flat_fileUpdateManyMutationInput, flat_fileUncheckedUpdateManyInput>
    /**
     * Filter which flat_files to update
     */
    where?: flat_fileWhereInput
  }

  /**
   * flat_file upsert
   */
  export type flat_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * The filter to search for the flat_file to update in case it exists.
     */
    where: flat_fileWhereUniqueInput
    /**
     * In case the flat_file found by the `where` argument doesn't exist, create a new flat_file with this data.
     */
    create: XOR<flat_fileCreateInput, flat_fileUncheckedCreateInput>
    /**
     * In case the flat_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flat_fileUpdateInput, flat_fileUncheckedUpdateInput>
  }

  /**
   * flat_file delete
   */
  export type flat_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    /**
     * Filter which flat_file to delete.
     */
    where: flat_fileWhereUniqueInput
  }

  /**
   * flat_file deleteMany
   */
  export type flat_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flat_files to delete
     */
    where?: flat_fileWhereInput
  }

  /**
   * flat_file.chat_message
   */
  export type flat_file$chat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    where?: chat_messageWhereInput
    orderBy?: chat_messageOrderByWithRelationInput | chat_messageOrderByWithRelationInput[]
    cursor?: chat_messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messageScalarFieldEnum | Chat_messageScalarFieldEnum[]
  }

  /**
   * flat_file.component_flat_files
   */
  export type flat_file$component_flat_filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    where?: component_flat_fileWhereInput
    orderBy?: component_flat_fileOrderByWithRelationInput | component_flat_fileOrderByWithRelationInput[]
    cursor?: component_flat_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Component_flat_fileScalarFieldEnum | Component_flat_fileScalarFieldEnum[]
  }

  /**
   * flat_file without action
   */
  export type flat_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
  }


  /**
   * Model component_flat_file
   */

  export type AggregateComponent_flat_file = {
    _count: Component_flat_fileCountAggregateOutputType | null
    _avg: Component_flat_fileAvgAggregateOutputType | null
    _sum: Component_flat_fileSumAggregateOutputType | null
    _min: Component_flat_fileMinAggregateOutputType | null
    _max: Component_flat_fileMaxAggregateOutputType | null
  }

  export type Component_flat_fileAvgAggregateOutputType = {
    id: number | null
    component_id: number | null
    flat_file_id: number | null
  }

  export type Component_flat_fileSumAggregateOutputType = {
    id: bigint | null
    component_id: bigint | null
    flat_file_id: bigint | null
  }

  export type Component_flat_fileMinAggregateOutputType = {
    id: bigint | null
    component_id: bigint | null
    flat_file_id: bigint | null
  }

  export type Component_flat_fileMaxAggregateOutputType = {
    id: bigint | null
    component_id: bigint | null
    flat_file_id: bigint | null
  }

  export type Component_flat_fileCountAggregateOutputType = {
    id: number
    component_id: number
    flat_file_id: number
    _all: number
  }


  export type Component_flat_fileAvgAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
  }

  export type Component_flat_fileSumAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
  }

  export type Component_flat_fileMinAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
  }

  export type Component_flat_fileMaxAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
  }

  export type Component_flat_fileCountAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
    _all?: true
  }

  export type Component_flat_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which component_flat_file to aggregate.
     */
    where?: component_flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_files to fetch.
     */
    orderBy?: component_flat_fileOrderByWithRelationInput | component_flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: component_flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned component_flat_files
    **/
    _count?: true | Component_flat_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Component_flat_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Component_flat_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Component_flat_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Component_flat_fileMaxAggregateInputType
  }

  export type GetComponent_flat_fileAggregateType<T extends Component_flat_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent_flat_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent_flat_file[P]>
      : GetScalarType<T[P], AggregateComponent_flat_file[P]>
  }




  export type component_flat_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: component_flat_fileWhereInput
    orderBy?: component_flat_fileOrderByWithAggregationInput | component_flat_fileOrderByWithAggregationInput[]
    by: Component_flat_fileScalarFieldEnum[] | Component_flat_fileScalarFieldEnum
    having?: component_flat_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Component_flat_fileCountAggregateInputType | true
    _avg?: Component_flat_fileAvgAggregateInputType
    _sum?: Component_flat_fileSumAggregateInputType
    _min?: Component_flat_fileMinAggregateInputType
    _max?: Component_flat_fileMaxAggregateInputType
  }

  export type Component_flat_fileGroupByOutputType = {
    id: bigint
    component_id: bigint
    flat_file_id: bigint
    _count: Component_flat_fileCountAggregateOutputType | null
    _avg: Component_flat_fileAvgAggregateOutputType | null
    _sum: Component_flat_fileSumAggregateOutputType | null
    _min: Component_flat_fileMinAggregateOutputType | null
    _max: Component_flat_fileMaxAggregateOutputType | null
  }

  type GetComponent_flat_fileGroupByPayload<T extends component_flat_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Component_flat_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Component_flat_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Component_flat_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Component_flat_fileGroupByOutputType[P]>
        }
      >
    >


  export type component_flat_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component_id?: boolean
    flat_file_id?: boolean
    component?: boolean | componentDefaultArgs<ExtArgs>
    flat_file?: boolean | flat_fileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component_flat_file"]>

  export type component_flat_fileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component_id?: boolean
    flat_file_id?: boolean
    component?: boolean | componentDefaultArgs<ExtArgs>
    flat_file?: boolean | flat_fileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component_flat_file"]>

  export type component_flat_fileSelectScalar = {
    id?: boolean
    component_id?: boolean
    flat_file_id?: boolean
  }

  export type component_flat_fileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | componentDefaultArgs<ExtArgs>
    flat_file?: boolean | flat_fileDefaultArgs<ExtArgs>
  }
  export type component_flat_fileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | componentDefaultArgs<ExtArgs>
    flat_file?: boolean | flat_fileDefaultArgs<ExtArgs>
  }

  export type $component_flat_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "component_flat_file"
    objects: {
      component: Prisma.$componentPayload<ExtArgs>
      flat_file: Prisma.$flat_filePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      component_id: bigint
      flat_file_id: bigint
    }, ExtArgs["result"]["component_flat_file"]>
    composites: {}
  }

  type component_flat_fileGetPayload<S extends boolean | null | undefined | component_flat_fileDefaultArgs> = $Result.GetResult<Prisma.$component_flat_filePayload, S>

  type component_flat_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<component_flat_fileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Component_flat_fileCountAggregateInputType | true
    }

  export interface component_flat_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['component_flat_file'], meta: { name: 'component_flat_file' } }
    /**
     * Find zero or one Component_flat_file that matches the filter.
     * @param {component_flat_fileFindUniqueArgs} args - Arguments to find a Component_flat_file
     * @example
     * // Get one Component_flat_file
     * const component_flat_file = await prisma.component_flat_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends component_flat_fileFindUniqueArgs>(args: SelectSubset<T, component_flat_fileFindUniqueArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Component_flat_file that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {component_flat_fileFindUniqueOrThrowArgs} args - Arguments to find a Component_flat_file
     * @example
     * // Get one Component_flat_file
     * const component_flat_file = await prisma.component_flat_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends component_flat_fileFindUniqueOrThrowArgs>(args: SelectSubset<T, component_flat_fileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Component_flat_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_fileFindFirstArgs} args - Arguments to find a Component_flat_file
     * @example
     * // Get one Component_flat_file
     * const component_flat_file = await prisma.component_flat_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends component_flat_fileFindFirstArgs>(args?: SelectSubset<T, component_flat_fileFindFirstArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Component_flat_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_fileFindFirstOrThrowArgs} args - Arguments to find a Component_flat_file
     * @example
     * // Get one Component_flat_file
     * const component_flat_file = await prisma.component_flat_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends component_flat_fileFindFirstOrThrowArgs>(args?: SelectSubset<T, component_flat_fileFindFirstOrThrowArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Component_flat_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_fileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Component_flat_files
     * const component_flat_files = await prisma.component_flat_file.findMany()
     * 
     * // Get first 10 Component_flat_files
     * const component_flat_files = await prisma.component_flat_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const component_flat_fileWithIdOnly = await prisma.component_flat_file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends component_flat_fileFindManyArgs>(args?: SelectSubset<T, component_flat_fileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Component_flat_file.
     * @param {component_flat_fileCreateArgs} args - Arguments to create a Component_flat_file.
     * @example
     * // Create one Component_flat_file
     * const Component_flat_file = await prisma.component_flat_file.create({
     *   data: {
     *     // ... data to create a Component_flat_file
     *   }
     * })
     * 
     */
    create<T extends component_flat_fileCreateArgs>(args: SelectSubset<T, component_flat_fileCreateArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Component_flat_files.
     * @param {component_flat_fileCreateManyArgs} args - Arguments to create many Component_flat_files.
     * @example
     * // Create many Component_flat_files
     * const component_flat_file = await prisma.component_flat_file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends component_flat_fileCreateManyArgs>(args?: SelectSubset<T, component_flat_fileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Component_flat_files and returns the data saved in the database.
     * @param {component_flat_fileCreateManyAndReturnArgs} args - Arguments to create many Component_flat_files.
     * @example
     * // Create many Component_flat_files
     * const component_flat_file = await prisma.component_flat_file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Component_flat_files and only return the `id`
     * const component_flat_fileWithIdOnly = await prisma.component_flat_file.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends component_flat_fileCreateManyAndReturnArgs>(args?: SelectSubset<T, component_flat_fileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Component_flat_file.
     * @param {component_flat_fileDeleteArgs} args - Arguments to delete one Component_flat_file.
     * @example
     * // Delete one Component_flat_file
     * const Component_flat_file = await prisma.component_flat_file.delete({
     *   where: {
     *     // ... filter to delete one Component_flat_file
     *   }
     * })
     * 
     */
    delete<T extends component_flat_fileDeleteArgs>(args: SelectSubset<T, component_flat_fileDeleteArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Component_flat_file.
     * @param {component_flat_fileUpdateArgs} args - Arguments to update one Component_flat_file.
     * @example
     * // Update one Component_flat_file
     * const component_flat_file = await prisma.component_flat_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends component_flat_fileUpdateArgs>(args: SelectSubset<T, component_flat_fileUpdateArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Component_flat_files.
     * @param {component_flat_fileDeleteManyArgs} args - Arguments to filter Component_flat_files to delete.
     * @example
     * // Delete a few Component_flat_files
     * const { count } = await prisma.component_flat_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends component_flat_fileDeleteManyArgs>(args?: SelectSubset<T, component_flat_fileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Component_flat_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Component_flat_files
     * const component_flat_file = await prisma.component_flat_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends component_flat_fileUpdateManyArgs>(args: SelectSubset<T, component_flat_fileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component_flat_file.
     * @param {component_flat_fileUpsertArgs} args - Arguments to update or create a Component_flat_file.
     * @example
     * // Update or create a Component_flat_file
     * const component_flat_file = await prisma.component_flat_file.upsert({
     *   create: {
     *     // ... data to create a Component_flat_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component_flat_file we want to update
     *   }
     * })
     */
    upsert<T extends component_flat_fileUpsertArgs>(args: SelectSubset<T, component_flat_fileUpsertArgs<ExtArgs>>): Prisma__component_flat_fileClient<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Component_flat_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_fileCountArgs} args - Arguments to filter Component_flat_files to count.
     * @example
     * // Count the number of Component_flat_files
     * const count = await prisma.component_flat_file.count({
     *   where: {
     *     // ... the filter for the Component_flat_files we want to count
     *   }
     * })
    **/
    count<T extends component_flat_fileCountArgs>(
      args?: Subset<T, component_flat_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Component_flat_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component_flat_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Component_flat_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Component_flat_fileAggregateArgs>(args: Subset<T, Component_flat_fileAggregateArgs>): Prisma.PrismaPromise<GetComponent_flat_fileAggregateType<T>>

    /**
     * Group by Component_flat_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends component_flat_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: component_flat_fileGroupByArgs['orderBy'] }
        : { orderBy?: component_flat_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, component_flat_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponent_flat_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the component_flat_file model
   */
  readonly fields: component_flat_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for component_flat_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__component_flat_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends componentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, componentDefaultArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    flat_file<T extends flat_fileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, flat_fileDefaultArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the component_flat_file model
   */ 
  interface component_flat_fileFieldRefs {
    readonly id: FieldRef<"component_flat_file", 'BigInt'>
    readonly component_id: FieldRef<"component_flat_file", 'BigInt'>
    readonly flat_file_id: FieldRef<"component_flat_file", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * component_flat_file findUnique
   */
  export type component_flat_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which component_flat_file to fetch.
     */
    where: component_flat_fileWhereUniqueInput
  }

  /**
   * component_flat_file findUniqueOrThrow
   */
  export type component_flat_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which component_flat_file to fetch.
     */
    where: component_flat_fileWhereUniqueInput
  }

  /**
   * component_flat_file findFirst
   */
  export type component_flat_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which component_flat_file to fetch.
     */
    where?: component_flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_files to fetch.
     */
    orderBy?: component_flat_fileOrderByWithRelationInput | component_flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for component_flat_files.
     */
    cursor?: component_flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of component_flat_files.
     */
    distinct?: Component_flat_fileScalarFieldEnum | Component_flat_fileScalarFieldEnum[]
  }

  /**
   * component_flat_file findFirstOrThrow
   */
  export type component_flat_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which component_flat_file to fetch.
     */
    where?: component_flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_files to fetch.
     */
    orderBy?: component_flat_fileOrderByWithRelationInput | component_flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for component_flat_files.
     */
    cursor?: component_flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of component_flat_files.
     */
    distinct?: Component_flat_fileScalarFieldEnum | Component_flat_fileScalarFieldEnum[]
  }

  /**
   * component_flat_file findMany
   */
  export type component_flat_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * Filter, which component_flat_files to fetch.
     */
    where?: component_flat_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_files to fetch.
     */
    orderBy?: component_flat_fileOrderByWithRelationInput | component_flat_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing component_flat_files.
     */
    cursor?: component_flat_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_files.
     */
    skip?: number
    distinct?: Component_flat_fileScalarFieldEnum | Component_flat_fileScalarFieldEnum[]
  }

  /**
   * component_flat_file create
   */
  export type component_flat_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * The data needed to create a component_flat_file.
     */
    data: XOR<component_flat_fileCreateInput, component_flat_fileUncheckedCreateInput>
  }

  /**
   * component_flat_file createMany
   */
  export type component_flat_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many component_flat_files.
     */
    data: component_flat_fileCreateManyInput | component_flat_fileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * component_flat_file createManyAndReturn
   */
  export type component_flat_fileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many component_flat_files.
     */
    data: component_flat_fileCreateManyInput | component_flat_fileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * component_flat_file update
   */
  export type component_flat_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * The data needed to update a component_flat_file.
     */
    data: XOR<component_flat_fileUpdateInput, component_flat_fileUncheckedUpdateInput>
    /**
     * Choose, which component_flat_file to update.
     */
    where: component_flat_fileWhereUniqueInput
  }

  /**
   * component_flat_file updateMany
   */
  export type component_flat_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update component_flat_files.
     */
    data: XOR<component_flat_fileUpdateManyMutationInput, component_flat_fileUncheckedUpdateManyInput>
    /**
     * Filter which component_flat_files to update
     */
    where?: component_flat_fileWhereInput
  }

  /**
   * component_flat_file upsert
   */
  export type component_flat_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * The filter to search for the component_flat_file to update in case it exists.
     */
    where: component_flat_fileWhereUniqueInput
    /**
     * In case the component_flat_file found by the `where` argument doesn't exist, create a new component_flat_file with this data.
     */
    create: XOR<component_flat_fileCreateInput, component_flat_fileUncheckedCreateInput>
    /**
     * In case the component_flat_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<component_flat_fileUpdateInput, component_flat_fileUncheckedUpdateInput>
  }

  /**
   * component_flat_file delete
   */
  export type component_flat_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    /**
     * Filter which component_flat_file to delete.
     */
    where: component_flat_fileWhereUniqueInput
  }

  /**
   * component_flat_file deleteMany
   */
  export type component_flat_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which component_flat_files to delete
     */
    where?: component_flat_fileWhereInput
  }

  /**
   * component_flat_file without action
   */
  export type component_flat_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
  }


  /**
   * Model project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    name: string | null
    user_id: string | null
    current_project_history_id: string | null
    version: string | null
    archived: boolean | null
    is_default: boolean | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    name: string | null
    user_id: string | null
    current_project_history_id: string | null
    version: string | null
    archived: boolean | null
    is_default: boolean | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    created_at: number
    name: number
    user_id: number
    data: number
    current_project_history_id: number
    version: number
    archived: number
    is_default: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    created_at?: true
    name?: true
    user_id?: true
    current_project_history_id?: true
    version?: true
    archived?: true
    is_default?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    created_at?: true
    name?: true
    user_id?: true
    current_project_history_id?: true
    version?: true
    archived?: true
    is_default?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    created_at?: true
    name?: true
    user_id?: true
    data?: true
    current_project_history_id?: true
    version?: true
    archived?: true
    is_default?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project to aggregate.
     */
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectOrderByWithRelationInput | projectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type projectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectWhereInput
    orderBy?: projectOrderByWithAggregationInput | projectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: projectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    created_at: Date
    name: string
    user_id: string
    data: JsonValue | null
    current_project_history_id: string | null
    version: string | null
    archived: boolean
    is_default: boolean
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends projectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type projectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    name?: boolean
    user_id?: boolean
    data?: boolean
    current_project_history_id?: boolean
    version?: boolean
    archived?: boolean
    is_default?: boolean
    collection?: boolean | project$collectionArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type projectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    name?: boolean
    user_id?: boolean
    data?: boolean
    current_project_history_id?: boolean
    version?: boolean
    archived?: boolean
    is_default?: boolean
  }, ExtArgs["result"]["project"]>

  export type projectSelectScalar = {
    id?: boolean
    created_at?: boolean
    name?: boolean
    user_id?: boolean
    data?: boolean
    current_project_history_id?: boolean
    version?: boolean
    archived?: boolean
    is_default?: boolean
  }

  export type projectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | project$collectionArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $projectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      name: string
      user_id: string
      data: Prisma.JsonValue | null
      current_project_history_id: string | null
      version: string | null
      archived: boolean
      is_default: boolean
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type projectGetPayload<S extends boolean | null | undefined | projectDefaultArgs> = $Result.GetResult<Prisma.$projectPayload, S>

  type projectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface projectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project'], meta: { name: 'project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {projectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectFindUniqueArgs>(args: SelectSubset<T, projectFindUniqueArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectFindUniqueOrThrowArgs>(args: SelectSubset<T, projectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectFindFirstArgs>(args?: SelectSubset<T, projectFindFirstArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectFindFirstOrThrowArgs>(args?: SelectSubset<T, projectFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projectFindManyArgs>(args?: SelectSubset<T, projectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {projectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends projectCreateArgs>(args: SelectSubset<T, projectCreateArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {projectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectCreateManyArgs>(args?: SelectSubset<T, projectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {projectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectCreateManyAndReturnArgs>(args?: SelectSubset<T, projectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {projectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends projectDeleteArgs>(args: SelectSubset<T, projectDeleteArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {projectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectUpdateArgs>(args: SelectSubset<T, projectUpdateArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {projectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectDeleteManyArgs>(args?: SelectSubset<T, projectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectUpdateManyArgs>(args: SelectSubset<T, projectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {projectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends projectUpsertArgs>(args: SelectSubset<T, projectUpsertArgs<ExtArgs>>): Prisma__projectClient<$Result.GetResult<Prisma.$projectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends projectCountArgs>(
      args?: Subset<T, projectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectGroupByArgs['orderBy'] }
        : { orderBy?: projectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project model
   */
  readonly fields: projectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends project$collectionArgs<ExtArgs> = {}>(args?: Subset<T, project$collectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project model
   */ 
  interface projectFieldRefs {
    readonly id: FieldRef<"project", 'String'>
    readonly created_at: FieldRef<"project", 'DateTime'>
    readonly name: FieldRef<"project", 'String'>
    readonly user_id: FieldRef<"project", 'String'>
    readonly data: FieldRef<"project", 'Json'>
    readonly current_project_history_id: FieldRef<"project", 'String'>
    readonly version: FieldRef<"project", 'String'>
    readonly archived: FieldRef<"project", 'Boolean'>
    readonly is_default: FieldRef<"project", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * project findUnique
   */
  export type projectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * Filter, which project to fetch.
     */
    where: projectWhereUniqueInput
  }

  /**
   * project findUniqueOrThrow
   */
  export type projectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * Filter, which project to fetch.
     */
    where: projectWhereUniqueInput
  }

  /**
   * project findFirst
   */
  export type projectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * Filter, which project to fetch.
     */
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectOrderByWithRelationInput | projectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * project findFirstOrThrow
   */
  export type projectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * Filter, which project to fetch.
     */
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectOrderByWithRelationInput | projectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * project findMany
   */
  export type projectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectOrderByWithRelationInput | projectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projects.
     */
    cursor?: projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * project create
   */
  export type projectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * The data needed to create a project.
     */
    data: XOR<projectCreateInput, projectUncheckedCreateInput>
  }

  /**
   * project createMany
   */
  export type projectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projects.
     */
    data: projectCreateManyInput | projectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project createManyAndReturn
   */
  export type projectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many projects.
     */
    data: projectCreateManyInput | projectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project update
   */
  export type projectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * The data needed to update a project.
     */
    data: XOR<projectUpdateInput, projectUncheckedUpdateInput>
    /**
     * Choose, which project to update.
     */
    where: projectWhereUniqueInput
  }

  /**
   * project updateMany
   */
  export type projectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projects.
     */
    data: XOR<projectUpdateManyMutationInput, projectUncheckedUpdateManyInput>
    /**
     * Filter which projects to update
     */
    where?: projectWhereInput
  }

  /**
   * project upsert
   */
  export type projectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * The filter to search for the project to update in case it exists.
     */
    where: projectWhereUniqueInput
    /**
     * In case the project found by the `where` argument doesn't exist, create a new project with this data.
     */
    create: XOR<projectCreateInput, projectUncheckedCreateInput>
    /**
     * In case the project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectUpdateInput, projectUncheckedUpdateInput>
  }

  /**
   * project delete
   */
  export type projectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
    /**
     * Filter which project to delete.
     */
    where: projectWhereUniqueInput
  }

  /**
   * project deleteMany
   */
  export type projectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to delete
     */
    where?: projectWhereInput
  }

  /**
   * project.collection
   */
  export type project$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    where?: collectionWhereInput
    orderBy?: collectionOrderByWithRelationInput | collectionOrderByWithRelationInput[]
    cursor?: collectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * project without action
   */
  export type projectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project
     */
    select?: projectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectInclude<ExtArgs> | null
  }


  /**
   * Model project_history
   */

  export type AggregateProject_history = {
    _count: Project_historyCountAggregateOutputType | null
    _min: Project_historyMinAggregateOutputType | null
    _max: Project_historyMaxAggregateOutputType | null
  }

  export type Project_historyMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    user_id: string | null
    project_id: string | null
    name: string | null
  }

  export type Project_historyMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    user_id: string | null
    project_id: string | null
    name: string | null
  }

  export type Project_historyCountAggregateOutputType = {
    id: number
    created_at: number
    data: number
    user_id: number
    project_id: number
    name: number
    images: number
    _all: number
  }


  export type Project_historyMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    project_id?: true
    name?: true
  }

  export type Project_historyMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    project_id?: true
    name?: true
  }

  export type Project_historyCountAggregateInputType = {
    id?: true
    created_at?: true
    data?: true
    user_id?: true
    project_id?: true
    name?: true
    images?: true
    _all?: true
  }

  export type Project_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_history to aggregate.
     */
    where?: project_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_histories to fetch.
     */
    orderBy?: project_historyOrderByWithRelationInput | project_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: project_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_histories
    **/
    _count?: true | Project_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Project_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Project_historyMaxAggregateInputType
  }

  export type GetProject_historyAggregateType<T extends Project_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateProject_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_history[P]>
      : GetScalarType<T[P], AggregateProject_history[P]>
  }




  export type project_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_historyWhereInput
    orderBy?: project_historyOrderByWithAggregationInput | project_historyOrderByWithAggregationInput[]
    by: Project_historyScalarFieldEnum[] | Project_historyScalarFieldEnum
    having?: project_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Project_historyCountAggregateInputType | true
    _min?: Project_historyMinAggregateInputType
    _max?: Project_historyMaxAggregateInputType
  }

  export type Project_historyGroupByOutputType = {
    id: string
    created_at: Date
    data: JsonValue
    user_id: string
    project_id: string
    name: string
    images: JsonValue | null
    _count: Project_historyCountAggregateOutputType | null
    _min: Project_historyMinAggregateOutputType | null
    _max: Project_historyMaxAggregateOutputType | null
  }

  type GetProject_historyGroupByPayload<T extends project_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Project_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Project_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Project_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Project_historyGroupByOutputType[P]>
        }
      >
    >


  export type project_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    data?: boolean
    user_id?: boolean
    project_id?: boolean
    name?: boolean
    images?: boolean
  }, ExtArgs["result"]["project_history"]>

  export type project_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    data?: boolean
    user_id?: boolean
    project_id?: boolean
    name?: boolean
    images?: boolean
  }, ExtArgs["result"]["project_history"]>

  export type project_historySelectScalar = {
    id?: boolean
    created_at?: boolean
    data?: boolean
    user_id?: boolean
    project_id?: boolean
    name?: boolean
    images?: boolean
  }


  export type $project_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      data: Prisma.JsonValue
      user_id: string
      project_id: string
      name: string
      images: Prisma.JsonValue | null
    }, ExtArgs["result"]["project_history"]>
    composites: {}
  }

  type project_historyGetPayload<S extends boolean | null | undefined | project_historyDefaultArgs> = $Result.GetResult<Prisma.$project_historyPayload, S>

  type project_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<project_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Project_historyCountAggregateInputType | true
    }

  export interface project_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project_history'], meta: { name: 'project_history' } }
    /**
     * Find zero or one Project_history that matches the filter.
     * @param {project_historyFindUniqueArgs} args - Arguments to find a Project_history
     * @example
     * // Get one Project_history
     * const project_history = await prisma.project_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends project_historyFindUniqueArgs>(args: SelectSubset<T, project_historyFindUniqueArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {project_historyFindUniqueOrThrowArgs} args - Arguments to find a Project_history
     * @example
     * // Get one Project_history
     * const project_history = await prisma.project_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends project_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, project_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_historyFindFirstArgs} args - Arguments to find a Project_history
     * @example
     * // Get one Project_history
     * const project_history = await prisma.project_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends project_historyFindFirstArgs>(args?: SelectSubset<T, project_historyFindFirstArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_historyFindFirstOrThrowArgs} args - Arguments to find a Project_history
     * @example
     * // Get one Project_history
     * const project_history = await prisma.project_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends project_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, project_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Project_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_histories
     * const project_histories = await prisma.project_history.findMany()
     * 
     * // Get first 10 Project_histories
     * const project_histories = await prisma.project_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_historyWithIdOnly = await prisma.project_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends project_historyFindManyArgs>(args?: SelectSubset<T, project_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project_history.
     * @param {project_historyCreateArgs} args - Arguments to create a Project_history.
     * @example
     * // Create one Project_history
     * const Project_history = await prisma.project_history.create({
     *   data: {
     *     // ... data to create a Project_history
     *   }
     * })
     * 
     */
    create<T extends project_historyCreateArgs>(args: SelectSubset<T, project_historyCreateArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Project_histories.
     * @param {project_historyCreateManyArgs} args - Arguments to create many Project_histories.
     * @example
     * // Create many Project_histories
     * const project_history = await prisma.project_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends project_historyCreateManyArgs>(args?: SelectSubset<T, project_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Project_histories and returns the data saved in the database.
     * @param {project_historyCreateManyAndReturnArgs} args - Arguments to create many Project_histories.
     * @example
     * // Create many Project_histories
     * const project_history = await prisma.project_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Project_histories and only return the `id`
     * const project_historyWithIdOnly = await prisma.project_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends project_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, project_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project_history.
     * @param {project_historyDeleteArgs} args - Arguments to delete one Project_history.
     * @example
     * // Delete one Project_history
     * const Project_history = await prisma.project_history.delete({
     *   where: {
     *     // ... filter to delete one Project_history
     *   }
     * })
     * 
     */
    delete<T extends project_historyDeleteArgs>(args: SelectSubset<T, project_historyDeleteArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project_history.
     * @param {project_historyUpdateArgs} args - Arguments to update one Project_history.
     * @example
     * // Update one Project_history
     * const project_history = await prisma.project_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends project_historyUpdateArgs>(args: SelectSubset<T, project_historyUpdateArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Project_histories.
     * @param {project_historyDeleteManyArgs} args - Arguments to filter Project_histories to delete.
     * @example
     * // Delete a few Project_histories
     * const { count } = await prisma.project_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends project_historyDeleteManyArgs>(args?: SelectSubset<T, project_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_histories
     * const project_history = await prisma.project_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends project_historyUpdateManyArgs>(args: SelectSubset<T, project_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project_history.
     * @param {project_historyUpsertArgs} args - Arguments to update or create a Project_history.
     * @example
     * // Update or create a Project_history
     * const project_history = await prisma.project_history.upsert({
     *   create: {
     *     // ... data to create a Project_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_history we want to update
     *   }
     * })
     */
    upsert<T extends project_historyUpsertArgs>(args: SelectSubset<T, project_historyUpsertArgs<ExtArgs>>): Prisma__project_historyClient<$Result.GetResult<Prisma.$project_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Project_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_historyCountArgs} args - Arguments to filter Project_histories to count.
     * @example
     * // Count the number of Project_histories
     * const count = await prisma.project_history.count({
     *   where: {
     *     // ... the filter for the Project_histories we want to count
     *   }
     * })
    **/
    count<T extends project_historyCountArgs>(
      args?: Subset<T, project_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Project_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_historyAggregateArgs>(args: Subset<T, Project_historyAggregateArgs>): Prisma.PrismaPromise<GetProject_historyAggregateType<T>>

    /**
     * Group by Project_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends project_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: project_historyGroupByArgs['orderBy'] }
        : { orderBy?: project_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, project_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProject_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project_history model
   */
  readonly fields: project_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__project_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project_history model
   */ 
  interface project_historyFieldRefs {
    readonly id: FieldRef<"project_history", 'String'>
    readonly created_at: FieldRef<"project_history", 'DateTime'>
    readonly data: FieldRef<"project_history", 'Json'>
    readonly user_id: FieldRef<"project_history", 'String'>
    readonly project_id: FieldRef<"project_history", 'String'>
    readonly name: FieldRef<"project_history", 'String'>
    readonly images: FieldRef<"project_history", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * project_history findUnique
   */
  export type project_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * Filter, which project_history to fetch.
     */
    where: project_historyWhereUniqueInput
  }

  /**
   * project_history findUniqueOrThrow
   */
  export type project_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * Filter, which project_history to fetch.
     */
    where: project_historyWhereUniqueInput
  }

  /**
   * project_history findFirst
   */
  export type project_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * Filter, which project_history to fetch.
     */
    where?: project_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_histories to fetch.
     */
    orderBy?: project_historyOrderByWithRelationInput | project_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_histories.
     */
    cursor?: project_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_histories.
     */
    distinct?: Project_historyScalarFieldEnum | Project_historyScalarFieldEnum[]
  }

  /**
   * project_history findFirstOrThrow
   */
  export type project_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * Filter, which project_history to fetch.
     */
    where?: project_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_histories to fetch.
     */
    orderBy?: project_historyOrderByWithRelationInput | project_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_histories.
     */
    cursor?: project_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_histories.
     */
    distinct?: Project_historyScalarFieldEnum | Project_historyScalarFieldEnum[]
  }

  /**
   * project_history findMany
   */
  export type project_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * Filter, which project_histories to fetch.
     */
    where?: project_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_histories to fetch.
     */
    orderBy?: project_historyOrderByWithRelationInput | project_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_histories.
     */
    cursor?: project_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_histories.
     */
    skip?: number
    distinct?: Project_historyScalarFieldEnum | Project_historyScalarFieldEnum[]
  }

  /**
   * project_history create
   */
  export type project_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * The data needed to create a project_history.
     */
    data: XOR<project_historyCreateInput, project_historyUncheckedCreateInput>
  }

  /**
   * project_history createMany
   */
  export type project_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many project_histories.
     */
    data: project_historyCreateManyInput | project_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_history createManyAndReturn
   */
  export type project_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many project_histories.
     */
    data: project_historyCreateManyInput | project_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_history update
   */
  export type project_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * The data needed to update a project_history.
     */
    data: XOR<project_historyUpdateInput, project_historyUncheckedUpdateInput>
    /**
     * Choose, which project_history to update.
     */
    where: project_historyWhereUniqueInput
  }

  /**
   * project_history updateMany
   */
  export type project_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update project_histories.
     */
    data: XOR<project_historyUpdateManyMutationInput, project_historyUncheckedUpdateManyInput>
    /**
     * Filter which project_histories to update
     */
    where?: project_historyWhereInput
  }

  /**
   * project_history upsert
   */
  export type project_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * The filter to search for the project_history to update in case it exists.
     */
    where: project_historyWhereUniqueInput
    /**
     * In case the project_history found by the `where` argument doesn't exist, create a new project_history with this data.
     */
    create: XOR<project_historyCreateInput, project_historyUncheckedCreateInput>
    /**
     * In case the project_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<project_historyUpdateInput, project_historyUncheckedUpdateInput>
  }

  /**
   * project_history delete
   */
  export type project_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
    /**
     * Filter which project_history to delete.
     */
    where: project_historyWhereUniqueInput
  }

  /**
   * project_history deleteMany
   */
  export type project_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_histories to delete
     */
    where?: project_historyWhereInput
  }

  /**
   * project_history without action
   */
  export type project_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_history
     */
    select?: project_historySelect<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    created_at: Date | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    created_at: Date | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    user_id: number
    created_at: number
    name: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    user_id: string
    created_at: Date
    name: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    name?: boolean
  }


  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      created_at: Date
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */ 
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'String'>
    readonly user_id: FieldRef<"role", 'String'>
    readonly created_at: FieldRef<"role", 'DateTime'>
    readonly name: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
  }


  /**
   * Model wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    id: number | null
  }

  export type WalletSumAggregateOutputType = {
    id: bigint | null
  }

  export type WalletMinAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    address: string | null
    user_id: string | null
  }

  export type WalletMaxAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    address: string | null
    user_id: string | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    created_at: number
    address: number
    user_id: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    id?: true
  }

  export type WalletSumAggregateInputType = {
    id?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    created_at?: true
    address?: true
    user_id?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    created_at?: true
    address?: true
    user_id?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    created_at?: true
    address?: true
    user_id?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet to aggregate.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type walletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
    orderBy?: walletOrderByWithAggregationInput | walletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: bigint
    created_at: Date | null
    address: string
    user_id: string | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends walletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type walletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    address?: boolean
    user_id?: boolean
  }, ExtArgs["result"]["wallet"]>

  export type walletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    address?: boolean
    user_id?: boolean
  }, ExtArgs["result"]["wallet"]>

  export type walletSelectScalar = {
    id?: boolean
    created_at?: boolean
    address?: boolean
    user_id?: boolean
  }


  export type $walletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      created_at: Date | null
      address: string
      user_id: string | null
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type walletGetPayload<S extends boolean | null | undefined | walletDefaultArgs> = $Result.GetResult<Prisma.$walletPayload, S>

  type walletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<walletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface walletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet'], meta: { name: 'wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {walletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends walletFindUniqueArgs>(args: SelectSubset<T, walletFindUniqueArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {walletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends walletFindUniqueOrThrowArgs>(args: SelectSubset<T, walletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends walletFindFirstArgs>(args?: SelectSubset<T, walletFindFirstArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends walletFindFirstOrThrowArgs>(args?: SelectSubset<T, walletFindFirstOrThrowArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends walletFindManyArgs>(args?: SelectSubset<T, walletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {walletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends walletCreateArgs>(args: SelectSubset<T, walletCreateArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {walletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends walletCreateManyArgs>(args?: SelectSubset<T, walletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {walletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends walletCreateManyAndReturnArgs>(args?: SelectSubset<T, walletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wallet.
     * @param {walletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends walletDeleteArgs>(args: SelectSubset<T, walletDeleteArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {walletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends walletUpdateArgs>(args: SelectSubset<T, walletUpdateArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {walletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends walletDeleteManyArgs>(args?: SelectSubset<T, walletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends walletUpdateManyArgs>(args: SelectSubset<T, walletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {walletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends walletUpsertArgs>(args: SelectSubset<T, walletUpsertArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletCountArgs>(
      args?: Subset<T, walletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletGroupByArgs['orderBy'] }
        : { orderBy?: walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet model
   */
  readonly fields: walletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__walletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet model
   */ 
  interface walletFieldRefs {
    readonly id: FieldRef<"wallet", 'BigInt'>
    readonly created_at: FieldRef<"wallet", 'DateTime'>
    readonly address: FieldRef<"wallet", 'String'>
    readonly user_id: FieldRef<"wallet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * wallet findUnique
   */
  export type walletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findUniqueOrThrow
   */
  export type walletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findFirst
   */
  export type walletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findFirstOrThrow
   */
  export type walletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findMany
   */
  export type walletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet create
   */
  export type walletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * The data needed to create a wallet.
     */
    data: XOR<walletCreateInput, walletUncheckedCreateInput>
  }

  /**
   * wallet createMany
   */
  export type walletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet createManyAndReturn
   */
  export type walletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet update
   */
  export type walletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * The data needed to update a wallet.
     */
    data: XOR<walletUpdateInput, walletUncheckedUpdateInput>
    /**
     * Choose, which wallet to update.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet updateMany
   */
  export type walletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletWhereInput
  }

  /**
   * wallet upsert
   */
  export type walletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * The filter to search for the wallet to update in case it exists.
     */
    where: walletWhereUniqueInput
    /**
     * In case the wallet found by the `where` argument doesn't exist, create a new wallet with this data.
     */
    create: XOR<walletCreateInput, walletUncheckedCreateInput>
    /**
     * In case the wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletUpdateInput, walletUncheckedUpdateInput>
  }

  /**
   * wallet delete
   */
  export type walletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Filter which wallet to delete.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet deleteMany
   */
  export type walletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletWhereInput
  }

  /**
   * wallet without action
   */
  export type walletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
  }


  /**
   * Model credits_history
   */

  export type AggregateCredits_history = {
    _count: Credits_historyCountAggregateOutputType | null
    _avg: Credits_historyAvgAggregateOutputType | null
    _sum: Credits_historySumAggregateOutputType | null
    _min: Credits_historyMinAggregateOutputType | null
    _max: Credits_historyMaxAggregateOutputType | null
  }

  export type Credits_historyAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
  }

  export type Credits_historySumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
  }

  export type Credits_historyMinAggregateOutputType = {
    id: number | null
    flow: string | null
    amount: Decimal | null
    credit_type: string | null
    created_at: Date | null
    user_id: string | null
    comment: string | null
  }

  export type Credits_historyMaxAggregateOutputType = {
    id: number | null
    flow: string | null
    amount: Decimal | null
    credit_type: string | null
    created_at: Date | null
    user_id: string | null
    comment: string | null
  }

  export type Credits_historyCountAggregateOutputType = {
    id: number
    flow: number
    amount: number
    credit_type: number
    created_at: number
    user_id: number
    comment: number
    _all: number
  }


  export type Credits_historyAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type Credits_historySumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type Credits_historyMinAggregateInputType = {
    id?: true
    flow?: true
    amount?: true
    credit_type?: true
    created_at?: true
    user_id?: true
    comment?: true
  }

  export type Credits_historyMaxAggregateInputType = {
    id?: true
    flow?: true
    amount?: true
    credit_type?: true
    created_at?: true
    user_id?: true
    comment?: true
  }

  export type Credits_historyCountAggregateInputType = {
    id?: true
    flow?: true
    amount?: true
    credit_type?: true
    created_at?: true
    user_id?: true
    comment?: true
    _all?: true
  }

  export type Credits_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credits_history to aggregate.
     */
    where?: credits_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_histories to fetch.
     */
    orderBy?: credits_historyOrderByWithRelationInput | credits_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credits_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credits_histories
    **/
    _count?: true | Credits_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Credits_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Credits_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Credits_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Credits_historyMaxAggregateInputType
  }

  export type GetCredits_historyAggregateType<T extends Credits_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateCredits_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredits_history[P]>
      : GetScalarType<T[P], AggregateCredits_history[P]>
  }




  export type credits_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credits_historyWhereInput
    orderBy?: credits_historyOrderByWithAggregationInput | credits_historyOrderByWithAggregationInput[]
    by: Credits_historyScalarFieldEnum[] | Credits_historyScalarFieldEnum
    having?: credits_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Credits_historyCountAggregateInputType | true
    _avg?: Credits_historyAvgAggregateInputType
    _sum?: Credits_historySumAggregateInputType
    _min?: Credits_historyMinAggregateInputType
    _max?: Credits_historyMaxAggregateInputType
  }

  export type Credits_historyGroupByOutputType = {
    id: number
    flow: string
    amount: Decimal
    credit_type: string
    created_at: Date | null
    user_id: string
    comment: string | null
    _count: Credits_historyCountAggregateOutputType | null
    _avg: Credits_historyAvgAggregateOutputType | null
    _sum: Credits_historySumAggregateOutputType | null
    _min: Credits_historyMinAggregateOutputType | null
    _max: Credits_historyMaxAggregateOutputType | null
  }

  type GetCredits_historyGroupByPayload<T extends credits_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Credits_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Credits_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Credits_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Credits_historyGroupByOutputType[P]>
        }
      >
    >


  export type credits_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flow?: boolean
    amount?: boolean
    credit_type?: boolean
    created_at?: boolean
    user_id?: boolean
    comment?: boolean
  }, ExtArgs["result"]["credits_history"]>

  export type credits_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flow?: boolean
    amount?: boolean
    credit_type?: boolean
    created_at?: boolean
    user_id?: boolean
    comment?: boolean
  }, ExtArgs["result"]["credits_history"]>

  export type credits_historySelectScalar = {
    id?: boolean
    flow?: boolean
    amount?: boolean
    credit_type?: boolean
    created_at?: boolean
    user_id?: boolean
    comment?: boolean
  }


  export type $credits_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credits_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      flow: string
      amount: Prisma.Decimal
      credit_type: string
      created_at: Date | null
      user_id: string
      comment: string | null
    }, ExtArgs["result"]["credits_history"]>
    composites: {}
  }

  type credits_historyGetPayload<S extends boolean | null | undefined | credits_historyDefaultArgs> = $Result.GetResult<Prisma.$credits_historyPayload, S>

  type credits_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<credits_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Credits_historyCountAggregateInputType | true
    }

  export interface credits_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credits_history'], meta: { name: 'credits_history' } }
    /**
     * Find zero or one Credits_history that matches the filter.
     * @param {credits_historyFindUniqueArgs} args - Arguments to find a Credits_history
     * @example
     * // Get one Credits_history
     * const credits_history = await prisma.credits_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credits_historyFindUniqueArgs>(args: SelectSubset<T, credits_historyFindUniqueArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Credits_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {credits_historyFindUniqueOrThrowArgs} args - Arguments to find a Credits_history
     * @example
     * // Get one Credits_history
     * const credits_history = await prisma.credits_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credits_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, credits_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Credits_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_historyFindFirstArgs} args - Arguments to find a Credits_history
     * @example
     * // Get one Credits_history
     * const credits_history = await prisma.credits_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credits_historyFindFirstArgs>(args?: SelectSubset<T, credits_historyFindFirstArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Credits_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_historyFindFirstOrThrowArgs} args - Arguments to find a Credits_history
     * @example
     * // Get one Credits_history
     * const credits_history = await prisma.credits_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credits_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, credits_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Credits_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credits_histories
     * const credits_histories = await prisma.credits_history.findMany()
     * 
     * // Get first 10 Credits_histories
     * const credits_histories = await prisma.credits_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credits_historyWithIdOnly = await prisma.credits_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends credits_historyFindManyArgs>(args?: SelectSubset<T, credits_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Credits_history.
     * @param {credits_historyCreateArgs} args - Arguments to create a Credits_history.
     * @example
     * // Create one Credits_history
     * const Credits_history = await prisma.credits_history.create({
     *   data: {
     *     // ... data to create a Credits_history
     *   }
     * })
     * 
     */
    create<T extends credits_historyCreateArgs>(args: SelectSubset<T, credits_historyCreateArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Credits_histories.
     * @param {credits_historyCreateManyArgs} args - Arguments to create many Credits_histories.
     * @example
     * // Create many Credits_histories
     * const credits_history = await prisma.credits_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credits_historyCreateManyArgs>(args?: SelectSubset<T, credits_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credits_histories and returns the data saved in the database.
     * @param {credits_historyCreateManyAndReturnArgs} args - Arguments to create many Credits_histories.
     * @example
     * // Create many Credits_histories
     * const credits_history = await prisma.credits_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credits_histories and only return the `id`
     * const credits_historyWithIdOnly = await prisma.credits_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends credits_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, credits_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Credits_history.
     * @param {credits_historyDeleteArgs} args - Arguments to delete one Credits_history.
     * @example
     * // Delete one Credits_history
     * const Credits_history = await prisma.credits_history.delete({
     *   where: {
     *     // ... filter to delete one Credits_history
     *   }
     * })
     * 
     */
    delete<T extends credits_historyDeleteArgs>(args: SelectSubset<T, credits_historyDeleteArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Credits_history.
     * @param {credits_historyUpdateArgs} args - Arguments to update one Credits_history.
     * @example
     * // Update one Credits_history
     * const credits_history = await prisma.credits_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credits_historyUpdateArgs>(args: SelectSubset<T, credits_historyUpdateArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Credits_histories.
     * @param {credits_historyDeleteManyArgs} args - Arguments to filter Credits_histories to delete.
     * @example
     * // Delete a few Credits_histories
     * const { count } = await prisma.credits_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credits_historyDeleteManyArgs>(args?: SelectSubset<T, credits_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credits_histories
     * const credits_history = await prisma.credits_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credits_historyUpdateManyArgs>(args: SelectSubset<T, credits_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credits_history.
     * @param {credits_historyUpsertArgs} args - Arguments to update or create a Credits_history.
     * @example
     * // Update or create a Credits_history
     * const credits_history = await prisma.credits_history.upsert({
     *   create: {
     *     // ... data to create a Credits_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credits_history we want to update
     *   }
     * })
     */
    upsert<T extends credits_historyUpsertArgs>(args: SelectSubset<T, credits_historyUpsertArgs<ExtArgs>>): Prisma__credits_historyClient<$Result.GetResult<Prisma.$credits_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Credits_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_historyCountArgs} args - Arguments to filter Credits_histories to count.
     * @example
     * // Count the number of Credits_histories
     * const count = await prisma.credits_history.count({
     *   where: {
     *     // ... the filter for the Credits_histories we want to count
     *   }
     * })
    **/
    count<T extends credits_historyCountArgs>(
      args?: Subset<T, credits_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Credits_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credits_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Credits_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Credits_historyAggregateArgs>(args: Subset<T, Credits_historyAggregateArgs>): Prisma.PrismaPromise<GetCredits_historyAggregateType<T>>

    /**
     * Group by Credits_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credits_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credits_historyGroupByArgs['orderBy'] }
        : { orderBy?: credits_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credits_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredits_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credits_history model
   */
  readonly fields: credits_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credits_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credits_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credits_history model
   */ 
  interface credits_historyFieldRefs {
    readonly id: FieldRef<"credits_history", 'Int'>
    readonly flow: FieldRef<"credits_history", 'String'>
    readonly amount: FieldRef<"credits_history", 'Decimal'>
    readonly credit_type: FieldRef<"credits_history", 'String'>
    readonly created_at: FieldRef<"credits_history", 'DateTime'>
    readonly user_id: FieldRef<"credits_history", 'String'>
    readonly comment: FieldRef<"credits_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * credits_history findUnique
   */
  export type credits_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * Filter, which credits_history to fetch.
     */
    where: credits_historyWhereUniqueInput
  }

  /**
   * credits_history findUniqueOrThrow
   */
  export type credits_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * Filter, which credits_history to fetch.
     */
    where: credits_historyWhereUniqueInput
  }

  /**
   * credits_history findFirst
   */
  export type credits_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * Filter, which credits_history to fetch.
     */
    where?: credits_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_histories to fetch.
     */
    orderBy?: credits_historyOrderByWithRelationInput | credits_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credits_histories.
     */
    cursor?: credits_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credits_histories.
     */
    distinct?: Credits_historyScalarFieldEnum | Credits_historyScalarFieldEnum[]
  }

  /**
   * credits_history findFirstOrThrow
   */
  export type credits_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * Filter, which credits_history to fetch.
     */
    where?: credits_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_histories to fetch.
     */
    orderBy?: credits_historyOrderByWithRelationInput | credits_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credits_histories.
     */
    cursor?: credits_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credits_histories.
     */
    distinct?: Credits_historyScalarFieldEnum | Credits_historyScalarFieldEnum[]
  }

  /**
   * credits_history findMany
   */
  export type credits_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * Filter, which credits_histories to fetch.
     */
    where?: credits_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_histories to fetch.
     */
    orderBy?: credits_historyOrderByWithRelationInput | credits_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credits_histories.
     */
    cursor?: credits_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_histories.
     */
    skip?: number
    distinct?: Credits_historyScalarFieldEnum | Credits_historyScalarFieldEnum[]
  }

  /**
   * credits_history create
   */
  export type credits_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * The data needed to create a credits_history.
     */
    data: XOR<credits_historyCreateInput, credits_historyUncheckedCreateInput>
  }

  /**
   * credits_history createMany
   */
  export type credits_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credits_histories.
     */
    data: credits_historyCreateManyInput | credits_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credits_history createManyAndReturn
   */
  export type credits_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many credits_histories.
     */
    data: credits_historyCreateManyInput | credits_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credits_history update
   */
  export type credits_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * The data needed to update a credits_history.
     */
    data: XOR<credits_historyUpdateInput, credits_historyUncheckedUpdateInput>
    /**
     * Choose, which credits_history to update.
     */
    where: credits_historyWhereUniqueInput
  }

  /**
   * credits_history updateMany
   */
  export type credits_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credits_histories.
     */
    data: XOR<credits_historyUpdateManyMutationInput, credits_historyUncheckedUpdateManyInput>
    /**
     * Filter which credits_histories to update
     */
    where?: credits_historyWhereInput
  }

  /**
   * credits_history upsert
   */
  export type credits_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * The filter to search for the credits_history to update in case it exists.
     */
    where: credits_historyWhereUniqueInput
    /**
     * In case the credits_history found by the `where` argument doesn't exist, create a new credits_history with this data.
     */
    create: XOR<credits_historyCreateInput, credits_historyUncheckedCreateInput>
    /**
     * In case the credits_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credits_historyUpdateInput, credits_historyUncheckedUpdateInput>
  }

  /**
   * credits_history delete
   */
  export type credits_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
    /**
     * Filter which credits_history to delete.
     */
    where: credits_historyWhereUniqueInput
  }

  /**
   * credits_history deleteMany
   */
  export type credits_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credits_histories to delete
     */
    where?: credits_historyWhereInput
  }

  /**
   * credits_history without action
   */
  export type credits_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_history
     */
    select?: credits_historySelect<ExtArgs> | null
  }


  /**
   * Model credits_balance
   */

  export type AggregateCredits_balance = {
    _count: Credits_balanceCountAggregateOutputType | null
    _avg: Credits_balanceAvgAggregateOutputType | null
    _sum: Credits_balanceSumAggregateOutputType | null
    _min: Credits_balanceMinAggregateOutputType | null
    _max: Credits_balanceMaxAggregateOutputType | null
  }

  export type Credits_balanceAvgAggregateOutputType = {
    id: number | null
    balance: Decimal | null
  }

  export type Credits_balanceSumAggregateOutputType = {
    id: number | null
    balance: Decimal | null
  }

  export type Credits_balanceMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
    balance: Decimal | null
    credit_type: string | null
  }

  export type Credits_balanceMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
    balance: Decimal | null
    credit_type: string | null
  }

  export type Credits_balanceCountAggregateOutputType = {
    id: number
    user_id: number
    created_at: number
    updated_at: number
    balance: number
    credit_type: number
    _all: number
  }


  export type Credits_balanceAvgAggregateInputType = {
    id?: true
    balance?: true
  }

  export type Credits_balanceSumAggregateInputType = {
    id?: true
    balance?: true
  }

  export type Credits_balanceMinAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    balance?: true
    credit_type?: true
  }

  export type Credits_balanceMaxAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    balance?: true
    credit_type?: true
  }

  export type Credits_balanceCountAggregateInputType = {
    id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    balance?: true
    credit_type?: true
    _all?: true
  }

  export type Credits_balanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credits_balance to aggregate.
     */
    where?: credits_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_balances to fetch.
     */
    orderBy?: credits_balanceOrderByWithRelationInput | credits_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credits_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credits_balances
    **/
    _count?: true | Credits_balanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Credits_balanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Credits_balanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Credits_balanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Credits_balanceMaxAggregateInputType
  }

  export type GetCredits_balanceAggregateType<T extends Credits_balanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCredits_balance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredits_balance[P]>
      : GetScalarType<T[P], AggregateCredits_balance[P]>
  }




  export type credits_balanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credits_balanceWhereInput
    orderBy?: credits_balanceOrderByWithAggregationInput | credits_balanceOrderByWithAggregationInput[]
    by: Credits_balanceScalarFieldEnum[] | Credits_balanceScalarFieldEnum
    having?: credits_balanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Credits_balanceCountAggregateInputType | true
    _avg?: Credits_balanceAvgAggregateInputType
    _sum?: Credits_balanceSumAggregateInputType
    _min?: Credits_balanceMinAggregateInputType
    _max?: Credits_balanceMaxAggregateInputType
  }

  export type Credits_balanceGroupByOutputType = {
    id: number
    user_id: string
    created_at: Date | null
    updated_at: Date | null
    balance: Decimal
    credit_type: string
    _count: Credits_balanceCountAggregateOutputType | null
    _avg: Credits_balanceAvgAggregateOutputType | null
    _sum: Credits_balanceSumAggregateOutputType | null
    _min: Credits_balanceMinAggregateOutputType | null
    _max: Credits_balanceMaxAggregateOutputType | null
  }

  type GetCredits_balanceGroupByPayload<T extends credits_balanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Credits_balanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Credits_balanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Credits_balanceGroupByOutputType[P]>
            : GetScalarType<T[P], Credits_balanceGroupByOutputType[P]>
        }
      >
    >


  export type credits_balanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    credit_type?: boolean
  }, ExtArgs["result"]["credits_balance"]>

  export type credits_balanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    credit_type?: boolean
  }, ExtArgs["result"]["credits_balance"]>

  export type credits_balanceSelectScalar = {
    id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    credit_type?: boolean
  }


  export type $credits_balancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credits_balance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      created_at: Date | null
      updated_at: Date | null
      balance: Prisma.Decimal
      credit_type: string
    }, ExtArgs["result"]["credits_balance"]>
    composites: {}
  }

  type credits_balanceGetPayload<S extends boolean | null | undefined | credits_balanceDefaultArgs> = $Result.GetResult<Prisma.$credits_balancePayload, S>

  type credits_balanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<credits_balanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Credits_balanceCountAggregateInputType | true
    }

  export interface credits_balanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credits_balance'], meta: { name: 'credits_balance' } }
    /**
     * Find zero or one Credits_balance that matches the filter.
     * @param {credits_balanceFindUniqueArgs} args - Arguments to find a Credits_balance
     * @example
     * // Get one Credits_balance
     * const credits_balance = await prisma.credits_balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credits_balanceFindUniqueArgs>(args: SelectSubset<T, credits_balanceFindUniqueArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Credits_balance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {credits_balanceFindUniqueOrThrowArgs} args - Arguments to find a Credits_balance
     * @example
     * // Get one Credits_balance
     * const credits_balance = await prisma.credits_balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credits_balanceFindUniqueOrThrowArgs>(args: SelectSubset<T, credits_balanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Credits_balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_balanceFindFirstArgs} args - Arguments to find a Credits_balance
     * @example
     * // Get one Credits_balance
     * const credits_balance = await prisma.credits_balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credits_balanceFindFirstArgs>(args?: SelectSubset<T, credits_balanceFindFirstArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Credits_balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_balanceFindFirstOrThrowArgs} args - Arguments to find a Credits_balance
     * @example
     * // Get one Credits_balance
     * const credits_balance = await prisma.credits_balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credits_balanceFindFirstOrThrowArgs>(args?: SelectSubset<T, credits_balanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Credits_balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_balanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credits_balances
     * const credits_balances = await prisma.credits_balance.findMany()
     * 
     * // Get first 10 Credits_balances
     * const credits_balances = await prisma.credits_balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credits_balanceWithIdOnly = await prisma.credits_balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends credits_balanceFindManyArgs>(args?: SelectSubset<T, credits_balanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Credits_balance.
     * @param {credits_balanceCreateArgs} args - Arguments to create a Credits_balance.
     * @example
     * // Create one Credits_balance
     * const Credits_balance = await prisma.credits_balance.create({
     *   data: {
     *     // ... data to create a Credits_balance
     *   }
     * })
     * 
     */
    create<T extends credits_balanceCreateArgs>(args: SelectSubset<T, credits_balanceCreateArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Credits_balances.
     * @param {credits_balanceCreateManyArgs} args - Arguments to create many Credits_balances.
     * @example
     * // Create many Credits_balances
     * const credits_balance = await prisma.credits_balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credits_balanceCreateManyArgs>(args?: SelectSubset<T, credits_balanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credits_balances and returns the data saved in the database.
     * @param {credits_balanceCreateManyAndReturnArgs} args - Arguments to create many Credits_balances.
     * @example
     * // Create many Credits_balances
     * const credits_balance = await prisma.credits_balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credits_balances and only return the `id`
     * const credits_balanceWithIdOnly = await prisma.credits_balance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends credits_balanceCreateManyAndReturnArgs>(args?: SelectSubset<T, credits_balanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Credits_balance.
     * @param {credits_balanceDeleteArgs} args - Arguments to delete one Credits_balance.
     * @example
     * // Delete one Credits_balance
     * const Credits_balance = await prisma.credits_balance.delete({
     *   where: {
     *     // ... filter to delete one Credits_balance
     *   }
     * })
     * 
     */
    delete<T extends credits_balanceDeleteArgs>(args: SelectSubset<T, credits_balanceDeleteArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Credits_balance.
     * @param {credits_balanceUpdateArgs} args - Arguments to update one Credits_balance.
     * @example
     * // Update one Credits_balance
     * const credits_balance = await prisma.credits_balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credits_balanceUpdateArgs>(args: SelectSubset<T, credits_balanceUpdateArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Credits_balances.
     * @param {credits_balanceDeleteManyArgs} args - Arguments to filter Credits_balances to delete.
     * @example
     * // Delete a few Credits_balances
     * const { count } = await prisma.credits_balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credits_balanceDeleteManyArgs>(args?: SelectSubset<T, credits_balanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits_balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_balanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credits_balances
     * const credits_balance = await prisma.credits_balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credits_balanceUpdateManyArgs>(args: SelectSubset<T, credits_balanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credits_balance.
     * @param {credits_balanceUpsertArgs} args - Arguments to update or create a Credits_balance.
     * @example
     * // Update or create a Credits_balance
     * const credits_balance = await prisma.credits_balance.upsert({
     *   create: {
     *     // ... data to create a Credits_balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credits_balance we want to update
     *   }
     * })
     */
    upsert<T extends credits_balanceUpsertArgs>(args: SelectSubset<T, credits_balanceUpsertArgs<ExtArgs>>): Prisma__credits_balanceClient<$Result.GetResult<Prisma.$credits_balancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Credits_balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_balanceCountArgs} args - Arguments to filter Credits_balances to count.
     * @example
     * // Count the number of Credits_balances
     * const count = await prisma.credits_balance.count({
     *   where: {
     *     // ... the filter for the Credits_balances we want to count
     *   }
     * })
    **/
    count<T extends credits_balanceCountArgs>(
      args?: Subset<T, credits_balanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Credits_balanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credits_balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Credits_balanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Credits_balanceAggregateArgs>(args: Subset<T, Credits_balanceAggregateArgs>): Prisma.PrismaPromise<GetCredits_balanceAggregateType<T>>

    /**
     * Group by Credits_balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credits_balanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credits_balanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credits_balanceGroupByArgs['orderBy'] }
        : { orderBy?: credits_balanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credits_balanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredits_balanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credits_balance model
   */
  readonly fields: credits_balanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credits_balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credits_balanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credits_balance model
   */ 
  interface credits_balanceFieldRefs {
    readonly id: FieldRef<"credits_balance", 'Int'>
    readonly user_id: FieldRef<"credits_balance", 'String'>
    readonly created_at: FieldRef<"credits_balance", 'DateTime'>
    readonly updated_at: FieldRef<"credits_balance", 'DateTime'>
    readonly balance: FieldRef<"credits_balance", 'Decimal'>
    readonly credit_type: FieldRef<"credits_balance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * credits_balance findUnique
   */
  export type credits_balanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * Filter, which credits_balance to fetch.
     */
    where: credits_balanceWhereUniqueInput
  }

  /**
   * credits_balance findUniqueOrThrow
   */
  export type credits_balanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * Filter, which credits_balance to fetch.
     */
    where: credits_balanceWhereUniqueInput
  }

  /**
   * credits_balance findFirst
   */
  export type credits_balanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * Filter, which credits_balance to fetch.
     */
    where?: credits_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_balances to fetch.
     */
    orderBy?: credits_balanceOrderByWithRelationInput | credits_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credits_balances.
     */
    cursor?: credits_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credits_balances.
     */
    distinct?: Credits_balanceScalarFieldEnum | Credits_balanceScalarFieldEnum[]
  }

  /**
   * credits_balance findFirstOrThrow
   */
  export type credits_balanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * Filter, which credits_balance to fetch.
     */
    where?: credits_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_balances to fetch.
     */
    orderBy?: credits_balanceOrderByWithRelationInput | credits_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credits_balances.
     */
    cursor?: credits_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credits_balances.
     */
    distinct?: Credits_balanceScalarFieldEnum | Credits_balanceScalarFieldEnum[]
  }

  /**
   * credits_balance findMany
   */
  export type credits_balanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * Filter, which credits_balances to fetch.
     */
    where?: credits_balanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits_balances to fetch.
     */
    orderBy?: credits_balanceOrderByWithRelationInput | credits_balanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credits_balances.
     */
    cursor?: credits_balanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits_balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits_balances.
     */
    skip?: number
    distinct?: Credits_balanceScalarFieldEnum | Credits_balanceScalarFieldEnum[]
  }

  /**
   * credits_balance create
   */
  export type credits_balanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * The data needed to create a credits_balance.
     */
    data: XOR<credits_balanceCreateInput, credits_balanceUncheckedCreateInput>
  }

  /**
   * credits_balance createMany
   */
  export type credits_balanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credits_balances.
     */
    data: credits_balanceCreateManyInput | credits_balanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credits_balance createManyAndReturn
   */
  export type credits_balanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many credits_balances.
     */
    data: credits_balanceCreateManyInput | credits_balanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credits_balance update
   */
  export type credits_balanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * The data needed to update a credits_balance.
     */
    data: XOR<credits_balanceUpdateInput, credits_balanceUncheckedUpdateInput>
    /**
     * Choose, which credits_balance to update.
     */
    where: credits_balanceWhereUniqueInput
  }

  /**
   * credits_balance updateMany
   */
  export type credits_balanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credits_balances.
     */
    data: XOR<credits_balanceUpdateManyMutationInput, credits_balanceUncheckedUpdateManyInput>
    /**
     * Filter which credits_balances to update
     */
    where?: credits_balanceWhereInput
  }

  /**
   * credits_balance upsert
   */
  export type credits_balanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * The filter to search for the credits_balance to update in case it exists.
     */
    where: credits_balanceWhereUniqueInput
    /**
     * In case the credits_balance found by the `where` argument doesn't exist, create a new credits_balance with this data.
     */
    create: XOR<credits_balanceCreateInput, credits_balanceUncheckedCreateInput>
    /**
     * In case the credits_balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credits_balanceUpdateInput, credits_balanceUncheckedUpdateInput>
  }

  /**
   * credits_balance delete
   */
  export type credits_balanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
    /**
     * Filter which credits_balance to delete.
     */
    where: credits_balanceWhereUniqueInput
  }

  /**
   * credits_balance deleteMany
   */
  export type credits_balanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credits_balances to delete
     */
    where?: credits_balanceWhereInput
  }

  /**
   * credits_balance without action
   */
  export type credits_balanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits_balance
     */
    select?: credits_balanceSelect<ExtArgs> | null
  }


  /**
   * Model subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    stripe_subscription_id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    status: string | null
    stripe_product_id: string | null
    subscription_key: string | null
    cancel_at_period_end: boolean | null
    current_period_end: Date | null
    current_period_start: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    stripe_subscription_id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    status: string | null
    stripe_product_id: string | null
    subscription_key: string | null
    cancel_at_period_end: boolean | null
    current_period_end: Date | null
    current_period_start: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    stripe_subscription_id: number
    created_at: number
    updated_at: number
    user_id: number
    status: number
    stripe_product_id: number
    subscription_key: number
    cancel_at_period_end: number
    current_period_end: number
    current_period_start: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    stripe_subscription_id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    status?: true
    stripe_product_id?: true
    subscription_key?: true
    cancel_at_period_end?: true
    current_period_end?: true
    current_period_start?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    stripe_subscription_id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    status?: true
    stripe_product_id?: true
    subscription_key?: true
    cancel_at_period_end?: true
    current_period_end?: true
    current_period_start?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    stripe_subscription_id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    status?: true
    stripe_product_id?: true
    subscription_key?: true
    cancel_at_period_end?: true
    current_period_end?: true
    current_period_start?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription to aggregate.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type subscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithAggregationInput | subscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    stripe_subscription_id: string
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    status: string
    stripe_product_id: string
    subscription_key: string
    cancel_at_period_end: boolean
    current_period_end: Date
    current_period_start: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends subscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripe_subscription_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    status?: boolean
    stripe_product_id?: boolean
    subscription_key?: boolean
    cancel_at_period_end?: boolean
    current_period_end?: boolean
    current_period_start?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type subscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripe_subscription_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    status?: boolean
    stripe_product_id?: boolean
    subscription_key?: boolean
    cancel_at_period_end?: boolean
    current_period_end?: boolean
    current_period_start?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type subscriptionSelectScalar = {
    id?: boolean
    stripe_subscription_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    status?: boolean
    stripe_product_id?: boolean
    subscription_key?: boolean
    cancel_at_period_end?: boolean
    current_period_end?: boolean
    current_period_start?: boolean
  }


  export type $subscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripe_subscription_id: string
      created_at: Date | null
      updated_at: Date | null
      user_id: string | null
      status: string
      stripe_product_id: string
      subscription_key: string
      cancel_at_period_end: boolean
      current_period_end: Date
      current_period_start: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type subscriptionGetPayload<S extends boolean | null | undefined | subscriptionDefaultArgs> = $Result.GetResult<Prisma.$subscriptionPayload, S>

  type subscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<subscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface subscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscription'], meta: { name: 'subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {subscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionFindUniqueArgs>(args: SelectSubset<T, subscriptionFindUniqueArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionFindFirstArgs>(args?: SelectSubset<T, subscriptionFindFirstArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionFindManyArgs>(args?: SelectSubset<T, subscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {subscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends subscriptionCreateArgs>(args: SelectSubset<T, subscriptionCreateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {subscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionCreateManyArgs>(args?: SelectSubset<T, subscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, subscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {subscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends subscriptionDeleteArgs>(args: SelectSubset<T, subscriptionDeleteArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {subscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionUpdateArgs>(args: SelectSubset<T, subscriptionUpdateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionDeleteManyArgs>(args?: SelectSubset<T, subscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionUpdateManyArgs>(args: SelectSubset<T, subscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {subscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionUpsertArgs>(args: SelectSubset<T, subscriptionUpsertArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionCountArgs>(
      args?: Subset<T, subscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscription model
   */
  readonly fields: subscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscription model
   */ 
  interface subscriptionFieldRefs {
    readonly id: FieldRef<"subscription", 'String'>
    readonly stripe_subscription_id: FieldRef<"subscription", 'String'>
    readonly created_at: FieldRef<"subscription", 'DateTime'>
    readonly updated_at: FieldRef<"subscription", 'DateTime'>
    readonly user_id: FieldRef<"subscription", 'String'>
    readonly status: FieldRef<"subscription", 'String'>
    readonly stripe_product_id: FieldRef<"subscription", 'String'>
    readonly subscription_key: FieldRef<"subscription", 'String'>
    readonly cancel_at_period_end: FieldRef<"subscription", 'Boolean'>
    readonly current_period_end: FieldRef<"subscription", 'DateTime'>
    readonly current_period_start: FieldRef<"subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscription findUnique
   */
  export type subscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findUniqueOrThrow
   */
  export type subscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findFirst
   */
  export type subscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findFirstOrThrow
   */
  export type subscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findMany
   */
  export type subscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription create
   */
  export type subscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * The data needed to create a subscription.
     */
    data: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
  }

  /**
   * subscription createMany
   */
  export type subscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscription createManyAndReturn
   */
  export type subscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscription update
   */
  export type subscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * The data needed to update a subscription.
     */
    data: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
    /**
     * Choose, which subscription to update.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription updateMany
   */
  export type subscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionWhereInput
  }

  /**
   * subscription upsert
   */
  export type subscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * The filter to search for the subscription to update in case it exists.
     */
    where: subscriptionWhereUniqueInput
    /**
     * In case the subscription found by the `where` argument doesn't exist, create a new subscription with this data.
     */
    create: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
    /**
     * In case the subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
  }

  /**
   * subscription delete
   */
  export type subscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Filter which subscription to delete.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription deleteMany
   */
  export type subscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionWhereInput
  }

  /**
   * subscription without action
   */
  export type subscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    stripe_customer_id: string | null
    created_at: Date | null
    updated_at: Date | null
    prefinery_referral_code: string | null
    has_migrated: boolean | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    stripe_customer_id: string | null
    created_at: Date | null
    updated_at: Date | null
    prefinery_referral_code: string | null
    has_migrated: boolean | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    stripe_customer_id: number
    created_at: number
    updated_at: number
    prefinery_referral_code: number
    has_migrated: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    stripe_customer_id?: true
    created_at?: true
    updated_at?: true
    prefinery_referral_code?: true
    has_migrated?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    stripe_customer_id?: true
    created_at?: true
    updated_at?: true
    prefinery_referral_code?: true
    has_migrated?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    stripe_customer_id?: true
    created_at?: true
    updated_at?: true
    prefinery_referral_code?: true
    has_migrated?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    stripe_customer_id: string | null
    created_at: Date | null
    updated_at: Date | null
    prefinery_referral_code: string | null
    has_migrated: boolean
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripe_customer_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    prefinery_referral_code?: boolean
    has_migrated?: boolean
  }, ExtArgs["result"]["customer"]>

  export type customerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripe_customer_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    prefinery_referral_code?: boolean
    has_migrated?: boolean
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    id?: boolean
    stripe_customer_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    prefinery_referral_code?: boolean
    has_migrated?: boolean
  }


  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripe_customer_id: string | null
      created_at: Date | null
      updated_at: Date | null
      prefinery_referral_code: string | null
      has_migrated: boolean
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customerCreateManyAndReturnArgs>(args?: SelectSubset<T, customerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */ 
  interface customerFieldRefs {
    readonly id: FieldRef<"customer", 'String'>
    readonly stripe_customer_id: FieldRef<"customer", 'String'>
    readonly created_at: FieldRef<"customer", 'DateTime'>
    readonly updated_at: FieldRef<"customer", 'DateTime'>
    readonly prefinery_referral_code: FieldRef<"customer", 'String'>
    readonly has_migrated: FieldRef<"customer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer createManyAndReturn
   */
  export type customerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
  }


  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    credits_quantity: number | null
    rank: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    credits_quantity: number | null
    rank: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    stripe_price_id: string | null
    stripe_product_id: string | null
    price: Decimal | null
    credits_quantity: number | null
    credits_type: string | null
    active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    lookup_key: string | null
    rank: number | null
    features: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    stripe_price_id: string | null
    stripe_product_id: string | null
    price: Decimal | null
    credits_quantity: number | null
    credits_type: string | null
    active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    lookup_key: string | null
    rank: number | null
    features: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    type: number
    stripe_price_id: number
    stripe_product_id: number
    price: number
    credits_quantity: number
    credits_type: number
    active: number
    created_at: number
    updated_at: number
    lookup_key: number
    rank: number
    features: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    credits_quantity?: true
    rank?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    credits_quantity?: true
    rank?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    stripe_price_id?: true
    stripe_product_id?: true
    price?: true
    credits_quantity?: true
    credits_type?: true
    active?: true
    created_at?: true
    updated_at?: true
    lookup_key?: true
    rank?: true
    features?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    stripe_price_id?: true
    stripe_product_id?: true
    price?: true
    credits_quantity?: true
    credits_type?: true
    active?: true
    created_at?: true
    updated_at?: true
    lookup_key?: true
    rank?: true
    features?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    stripe_price_id?: true
    stripe_product_id?: true
    price?: true
    credits_quantity?: true
    credits_type?: true
    active?: true
    created_at?: true
    updated_at?: true
    lookup_key?: true
    rank?: true
    features?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    type: string
    stripe_price_id: string
    stripe_product_id: string
    price: Decimal
    credits_quantity: number | null
    credits_type: string | null
    active: boolean
    created_at: Date | null
    updated_at: Date
    lookup_key: string
    rank: number
    features: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    stripe_price_id?: boolean
    stripe_product_id?: boolean
    price?: boolean
    credits_quantity?: boolean
    credits_type?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    lookup_key?: boolean
    rank?: boolean
    features?: boolean
  }, ExtArgs["result"]["product"]>

  export type productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    stripe_price_id?: boolean
    stripe_product_id?: boolean
    price?: boolean
    credits_quantity?: boolean
    credits_type?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    lookup_key?: boolean
    rank?: boolean
    features?: boolean
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    stripe_price_id?: boolean
    stripe_product_id?: boolean
    price?: boolean
    credits_quantity?: boolean
    credits_type?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    lookup_key?: boolean
    rank?: boolean
    features?: boolean
  }


  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      stripe_price_id: string
      stripe_product_id: string
      price: Prisma.Decimal
      credits_quantity: number | null
      credits_type: string | null
      active: boolean
      created_at: Date | null
      updated_at: Date
      lookup_key: string
      rank: number
      features: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productFindUniqueArgs>(args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs>(args: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productFindFirstArgs>(args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productFindFirstOrThrowArgs>(args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productFindManyArgs>(args?: SelectSubset<T, productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends productCreateArgs>(args: SelectSubset<T, productCreateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {productCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productCreateManyArgs>(args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productCreateManyAndReturnArgs>(args?: SelectSubset<T, productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends productDeleteArgs>(args: SelectSubset<T, productDeleteArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productUpdateArgs>(args: SelectSubset<T, productUpdateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productDeleteManyArgs>(args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productUpdateManyArgs>(args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends productUpsertArgs>(args: SelectSubset<T, productUpsertArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product model
   */ 
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'Int'>
    readonly name: FieldRef<"product", 'String'>
    readonly type: FieldRef<"product", 'String'>
    readonly stripe_price_id: FieldRef<"product", 'String'>
    readonly stripe_product_id: FieldRef<"product", 'String'>
    readonly price: FieldRef<"product", 'Decimal'>
    readonly credits_quantity: FieldRef<"product", 'Int'>
    readonly credits_type: FieldRef<"product", 'String'>
    readonly active: FieldRef<"product", 'Boolean'>
    readonly created_at: FieldRef<"product", 'DateTime'>
    readonly updated_at: FieldRef<"product", 'DateTime'>
    readonly lookup_key: FieldRef<"product", 'String'>
    readonly rank: FieldRef<"product", 'Int'>
    readonly features: FieldRef<"product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }

  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product createManyAndReturn
   */
  export type productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }

  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }

  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }

  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }

  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }

  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
  }


  /**
   * Model project_template
   */

  export type AggregateProject_template = {
    _count: Project_templateCountAggregateOutputType | null
    _avg: Project_templateAvgAggregateOutputType | null
    _sum: Project_templateSumAggregateOutputType | null
    _min: Project_templateMinAggregateOutputType | null
    _max: Project_templateMaxAggregateOutputType | null
  }

  export type Project_templateAvgAggregateOutputType = {
    id: number | null
  }

  export type Project_templateSumAggregateOutputType = {
    id: bigint | null
  }

  export type Project_templateMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    current_project_history_id: string | null
  }

  export type Project_templateMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    current_project_history_id: string | null
  }

  export type Project_templateCountAggregateOutputType = {
    id: number
    name: number
    data: number
    created_at: number
    updated_at: number
    current_project_history_id: number
    _all: number
  }


  export type Project_templateAvgAggregateInputType = {
    id?: true
  }

  export type Project_templateSumAggregateInputType = {
    id?: true
  }

  export type Project_templateMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    current_project_history_id?: true
  }

  export type Project_templateMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    current_project_history_id?: true
  }

  export type Project_templateCountAggregateInputType = {
    id?: true
    name?: true
    data?: true
    created_at?: true
    updated_at?: true
    current_project_history_id?: true
    _all?: true
  }

  export type Project_templateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_template to aggregate.
     */
    where?: project_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_templates to fetch.
     */
    orderBy?: project_templateOrderByWithRelationInput | project_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: project_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_templates
    **/
    _count?: true | Project_templateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Project_templateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Project_templateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Project_templateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Project_templateMaxAggregateInputType
  }

  export type GetProject_templateAggregateType<T extends Project_templateAggregateArgs> = {
        [P in keyof T & keyof AggregateProject_template]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_template[P]>
      : GetScalarType<T[P], AggregateProject_template[P]>
  }




  export type project_templateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_templateWhereInput
    orderBy?: project_templateOrderByWithAggregationInput | project_templateOrderByWithAggregationInput[]
    by: Project_templateScalarFieldEnum[] | Project_templateScalarFieldEnum
    having?: project_templateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Project_templateCountAggregateInputType | true
    _avg?: Project_templateAvgAggregateInputType
    _sum?: Project_templateSumAggregateInputType
    _min?: Project_templateMinAggregateInputType
    _max?: Project_templateMaxAggregateInputType
  }

  export type Project_templateGroupByOutputType = {
    id: bigint
    name: string
    data: JsonValue
    created_at: Date
    updated_at: Date | null
    current_project_history_id: string | null
    _count: Project_templateCountAggregateOutputType | null
    _avg: Project_templateAvgAggregateOutputType | null
    _sum: Project_templateSumAggregateOutputType | null
    _min: Project_templateMinAggregateOutputType | null
    _max: Project_templateMaxAggregateOutputType | null
  }

  type GetProject_templateGroupByPayload<T extends project_templateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Project_templateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Project_templateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Project_templateGroupByOutputType[P]>
            : GetScalarType<T[P], Project_templateGroupByOutputType[P]>
        }
      >
    >


  export type project_templateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    current_project_history_id?: boolean
    project_template_save?: boolean | project_template$project_template_saveArgs<ExtArgs>
    _count?: boolean | Project_templateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_template"]>

  export type project_templateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    current_project_history_id?: boolean
  }, ExtArgs["result"]["project_template"]>

  export type project_templateSelectScalar = {
    id?: boolean
    name?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    current_project_history_id?: boolean
  }

  export type project_templateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_template_save?: boolean | project_template$project_template_saveArgs<ExtArgs>
    _count?: boolean | Project_templateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type project_templateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $project_templatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project_template"
    objects: {
      project_template_save: Prisma.$project_template_savePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      data: Prisma.JsonValue
      created_at: Date
      updated_at: Date | null
      current_project_history_id: string | null
    }, ExtArgs["result"]["project_template"]>
    composites: {}
  }

  type project_templateGetPayload<S extends boolean | null | undefined | project_templateDefaultArgs> = $Result.GetResult<Prisma.$project_templatePayload, S>

  type project_templateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<project_templateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Project_templateCountAggregateInputType | true
    }

  export interface project_templateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project_template'], meta: { name: 'project_template' } }
    /**
     * Find zero or one Project_template that matches the filter.
     * @param {project_templateFindUniqueArgs} args - Arguments to find a Project_template
     * @example
     * // Get one Project_template
     * const project_template = await prisma.project_template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends project_templateFindUniqueArgs>(args: SelectSubset<T, project_templateFindUniqueArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project_template that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {project_templateFindUniqueOrThrowArgs} args - Arguments to find a Project_template
     * @example
     * // Get one Project_template
     * const project_template = await prisma.project_template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends project_templateFindUniqueOrThrowArgs>(args: SelectSubset<T, project_templateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project_template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_templateFindFirstArgs} args - Arguments to find a Project_template
     * @example
     * // Get one Project_template
     * const project_template = await prisma.project_template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends project_templateFindFirstArgs>(args?: SelectSubset<T, project_templateFindFirstArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project_template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_templateFindFirstOrThrowArgs} args - Arguments to find a Project_template
     * @example
     * // Get one Project_template
     * const project_template = await prisma.project_template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends project_templateFindFirstOrThrowArgs>(args?: SelectSubset<T, project_templateFindFirstOrThrowArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Project_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_templateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_templates
     * const project_templates = await prisma.project_template.findMany()
     * 
     * // Get first 10 Project_templates
     * const project_templates = await prisma.project_template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_templateWithIdOnly = await prisma.project_template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends project_templateFindManyArgs>(args?: SelectSubset<T, project_templateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project_template.
     * @param {project_templateCreateArgs} args - Arguments to create a Project_template.
     * @example
     * // Create one Project_template
     * const Project_template = await prisma.project_template.create({
     *   data: {
     *     // ... data to create a Project_template
     *   }
     * })
     * 
     */
    create<T extends project_templateCreateArgs>(args: SelectSubset<T, project_templateCreateArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Project_templates.
     * @param {project_templateCreateManyArgs} args - Arguments to create many Project_templates.
     * @example
     * // Create many Project_templates
     * const project_template = await prisma.project_template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends project_templateCreateManyArgs>(args?: SelectSubset<T, project_templateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Project_templates and returns the data saved in the database.
     * @param {project_templateCreateManyAndReturnArgs} args - Arguments to create many Project_templates.
     * @example
     * // Create many Project_templates
     * const project_template = await prisma.project_template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Project_templates and only return the `id`
     * const project_templateWithIdOnly = await prisma.project_template.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends project_templateCreateManyAndReturnArgs>(args?: SelectSubset<T, project_templateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project_template.
     * @param {project_templateDeleteArgs} args - Arguments to delete one Project_template.
     * @example
     * // Delete one Project_template
     * const Project_template = await prisma.project_template.delete({
     *   where: {
     *     // ... filter to delete one Project_template
     *   }
     * })
     * 
     */
    delete<T extends project_templateDeleteArgs>(args: SelectSubset<T, project_templateDeleteArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project_template.
     * @param {project_templateUpdateArgs} args - Arguments to update one Project_template.
     * @example
     * // Update one Project_template
     * const project_template = await prisma.project_template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends project_templateUpdateArgs>(args: SelectSubset<T, project_templateUpdateArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Project_templates.
     * @param {project_templateDeleteManyArgs} args - Arguments to filter Project_templates to delete.
     * @example
     * // Delete a few Project_templates
     * const { count } = await prisma.project_template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends project_templateDeleteManyArgs>(args?: SelectSubset<T, project_templateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_templateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_templates
     * const project_template = await prisma.project_template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends project_templateUpdateManyArgs>(args: SelectSubset<T, project_templateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project_template.
     * @param {project_templateUpsertArgs} args - Arguments to update or create a Project_template.
     * @example
     * // Update or create a Project_template
     * const project_template = await prisma.project_template.upsert({
     *   create: {
     *     // ... data to create a Project_template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_template we want to update
     *   }
     * })
     */
    upsert<T extends project_templateUpsertArgs>(args: SelectSubset<T, project_templateUpsertArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Project_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_templateCountArgs} args - Arguments to filter Project_templates to count.
     * @example
     * // Count the number of Project_templates
     * const count = await prisma.project_template.count({
     *   where: {
     *     // ... the filter for the Project_templates we want to count
     *   }
     * })
    **/
    count<T extends project_templateCountArgs>(
      args?: Subset<T, project_templateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_templateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Project_templateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_templateAggregateArgs>(args: Subset<T, Project_templateAggregateArgs>): Prisma.PrismaPromise<GetProject_templateAggregateType<T>>

    /**
     * Group by Project_template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_templateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends project_templateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: project_templateGroupByArgs['orderBy'] }
        : { orderBy?: project_templateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, project_templateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProject_templateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project_template model
   */
  readonly fields: project_templateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project_template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__project_templateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project_template_save<T extends project_template$project_template_saveArgs<ExtArgs> = {}>(args?: Subset<T, project_template$project_template_saveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project_template model
   */ 
  interface project_templateFieldRefs {
    readonly id: FieldRef<"project_template", 'BigInt'>
    readonly name: FieldRef<"project_template", 'String'>
    readonly data: FieldRef<"project_template", 'Json'>
    readonly created_at: FieldRef<"project_template", 'DateTime'>
    readonly updated_at: FieldRef<"project_template", 'DateTime'>
    readonly current_project_history_id: FieldRef<"project_template", 'String'>
  }
    

  // Custom InputTypes
  /**
   * project_template findUnique
   */
  export type project_templateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * Filter, which project_template to fetch.
     */
    where: project_templateWhereUniqueInput
  }

  /**
   * project_template findUniqueOrThrow
   */
  export type project_templateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * Filter, which project_template to fetch.
     */
    where: project_templateWhereUniqueInput
  }

  /**
   * project_template findFirst
   */
  export type project_templateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * Filter, which project_template to fetch.
     */
    where?: project_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_templates to fetch.
     */
    orderBy?: project_templateOrderByWithRelationInput | project_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_templates.
     */
    cursor?: project_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_templates.
     */
    distinct?: Project_templateScalarFieldEnum | Project_templateScalarFieldEnum[]
  }

  /**
   * project_template findFirstOrThrow
   */
  export type project_templateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * Filter, which project_template to fetch.
     */
    where?: project_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_templates to fetch.
     */
    orderBy?: project_templateOrderByWithRelationInput | project_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_templates.
     */
    cursor?: project_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_templates.
     */
    distinct?: Project_templateScalarFieldEnum | Project_templateScalarFieldEnum[]
  }

  /**
   * project_template findMany
   */
  export type project_templateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * Filter, which project_templates to fetch.
     */
    where?: project_templateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_templates to fetch.
     */
    orderBy?: project_templateOrderByWithRelationInput | project_templateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_templates.
     */
    cursor?: project_templateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_templates.
     */
    skip?: number
    distinct?: Project_templateScalarFieldEnum | Project_templateScalarFieldEnum[]
  }

  /**
   * project_template create
   */
  export type project_templateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * The data needed to create a project_template.
     */
    data: XOR<project_templateCreateInput, project_templateUncheckedCreateInput>
  }

  /**
   * project_template createMany
   */
  export type project_templateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many project_templates.
     */
    data: project_templateCreateManyInput | project_templateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_template createManyAndReturn
   */
  export type project_templateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many project_templates.
     */
    data: project_templateCreateManyInput | project_templateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_template update
   */
  export type project_templateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * The data needed to update a project_template.
     */
    data: XOR<project_templateUpdateInput, project_templateUncheckedUpdateInput>
    /**
     * Choose, which project_template to update.
     */
    where: project_templateWhereUniqueInput
  }

  /**
   * project_template updateMany
   */
  export type project_templateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update project_templates.
     */
    data: XOR<project_templateUpdateManyMutationInput, project_templateUncheckedUpdateManyInput>
    /**
     * Filter which project_templates to update
     */
    where?: project_templateWhereInput
  }

  /**
   * project_template upsert
   */
  export type project_templateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * The filter to search for the project_template to update in case it exists.
     */
    where: project_templateWhereUniqueInput
    /**
     * In case the project_template found by the `where` argument doesn't exist, create a new project_template with this data.
     */
    create: XOR<project_templateCreateInput, project_templateUncheckedCreateInput>
    /**
     * In case the project_template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<project_templateUpdateInput, project_templateUncheckedUpdateInput>
  }

  /**
   * project_template delete
   */
  export type project_templateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
    /**
     * Filter which project_template to delete.
     */
    where: project_templateWhereUniqueInput
  }

  /**
   * project_template deleteMany
   */
  export type project_templateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_templates to delete
     */
    where?: project_templateWhereInput
  }

  /**
   * project_template.project_template_save
   */
  export type project_template$project_template_saveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    where?: project_template_saveWhereInput
    orderBy?: project_template_saveOrderByWithRelationInput | project_template_saveOrderByWithRelationInput[]
    cursor?: project_template_saveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_template_saveScalarFieldEnum | Project_template_saveScalarFieldEnum[]
  }

  /**
   * project_template without action
   */
  export type project_templateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template
     */
    select?: project_templateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_templateInclude<ExtArgs> | null
  }


  /**
   * Model project_template_save
   */

  export type AggregateProject_template_save = {
    _count: Project_template_saveCountAggregateOutputType | null
    _avg: Project_template_saveAvgAggregateOutputType | null
    _sum: Project_template_saveSumAggregateOutputType | null
    _min: Project_template_saveMinAggregateOutputType | null
    _max: Project_template_saveMaxAggregateOutputType | null
  }

  export type Project_template_saveAvgAggregateOutputType = {
    id: number | null
    project_template_id: number | null
  }

  export type Project_template_saveSumAggregateOutputType = {
    id: bigint | null
    project_template_id: bigint | null
  }

  export type Project_template_saveMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    project_template_id: bigint | null
    project_history_id: string | null
  }

  export type Project_template_saveMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    project_template_id: bigint | null
    project_history_id: string | null
  }

  export type Project_template_saveCountAggregateOutputType = {
    id: number
    name: number
    data: number
    images: number
    created_at: number
    updated_at: number
    project_template_id: number
    project_history_id: number
    _all: number
  }


  export type Project_template_saveAvgAggregateInputType = {
    id?: true
    project_template_id?: true
  }

  export type Project_template_saveSumAggregateInputType = {
    id?: true
    project_template_id?: true
  }

  export type Project_template_saveMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    project_template_id?: true
    project_history_id?: true
  }

  export type Project_template_saveMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    project_template_id?: true
    project_history_id?: true
  }

  export type Project_template_saveCountAggregateInputType = {
    id?: true
    name?: true
    data?: true
    images?: true
    created_at?: true
    updated_at?: true
    project_template_id?: true
    project_history_id?: true
    _all?: true
  }

  export type Project_template_saveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_template_save to aggregate.
     */
    where?: project_template_saveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_template_saves to fetch.
     */
    orderBy?: project_template_saveOrderByWithRelationInput | project_template_saveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: project_template_saveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_template_saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_template_saves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_template_saves
    **/
    _count?: true | Project_template_saveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Project_template_saveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Project_template_saveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Project_template_saveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Project_template_saveMaxAggregateInputType
  }

  export type GetProject_template_saveAggregateType<T extends Project_template_saveAggregateArgs> = {
        [P in keyof T & keyof AggregateProject_template_save]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_template_save[P]>
      : GetScalarType<T[P], AggregateProject_template_save[P]>
  }




  export type project_template_saveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_template_saveWhereInput
    orderBy?: project_template_saveOrderByWithAggregationInput | project_template_saveOrderByWithAggregationInput[]
    by: Project_template_saveScalarFieldEnum[] | Project_template_saveScalarFieldEnum
    having?: project_template_saveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Project_template_saveCountAggregateInputType | true
    _avg?: Project_template_saveAvgAggregateInputType
    _sum?: Project_template_saveSumAggregateInputType
    _min?: Project_template_saveMinAggregateInputType
    _max?: Project_template_saveMaxAggregateInputType
  }

  export type Project_template_saveGroupByOutputType = {
    id: bigint
    name: string
    data: JsonValue
    images: JsonValue | null
    created_at: Date
    updated_at: Date | null
    project_template_id: bigint
    project_history_id: string | null
    _count: Project_template_saveCountAggregateOutputType | null
    _avg: Project_template_saveAvgAggregateOutputType | null
    _sum: Project_template_saveSumAggregateOutputType | null
    _min: Project_template_saveMinAggregateOutputType | null
    _max: Project_template_saveMaxAggregateOutputType | null
  }

  type GetProject_template_saveGroupByPayload<T extends project_template_saveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Project_template_saveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Project_template_saveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Project_template_saveGroupByOutputType[P]>
            : GetScalarType<T[P], Project_template_saveGroupByOutputType[P]>
        }
      >
    >


  export type project_template_saveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
    project_template_id?: boolean
    project_history_id?: boolean
    project_template?: boolean | project_templateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_template_save"]>

  export type project_template_saveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
    project_template_id?: boolean
    project_history_id?: boolean
    project_template?: boolean | project_templateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_template_save"]>

  export type project_template_saveSelectScalar = {
    id?: boolean
    name?: boolean
    data?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
    project_template_id?: boolean
    project_history_id?: boolean
  }

  export type project_template_saveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_template?: boolean | project_templateDefaultArgs<ExtArgs>
  }
  export type project_template_saveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_template?: boolean | project_templateDefaultArgs<ExtArgs>
  }

  export type $project_template_savePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project_template_save"
    objects: {
      project_template: Prisma.$project_templatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      data: Prisma.JsonValue
      images: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date | null
      project_template_id: bigint
      project_history_id: string | null
    }, ExtArgs["result"]["project_template_save"]>
    composites: {}
  }

  type project_template_saveGetPayload<S extends boolean | null | undefined | project_template_saveDefaultArgs> = $Result.GetResult<Prisma.$project_template_savePayload, S>

  type project_template_saveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<project_template_saveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Project_template_saveCountAggregateInputType | true
    }

  export interface project_template_saveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project_template_save'], meta: { name: 'project_template_save' } }
    /**
     * Find zero or one Project_template_save that matches the filter.
     * @param {project_template_saveFindUniqueArgs} args - Arguments to find a Project_template_save
     * @example
     * // Get one Project_template_save
     * const project_template_save = await prisma.project_template_save.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends project_template_saveFindUniqueArgs>(args: SelectSubset<T, project_template_saveFindUniqueArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project_template_save that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {project_template_saveFindUniqueOrThrowArgs} args - Arguments to find a Project_template_save
     * @example
     * // Get one Project_template_save
     * const project_template_save = await prisma.project_template_save.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends project_template_saveFindUniqueOrThrowArgs>(args: SelectSubset<T, project_template_saveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project_template_save that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_template_saveFindFirstArgs} args - Arguments to find a Project_template_save
     * @example
     * // Get one Project_template_save
     * const project_template_save = await prisma.project_template_save.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends project_template_saveFindFirstArgs>(args?: SelectSubset<T, project_template_saveFindFirstArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project_template_save that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_template_saveFindFirstOrThrowArgs} args - Arguments to find a Project_template_save
     * @example
     * // Get one Project_template_save
     * const project_template_save = await prisma.project_template_save.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends project_template_saveFindFirstOrThrowArgs>(args?: SelectSubset<T, project_template_saveFindFirstOrThrowArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Project_template_saves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_template_saveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_template_saves
     * const project_template_saves = await prisma.project_template_save.findMany()
     * 
     * // Get first 10 Project_template_saves
     * const project_template_saves = await prisma.project_template_save.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_template_saveWithIdOnly = await prisma.project_template_save.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends project_template_saveFindManyArgs>(args?: SelectSubset<T, project_template_saveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project_template_save.
     * @param {project_template_saveCreateArgs} args - Arguments to create a Project_template_save.
     * @example
     * // Create one Project_template_save
     * const Project_template_save = await prisma.project_template_save.create({
     *   data: {
     *     // ... data to create a Project_template_save
     *   }
     * })
     * 
     */
    create<T extends project_template_saveCreateArgs>(args: SelectSubset<T, project_template_saveCreateArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Project_template_saves.
     * @param {project_template_saveCreateManyArgs} args - Arguments to create many Project_template_saves.
     * @example
     * // Create many Project_template_saves
     * const project_template_save = await prisma.project_template_save.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends project_template_saveCreateManyArgs>(args?: SelectSubset<T, project_template_saveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Project_template_saves and returns the data saved in the database.
     * @param {project_template_saveCreateManyAndReturnArgs} args - Arguments to create many Project_template_saves.
     * @example
     * // Create many Project_template_saves
     * const project_template_save = await prisma.project_template_save.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Project_template_saves and only return the `id`
     * const project_template_saveWithIdOnly = await prisma.project_template_save.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends project_template_saveCreateManyAndReturnArgs>(args?: SelectSubset<T, project_template_saveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project_template_save.
     * @param {project_template_saveDeleteArgs} args - Arguments to delete one Project_template_save.
     * @example
     * // Delete one Project_template_save
     * const Project_template_save = await prisma.project_template_save.delete({
     *   where: {
     *     // ... filter to delete one Project_template_save
     *   }
     * })
     * 
     */
    delete<T extends project_template_saveDeleteArgs>(args: SelectSubset<T, project_template_saveDeleteArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project_template_save.
     * @param {project_template_saveUpdateArgs} args - Arguments to update one Project_template_save.
     * @example
     * // Update one Project_template_save
     * const project_template_save = await prisma.project_template_save.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends project_template_saveUpdateArgs>(args: SelectSubset<T, project_template_saveUpdateArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Project_template_saves.
     * @param {project_template_saveDeleteManyArgs} args - Arguments to filter Project_template_saves to delete.
     * @example
     * // Delete a few Project_template_saves
     * const { count } = await prisma.project_template_save.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends project_template_saveDeleteManyArgs>(args?: SelectSubset<T, project_template_saveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_template_saves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_template_saveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_template_saves
     * const project_template_save = await prisma.project_template_save.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends project_template_saveUpdateManyArgs>(args: SelectSubset<T, project_template_saveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project_template_save.
     * @param {project_template_saveUpsertArgs} args - Arguments to update or create a Project_template_save.
     * @example
     * // Update or create a Project_template_save
     * const project_template_save = await prisma.project_template_save.upsert({
     *   create: {
     *     // ... data to create a Project_template_save
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_template_save we want to update
     *   }
     * })
     */
    upsert<T extends project_template_saveUpsertArgs>(args: SelectSubset<T, project_template_saveUpsertArgs<ExtArgs>>): Prisma__project_template_saveClient<$Result.GetResult<Prisma.$project_template_savePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Project_template_saves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_template_saveCountArgs} args - Arguments to filter Project_template_saves to count.
     * @example
     * // Count the number of Project_template_saves
     * const count = await prisma.project_template_save.count({
     *   where: {
     *     // ... the filter for the Project_template_saves we want to count
     *   }
     * })
    **/
    count<T extends project_template_saveCountArgs>(
      args?: Subset<T, project_template_saveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_template_saveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_template_save.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Project_template_saveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_template_saveAggregateArgs>(args: Subset<T, Project_template_saveAggregateArgs>): Prisma.PrismaPromise<GetProject_template_saveAggregateType<T>>

    /**
     * Group by Project_template_save.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_template_saveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends project_template_saveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: project_template_saveGroupByArgs['orderBy'] }
        : { orderBy?: project_template_saveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, project_template_saveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProject_template_saveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project_template_save model
   */
  readonly fields: project_template_saveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project_template_save.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__project_template_saveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project_template<T extends project_templateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, project_templateDefaultArgs<ExtArgs>>): Prisma__project_templateClient<$Result.GetResult<Prisma.$project_templatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project_template_save model
   */ 
  interface project_template_saveFieldRefs {
    readonly id: FieldRef<"project_template_save", 'BigInt'>
    readonly name: FieldRef<"project_template_save", 'String'>
    readonly data: FieldRef<"project_template_save", 'Json'>
    readonly images: FieldRef<"project_template_save", 'Json'>
    readonly created_at: FieldRef<"project_template_save", 'DateTime'>
    readonly updated_at: FieldRef<"project_template_save", 'DateTime'>
    readonly project_template_id: FieldRef<"project_template_save", 'BigInt'>
    readonly project_history_id: FieldRef<"project_template_save", 'String'>
  }
    

  // Custom InputTypes
  /**
   * project_template_save findUnique
   */
  export type project_template_saveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * Filter, which project_template_save to fetch.
     */
    where: project_template_saveWhereUniqueInput
  }

  /**
   * project_template_save findUniqueOrThrow
   */
  export type project_template_saveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * Filter, which project_template_save to fetch.
     */
    where: project_template_saveWhereUniqueInput
  }

  /**
   * project_template_save findFirst
   */
  export type project_template_saveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * Filter, which project_template_save to fetch.
     */
    where?: project_template_saveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_template_saves to fetch.
     */
    orderBy?: project_template_saveOrderByWithRelationInput | project_template_saveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_template_saves.
     */
    cursor?: project_template_saveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_template_saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_template_saves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_template_saves.
     */
    distinct?: Project_template_saveScalarFieldEnum | Project_template_saveScalarFieldEnum[]
  }

  /**
   * project_template_save findFirstOrThrow
   */
  export type project_template_saveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * Filter, which project_template_save to fetch.
     */
    where?: project_template_saveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_template_saves to fetch.
     */
    orderBy?: project_template_saveOrderByWithRelationInput | project_template_saveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_template_saves.
     */
    cursor?: project_template_saveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_template_saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_template_saves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_template_saves.
     */
    distinct?: Project_template_saveScalarFieldEnum | Project_template_saveScalarFieldEnum[]
  }

  /**
   * project_template_save findMany
   */
  export type project_template_saveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * Filter, which project_template_saves to fetch.
     */
    where?: project_template_saveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_template_saves to fetch.
     */
    orderBy?: project_template_saveOrderByWithRelationInput | project_template_saveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_template_saves.
     */
    cursor?: project_template_saveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_template_saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_template_saves.
     */
    skip?: number
    distinct?: Project_template_saveScalarFieldEnum | Project_template_saveScalarFieldEnum[]
  }

  /**
   * project_template_save create
   */
  export type project_template_saveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * The data needed to create a project_template_save.
     */
    data: XOR<project_template_saveCreateInput, project_template_saveUncheckedCreateInput>
  }

  /**
   * project_template_save createMany
   */
  export type project_template_saveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many project_template_saves.
     */
    data: project_template_saveCreateManyInput | project_template_saveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_template_save createManyAndReturn
   */
  export type project_template_saveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many project_template_saves.
     */
    data: project_template_saveCreateManyInput | project_template_saveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * project_template_save update
   */
  export type project_template_saveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * The data needed to update a project_template_save.
     */
    data: XOR<project_template_saveUpdateInput, project_template_saveUncheckedUpdateInput>
    /**
     * Choose, which project_template_save to update.
     */
    where: project_template_saveWhereUniqueInput
  }

  /**
   * project_template_save updateMany
   */
  export type project_template_saveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update project_template_saves.
     */
    data: XOR<project_template_saveUpdateManyMutationInput, project_template_saveUncheckedUpdateManyInput>
    /**
     * Filter which project_template_saves to update
     */
    where?: project_template_saveWhereInput
  }

  /**
   * project_template_save upsert
   */
  export type project_template_saveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * The filter to search for the project_template_save to update in case it exists.
     */
    where: project_template_saveWhereUniqueInput
    /**
     * In case the project_template_save found by the `where` argument doesn't exist, create a new project_template_save with this data.
     */
    create: XOR<project_template_saveCreateInput, project_template_saveUncheckedCreateInput>
    /**
     * In case the project_template_save was found with the provided `where` argument, update it with this data.
     */
    update: XOR<project_template_saveUpdateInput, project_template_saveUncheckedUpdateInput>
  }

  /**
   * project_template_save delete
   */
  export type project_template_saveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
    /**
     * Filter which project_template_save to delete.
     */
    where: project_template_saveWhereUniqueInput
  }

  /**
   * project_template_save deleteMany
   */
  export type project_template_saveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_template_saves to delete
     */
    where?: project_template_saveWhereInput
  }

  /**
   * project_template_save without action
   */
  export type project_template_saveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_template_save
     */
    select?: project_template_saveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_template_saveInclude<ExtArgs> | null
  }


  /**
   * Model collection_reward
   */

  export type AggregateCollection_reward = {
    _count: Collection_rewardCountAggregateOutputType | null
    _avg: Collection_rewardAvgAggregateOutputType | null
    _sum: Collection_rewardSumAggregateOutputType | null
    _min: Collection_rewardMinAggregateOutputType | null
    _max: Collection_rewardMaxAggregateOutputType | null
  }

  export type Collection_rewardAvgAggregateOutputType = {
    id: number | null
    credits: number | null
  }

  export type Collection_rewardSumAggregateOutputType = {
    id: number | null
    credits: number | null
  }

  export type Collection_rewardMinAggregateOutputType = {
    id: number | null
    collection_id: string | null
    tag: string | null
    credits: number | null
    enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Collection_rewardMaxAggregateOutputType = {
    id: number | null
    collection_id: string | null
    tag: string | null
    credits: number | null
    enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Collection_rewardCountAggregateOutputType = {
    id: number
    collection_id: number
    tag: number
    credits: number
    enabled: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Collection_rewardAvgAggregateInputType = {
    id?: true
    credits?: true
  }

  export type Collection_rewardSumAggregateInputType = {
    id?: true
    credits?: true
  }

  export type Collection_rewardMinAggregateInputType = {
    id?: true
    collection_id?: true
    tag?: true
    credits?: true
    enabled?: true
    created_at?: true
    updated_at?: true
  }

  export type Collection_rewardMaxAggregateInputType = {
    id?: true
    collection_id?: true
    tag?: true
    credits?: true
    enabled?: true
    created_at?: true
    updated_at?: true
  }

  export type Collection_rewardCountAggregateInputType = {
    id?: true
    collection_id?: true
    tag?: true
    credits?: true
    enabled?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Collection_rewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_reward to aggregate.
     */
    where?: collection_rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_rewards to fetch.
     */
    orderBy?: collection_rewardOrderByWithRelationInput | collection_rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_rewards
    **/
    _count?: true | Collection_rewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_rewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_rewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_rewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_rewardMaxAggregateInputType
  }

  export type GetCollection_rewardAggregateType<T extends Collection_rewardAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_reward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_reward[P]>
      : GetScalarType<T[P], AggregateCollection_reward[P]>
  }




  export type collection_rewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_rewardWhereInput
    orderBy?: collection_rewardOrderByWithAggregationInput | collection_rewardOrderByWithAggregationInput[]
    by: Collection_rewardScalarFieldEnum[] | Collection_rewardScalarFieldEnum
    having?: collection_rewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_rewardCountAggregateInputType | true
    _avg?: Collection_rewardAvgAggregateInputType
    _sum?: Collection_rewardSumAggregateInputType
    _min?: Collection_rewardMinAggregateInputType
    _max?: Collection_rewardMaxAggregateInputType
  }

  export type Collection_rewardGroupByOutputType = {
    id: number
    collection_id: string
    tag: string
    credits: number
    enabled: boolean | null
    created_at: Date
    updated_at: Date | null
    _count: Collection_rewardCountAggregateOutputType | null
    _avg: Collection_rewardAvgAggregateOutputType | null
    _sum: Collection_rewardSumAggregateOutputType | null
    _min: Collection_rewardMinAggregateOutputType | null
    _max: Collection_rewardMaxAggregateOutputType | null
  }

  type GetCollection_rewardGroupByPayload<T extends collection_rewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_rewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_rewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_rewardGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_rewardGroupByOutputType[P]>
        }
      >
    >


  export type collection_rewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    tag?: boolean
    credits?: boolean
    enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_reward_redemption?: boolean | collection_reward$collection_reward_redemptionArgs<ExtArgs>
    _count?: boolean | Collection_rewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_reward"]>

  export type collection_rewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    tag?: boolean
    credits?: boolean
    enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["collection_reward"]>

  export type collection_rewardSelectScalar = {
    id?: boolean
    collection_id?: boolean
    tag?: boolean
    credits?: boolean
    enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type collection_rewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_reward_redemption?: boolean | collection_reward$collection_reward_redemptionArgs<ExtArgs>
    _count?: boolean | Collection_rewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type collection_rewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $collection_rewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_reward"
    objects: {
      collection_reward_redemption: Prisma.$collection_reward_redemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      collection_id: string
      tag: string
      credits: number
      enabled: boolean | null
      created_at: Date
      updated_at: Date | null
    }, ExtArgs["result"]["collection_reward"]>
    composites: {}
  }

  type collection_rewardGetPayload<S extends boolean | null | undefined | collection_rewardDefaultArgs> = $Result.GetResult<Prisma.$collection_rewardPayload, S>

  type collection_rewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_rewardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_rewardCountAggregateInputType | true
    }

  export interface collection_rewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_reward'], meta: { name: 'collection_reward' } }
    /**
     * Find zero or one Collection_reward that matches the filter.
     * @param {collection_rewardFindUniqueArgs} args - Arguments to find a Collection_reward
     * @example
     * // Get one Collection_reward
     * const collection_reward = await prisma.collection_reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_rewardFindUniqueArgs>(args: SelectSubset<T, collection_rewardFindUniqueArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_reward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_rewardFindUniqueOrThrowArgs} args - Arguments to find a Collection_reward
     * @example
     * // Get one Collection_reward
     * const collection_reward = await prisma.collection_reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_rewardFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_rewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_rewardFindFirstArgs} args - Arguments to find a Collection_reward
     * @example
     * // Get one Collection_reward
     * const collection_reward = await prisma.collection_reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_rewardFindFirstArgs>(args?: SelectSubset<T, collection_rewardFindFirstArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_rewardFindFirstOrThrowArgs} args - Arguments to find a Collection_reward
     * @example
     * // Get one Collection_reward
     * const collection_reward = await prisma.collection_reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_rewardFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_rewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_rewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_rewards
     * const collection_rewards = await prisma.collection_reward.findMany()
     * 
     * // Get first 10 Collection_rewards
     * const collection_rewards = await prisma.collection_reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_rewardWithIdOnly = await prisma.collection_reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_rewardFindManyArgs>(args?: SelectSubset<T, collection_rewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_reward.
     * @param {collection_rewardCreateArgs} args - Arguments to create a Collection_reward.
     * @example
     * // Create one Collection_reward
     * const Collection_reward = await prisma.collection_reward.create({
     *   data: {
     *     // ... data to create a Collection_reward
     *   }
     * })
     * 
     */
    create<T extends collection_rewardCreateArgs>(args: SelectSubset<T, collection_rewardCreateArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_rewards.
     * @param {collection_rewardCreateManyArgs} args - Arguments to create many Collection_rewards.
     * @example
     * // Create many Collection_rewards
     * const collection_reward = await prisma.collection_reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_rewardCreateManyArgs>(args?: SelectSubset<T, collection_rewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_rewards and returns the data saved in the database.
     * @param {collection_rewardCreateManyAndReturnArgs} args - Arguments to create many Collection_rewards.
     * @example
     * // Create many Collection_rewards
     * const collection_reward = await prisma.collection_reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_rewards and only return the `id`
     * const collection_rewardWithIdOnly = await prisma.collection_reward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_rewardCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_rewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_reward.
     * @param {collection_rewardDeleteArgs} args - Arguments to delete one Collection_reward.
     * @example
     * // Delete one Collection_reward
     * const Collection_reward = await prisma.collection_reward.delete({
     *   where: {
     *     // ... filter to delete one Collection_reward
     *   }
     * })
     * 
     */
    delete<T extends collection_rewardDeleteArgs>(args: SelectSubset<T, collection_rewardDeleteArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_reward.
     * @param {collection_rewardUpdateArgs} args - Arguments to update one Collection_reward.
     * @example
     * // Update one Collection_reward
     * const collection_reward = await prisma.collection_reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_rewardUpdateArgs>(args: SelectSubset<T, collection_rewardUpdateArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_rewards.
     * @param {collection_rewardDeleteManyArgs} args - Arguments to filter Collection_rewards to delete.
     * @example
     * // Delete a few Collection_rewards
     * const { count } = await prisma.collection_reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_rewardDeleteManyArgs>(args?: SelectSubset<T, collection_rewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_rewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_rewards
     * const collection_reward = await prisma.collection_reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_rewardUpdateManyArgs>(args: SelectSubset<T, collection_rewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_reward.
     * @param {collection_rewardUpsertArgs} args - Arguments to update or create a Collection_reward.
     * @example
     * // Update or create a Collection_reward
     * const collection_reward = await prisma.collection_reward.upsert({
     *   create: {
     *     // ... data to create a Collection_reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_reward we want to update
     *   }
     * })
     */
    upsert<T extends collection_rewardUpsertArgs>(args: SelectSubset<T, collection_rewardUpsertArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_rewardCountArgs} args - Arguments to filter Collection_rewards to count.
     * @example
     * // Count the number of Collection_rewards
     * const count = await prisma.collection_reward.count({
     *   where: {
     *     // ... the filter for the Collection_rewards we want to count
     *   }
     * })
    **/
    count<T extends collection_rewardCountArgs>(
      args?: Subset<T, collection_rewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_rewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_rewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_rewardAggregateArgs>(args: Subset<T, Collection_rewardAggregateArgs>): Prisma.PrismaPromise<GetCollection_rewardAggregateType<T>>

    /**
     * Group by Collection_reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_rewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_rewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_rewardGroupByArgs['orderBy'] }
        : { orderBy?: collection_rewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_rewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_rewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_reward model
   */
  readonly fields: collection_rewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_rewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_reward_redemption<T extends collection_reward$collection_reward_redemptionArgs<ExtArgs> = {}>(args?: Subset<T, collection_reward$collection_reward_redemptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_reward model
   */ 
  interface collection_rewardFieldRefs {
    readonly id: FieldRef<"collection_reward", 'Int'>
    readonly collection_id: FieldRef<"collection_reward", 'String'>
    readonly tag: FieldRef<"collection_reward", 'String'>
    readonly credits: FieldRef<"collection_reward", 'Int'>
    readonly enabled: FieldRef<"collection_reward", 'Boolean'>
    readonly created_at: FieldRef<"collection_reward", 'DateTime'>
    readonly updated_at: FieldRef<"collection_reward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * collection_reward findUnique
   */
  export type collection_rewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward to fetch.
     */
    where: collection_rewardWhereUniqueInput
  }

  /**
   * collection_reward findUniqueOrThrow
   */
  export type collection_rewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward to fetch.
     */
    where: collection_rewardWhereUniqueInput
  }

  /**
   * collection_reward findFirst
   */
  export type collection_rewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward to fetch.
     */
    where?: collection_rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_rewards to fetch.
     */
    orderBy?: collection_rewardOrderByWithRelationInput | collection_rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_rewards.
     */
    cursor?: collection_rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_rewards.
     */
    distinct?: Collection_rewardScalarFieldEnum | Collection_rewardScalarFieldEnum[]
  }

  /**
   * collection_reward findFirstOrThrow
   */
  export type collection_rewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward to fetch.
     */
    where?: collection_rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_rewards to fetch.
     */
    orderBy?: collection_rewardOrderByWithRelationInput | collection_rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_rewards.
     */
    cursor?: collection_rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_rewards.
     */
    distinct?: Collection_rewardScalarFieldEnum | Collection_rewardScalarFieldEnum[]
  }

  /**
   * collection_reward findMany
   */
  export type collection_rewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * Filter, which collection_rewards to fetch.
     */
    where?: collection_rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_rewards to fetch.
     */
    orderBy?: collection_rewardOrderByWithRelationInput | collection_rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_rewards.
     */
    cursor?: collection_rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_rewards.
     */
    skip?: number
    distinct?: Collection_rewardScalarFieldEnum | Collection_rewardScalarFieldEnum[]
  }

  /**
   * collection_reward create
   */
  export type collection_rewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_reward.
     */
    data: XOR<collection_rewardCreateInput, collection_rewardUncheckedCreateInput>
  }

  /**
   * collection_reward createMany
   */
  export type collection_rewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_rewards.
     */
    data: collection_rewardCreateManyInput | collection_rewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_reward createManyAndReturn
   */
  export type collection_rewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_rewards.
     */
    data: collection_rewardCreateManyInput | collection_rewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_reward update
   */
  export type collection_rewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_reward.
     */
    data: XOR<collection_rewardUpdateInput, collection_rewardUncheckedUpdateInput>
    /**
     * Choose, which collection_reward to update.
     */
    where: collection_rewardWhereUniqueInput
  }

  /**
   * collection_reward updateMany
   */
  export type collection_rewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_rewards.
     */
    data: XOR<collection_rewardUpdateManyMutationInput, collection_rewardUncheckedUpdateManyInput>
    /**
     * Filter which collection_rewards to update
     */
    where?: collection_rewardWhereInput
  }

  /**
   * collection_reward upsert
   */
  export type collection_rewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_reward to update in case it exists.
     */
    where: collection_rewardWhereUniqueInput
    /**
     * In case the collection_reward found by the `where` argument doesn't exist, create a new collection_reward with this data.
     */
    create: XOR<collection_rewardCreateInput, collection_rewardUncheckedCreateInput>
    /**
     * In case the collection_reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_rewardUpdateInput, collection_rewardUncheckedUpdateInput>
  }

  /**
   * collection_reward delete
   */
  export type collection_rewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
    /**
     * Filter which collection_reward to delete.
     */
    where: collection_rewardWhereUniqueInput
  }

  /**
   * collection_reward deleteMany
   */
  export type collection_rewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_rewards to delete
     */
    where?: collection_rewardWhereInput
  }

  /**
   * collection_reward.collection_reward_redemption
   */
  export type collection_reward$collection_reward_redemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    where?: collection_reward_redemptionWhereInput
    orderBy?: collection_reward_redemptionOrderByWithRelationInput | collection_reward_redemptionOrderByWithRelationInput[]
    cursor?: collection_reward_redemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_reward_redemptionScalarFieldEnum | Collection_reward_redemptionScalarFieldEnum[]
  }

  /**
   * collection_reward without action
   */
  export type collection_rewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward
     */
    select?: collection_rewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_rewardInclude<ExtArgs> | null
  }


  /**
   * Model collection_reward_redemption
   */

  export type AggregateCollection_reward_redemption = {
    _count: Collection_reward_redemptionCountAggregateOutputType | null
    _avg: Collection_reward_redemptionAvgAggregateOutputType | null
    _sum: Collection_reward_redemptionSumAggregateOutputType | null
    _min: Collection_reward_redemptionMinAggregateOutputType | null
    _max: Collection_reward_redemptionMaxAggregateOutputType | null
  }

  export type Collection_reward_redemptionAvgAggregateOutputType = {
    id: number | null
    collection_reward_id: number | null
  }

  export type Collection_reward_redemptionSumAggregateOutputType = {
    id: number | null
    collection_reward_id: number | null
  }

  export type Collection_reward_redemptionMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    wallet_address: string | null
    token_id: string | null
    collection_reward_id: number | null
    created_at: Date | null
  }

  export type Collection_reward_redemptionMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    wallet_address: string | null
    token_id: string | null
    collection_reward_id: number | null
    created_at: Date | null
  }

  export type Collection_reward_redemptionCountAggregateOutputType = {
    id: number
    user_id: number
    wallet_address: number
    token_id: number
    collection_reward_id: number
    created_at: number
    _all: number
  }


  export type Collection_reward_redemptionAvgAggregateInputType = {
    id?: true
    collection_reward_id?: true
  }

  export type Collection_reward_redemptionSumAggregateInputType = {
    id?: true
    collection_reward_id?: true
  }

  export type Collection_reward_redemptionMinAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    token_id?: true
    collection_reward_id?: true
    created_at?: true
  }

  export type Collection_reward_redemptionMaxAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    token_id?: true
    collection_reward_id?: true
    created_at?: true
  }

  export type Collection_reward_redemptionCountAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    token_id?: true
    collection_reward_id?: true
    created_at?: true
    _all?: true
  }

  export type Collection_reward_redemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_reward_redemption to aggregate.
     */
    where?: collection_reward_redemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_reward_redemptions to fetch.
     */
    orderBy?: collection_reward_redemptionOrderByWithRelationInput | collection_reward_redemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_reward_redemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_reward_redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_reward_redemptions
    **/
    _count?: true | Collection_reward_redemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_reward_redemptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_reward_redemptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_reward_redemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_reward_redemptionMaxAggregateInputType
  }

  export type GetCollection_reward_redemptionAggregateType<T extends Collection_reward_redemptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_reward_redemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_reward_redemption[P]>
      : GetScalarType<T[P], AggregateCollection_reward_redemption[P]>
  }




  export type collection_reward_redemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_reward_redemptionWhereInput
    orderBy?: collection_reward_redemptionOrderByWithAggregationInput | collection_reward_redemptionOrderByWithAggregationInput[]
    by: Collection_reward_redemptionScalarFieldEnum[] | Collection_reward_redemptionScalarFieldEnum
    having?: collection_reward_redemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_reward_redemptionCountAggregateInputType | true
    _avg?: Collection_reward_redemptionAvgAggregateInputType
    _sum?: Collection_reward_redemptionSumAggregateInputType
    _min?: Collection_reward_redemptionMinAggregateInputType
    _max?: Collection_reward_redemptionMaxAggregateInputType
  }

  export type Collection_reward_redemptionGroupByOutputType = {
    id: number
    user_id: string
    wallet_address: string
    token_id: string
    collection_reward_id: number
    created_at: Date
    _count: Collection_reward_redemptionCountAggregateOutputType | null
    _avg: Collection_reward_redemptionAvgAggregateOutputType | null
    _sum: Collection_reward_redemptionSumAggregateOutputType | null
    _min: Collection_reward_redemptionMinAggregateOutputType | null
    _max: Collection_reward_redemptionMaxAggregateOutputType | null
  }

  type GetCollection_reward_redemptionGroupByPayload<T extends collection_reward_redemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_reward_redemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_reward_redemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_reward_redemptionGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_reward_redemptionGroupByOutputType[P]>
        }
      >
    >


  export type collection_reward_redemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    token_id?: boolean
    collection_reward_id?: boolean
    created_at?: boolean
    collection_reward?: boolean | collection_rewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_reward_redemption"]>

  export type collection_reward_redemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    token_id?: boolean
    collection_reward_id?: boolean
    created_at?: boolean
    collection_reward?: boolean | collection_rewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_reward_redemption"]>

  export type collection_reward_redemptionSelectScalar = {
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    token_id?: boolean
    collection_reward_id?: boolean
    created_at?: boolean
  }

  export type collection_reward_redemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_reward?: boolean | collection_rewardDefaultArgs<ExtArgs>
  }
  export type collection_reward_redemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_reward?: boolean | collection_rewardDefaultArgs<ExtArgs>
  }

  export type $collection_reward_redemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_reward_redemption"
    objects: {
      collection_reward: Prisma.$collection_rewardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      wallet_address: string
      token_id: string
      collection_reward_id: number
      created_at: Date
    }, ExtArgs["result"]["collection_reward_redemption"]>
    composites: {}
  }

  type collection_reward_redemptionGetPayload<S extends boolean | null | undefined | collection_reward_redemptionDefaultArgs> = $Result.GetResult<Prisma.$collection_reward_redemptionPayload, S>

  type collection_reward_redemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_reward_redemptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_reward_redemptionCountAggregateInputType | true
    }

  export interface collection_reward_redemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_reward_redemption'], meta: { name: 'collection_reward_redemption' } }
    /**
     * Find zero or one Collection_reward_redemption that matches the filter.
     * @param {collection_reward_redemptionFindUniqueArgs} args - Arguments to find a Collection_reward_redemption
     * @example
     * // Get one Collection_reward_redemption
     * const collection_reward_redemption = await prisma.collection_reward_redemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_reward_redemptionFindUniqueArgs>(args: SelectSubset<T, collection_reward_redemptionFindUniqueArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_reward_redemption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_reward_redemptionFindUniqueOrThrowArgs} args - Arguments to find a Collection_reward_redemption
     * @example
     * // Get one Collection_reward_redemption
     * const collection_reward_redemption = await prisma.collection_reward_redemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_reward_redemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_reward_redemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_reward_redemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_reward_redemptionFindFirstArgs} args - Arguments to find a Collection_reward_redemption
     * @example
     * // Get one Collection_reward_redemption
     * const collection_reward_redemption = await prisma.collection_reward_redemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_reward_redemptionFindFirstArgs>(args?: SelectSubset<T, collection_reward_redemptionFindFirstArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_reward_redemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_reward_redemptionFindFirstOrThrowArgs} args - Arguments to find a Collection_reward_redemption
     * @example
     * // Get one Collection_reward_redemption
     * const collection_reward_redemption = await prisma.collection_reward_redemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_reward_redemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_reward_redemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_reward_redemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_reward_redemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_reward_redemptions
     * const collection_reward_redemptions = await prisma.collection_reward_redemption.findMany()
     * 
     * // Get first 10 Collection_reward_redemptions
     * const collection_reward_redemptions = await prisma.collection_reward_redemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_reward_redemptionWithIdOnly = await prisma.collection_reward_redemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_reward_redemptionFindManyArgs>(args?: SelectSubset<T, collection_reward_redemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_reward_redemption.
     * @param {collection_reward_redemptionCreateArgs} args - Arguments to create a Collection_reward_redemption.
     * @example
     * // Create one Collection_reward_redemption
     * const Collection_reward_redemption = await prisma.collection_reward_redemption.create({
     *   data: {
     *     // ... data to create a Collection_reward_redemption
     *   }
     * })
     * 
     */
    create<T extends collection_reward_redemptionCreateArgs>(args: SelectSubset<T, collection_reward_redemptionCreateArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_reward_redemptions.
     * @param {collection_reward_redemptionCreateManyArgs} args - Arguments to create many Collection_reward_redemptions.
     * @example
     * // Create many Collection_reward_redemptions
     * const collection_reward_redemption = await prisma.collection_reward_redemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_reward_redemptionCreateManyArgs>(args?: SelectSubset<T, collection_reward_redemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_reward_redemptions and returns the data saved in the database.
     * @param {collection_reward_redemptionCreateManyAndReturnArgs} args - Arguments to create many Collection_reward_redemptions.
     * @example
     * // Create many Collection_reward_redemptions
     * const collection_reward_redemption = await prisma.collection_reward_redemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_reward_redemptions and only return the `id`
     * const collection_reward_redemptionWithIdOnly = await prisma.collection_reward_redemption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_reward_redemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_reward_redemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_reward_redemption.
     * @param {collection_reward_redemptionDeleteArgs} args - Arguments to delete one Collection_reward_redemption.
     * @example
     * // Delete one Collection_reward_redemption
     * const Collection_reward_redemption = await prisma.collection_reward_redemption.delete({
     *   where: {
     *     // ... filter to delete one Collection_reward_redemption
     *   }
     * })
     * 
     */
    delete<T extends collection_reward_redemptionDeleteArgs>(args: SelectSubset<T, collection_reward_redemptionDeleteArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_reward_redemption.
     * @param {collection_reward_redemptionUpdateArgs} args - Arguments to update one Collection_reward_redemption.
     * @example
     * // Update one Collection_reward_redemption
     * const collection_reward_redemption = await prisma.collection_reward_redemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_reward_redemptionUpdateArgs>(args: SelectSubset<T, collection_reward_redemptionUpdateArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_reward_redemptions.
     * @param {collection_reward_redemptionDeleteManyArgs} args - Arguments to filter Collection_reward_redemptions to delete.
     * @example
     * // Delete a few Collection_reward_redemptions
     * const { count } = await prisma.collection_reward_redemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_reward_redemptionDeleteManyArgs>(args?: SelectSubset<T, collection_reward_redemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_reward_redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_reward_redemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_reward_redemptions
     * const collection_reward_redemption = await prisma.collection_reward_redemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_reward_redemptionUpdateManyArgs>(args: SelectSubset<T, collection_reward_redemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_reward_redemption.
     * @param {collection_reward_redemptionUpsertArgs} args - Arguments to update or create a Collection_reward_redemption.
     * @example
     * // Update or create a Collection_reward_redemption
     * const collection_reward_redemption = await prisma.collection_reward_redemption.upsert({
     *   create: {
     *     // ... data to create a Collection_reward_redemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_reward_redemption we want to update
     *   }
     * })
     */
    upsert<T extends collection_reward_redemptionUpsertArgs>(args: SelectSubset<T, collection_reward_redemptionUpsertArgs<ExtArgs>>): Prisma__collection_reward_redemptionClient<$Result.GetResult<Prisma.$collection_reward_redemptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_reward_redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_reward_redemptionCountArgs} args - Arguments to filter Collection_reward_redemptions to count.
     * @example
     * // Count the number of Collection_reward_redemptions
     * const count = await prisma.collection_reward_redemption.count({
     *   where: {
     *     // ... the filter for the Collection_reward_redemptions we want to count
     *   }
     * })
    **/
    count<T extends collection_reward_redemptionCountArgs>(
      args?: Subset<T, collection_reward_redemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_reward_redemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_reward_redemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_reward_redemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_reward_redemptionAggregateArgs>(args: Subset<T, Collection_reward_redemptionAggregateArgs>): Prisma.PrismaPromise<GetCollection_reward_redemptionAggregateType<T>>

    /**
     * Group by Collection_reward_redemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_reward_redemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_reward_redemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_reward_redemptionGroupByArgs['orderBy'] }
        : { orderBy?: collection_reward_redemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_reward_redemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_reward_redemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_reward_redemption model
   */
  readonly fields: collection_reward_redemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_reward_redemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_reward_redemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_reward<T extends collection_rewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collection_rewardDefaultArgs<ExtArgs>>): Prisma__collection_rewardClient<$Result.GetResult<Prisma.$collection_rewardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_reward_redemption model
   */ 
  interface collection_reward_redemptionFieldRefs {
    readonly id: FieldRef<"collection_reward_redemption", 'Int'>
    readonly user_id: FieldRef<"collection_reward_redemption", 'String'>
    readonly wallet_address: FieldRef<"collection_reward_redemption", 'String'>
    readonly token_id: FieldRef<"collection_reward_redemption", 'String'>
    readonly collection_reward_id: FieldRef<"collection_reward_redemption", 'Int'>
    readonly created_at: FieldRef<"collection_reward_redemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * collection_reward_redemption findUnique
   */
  export type collection_reward_redemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward_redemption to fetch.
     */
    where: collection_reward_redemptionWhereUniqueInput
  }

  /**
   * collection_reward_redemption findUniqueOrThrow
   */
  export type collection_reward_redemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward_redemption to fetch.
     */
    where: collection_reward_redemptionWhereUniqueInput
  }

  /**
   * collection_reward_redemption findFirst
   */
  export type collection_reward_redemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward_redemption to fetch.
     */
    where?: collection_reward_redemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_reward_redemptions to fetch.
     */
    orderBy?: collection_reward_redemptionOrderByWithRelationInput | collection_reward_redemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_reward_redemptions.
     */
    cursor?: collection_reward_redemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_reward_redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_reward_redemptions.
     */
    distinct?: Collection_reward_redemptionScalarFieldEnum | Collection_reward_redemptionScalarFieldEnum[]
  }

  /**
   * collection_reward_redemption findFirstOrThrow
   */
  export type collection_reward_redemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward_redemption to fetch.
     */
    where?: collection_reward_redemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_reward_redemptions to fetch.
     */
    orderBy?: collection_reward_redemptionOrderByWithRelationInput | collection_reward_redemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_reward_redemptions.
     */
    cursor?: collection_reward_redemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_reward_redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_reward_redemptions.
     */
    distinct?: Collection_reward_redemptionScalarFieldEnum | Collection_reward_redemptionScalarFieldEnum[]
  }

  /**
   * collection_reward_redemption findMany
   */
  export type collection_reward_redemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * Filter, which collection_reward_redemptions to fetch.
     */
    where?: collection_reward_redemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_reward_redemptions to fetch.
     */
    orderBy?: collection_reward_redemptionOrderByWithRelationInput | collection_reward_redemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_reward_redemptions.
     */
    cursor?: collection_reward_redemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_reward_redemptions.
     */
    skip?: number
    distinct?: Collection_reward_redemptionScalarFieldEnum | Collection_reward_redemptionScalarFieldEnum[]
  }

  /**
   * collection_reward_redemption create
   */
  export type collection_reward_redemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_reward_redemption.
     */
    data: XOR<collection_reward_redemptionCreateInput, collection_reward_redemptionUncheckedCreateInput>
  }

  /**
   * collection_reward_redemption createMany
   */
  export type collection_reward_redemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_reward_redemptions.
     */
    data: collection_reward_redemptionCreateManyInput | collection_reward_redemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_reward_redemption createManyAndReturn
   */
  export type collection_reward_redemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_reward_redemptions.
     */
    data: collection_reward_redemptionCreateManyInput | collection_reward_redemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_reward_redemption update
   */
  export type collection_reward_redemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_reward_redemption.
     */
    data: XOR<collection_reward_redemptionUpdateInput, collection_reward_redemptionUncheckedUpdateInput>
    /**
     * Choose, which collection_reward_redemption to update.
     */
    where: collection_reward_redemptionWhereUniqueInput
  }

  /**
   * collection_reward_redemption updateMany
   */
  export type collection_reward_redemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_reward_redemptions.
     */
    data: XOR<collection_reward_redemptionUpdateManyMutationInput, collection_reward_redemptionUncheckedUpdateManyInput>
    /**
     * Filter which collection_reward_redemptions to update
     */
    where?: collection_reward_redemptionWhereInput
  }

  /**
   * collection_reward_redemption upsert
   */
  export type collection_reward_redemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_reward_redemption to update in case it exists.
     */
    where: collection_reward_redemptionWhereUniqueInput
    /**
     * In case the collection_reward_redemption found by the `where` argument doesn't exist, create a new collection_reward_redemption with this data.
     */
    create: XOR<collection_reward_redemptionCreateInput, collection_reward_redemptionUncheckedCreateInput>
    /**
     * In case the collection_reward_redemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_reward_redemptionUpdateInput, collection_reward_redemptionUncheckedUpdateInput>
  }

  /**
   * collection_reward_redemption delete
   */
  export type collection_reward_redemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
    /**
     * Filter which collection_reward_redemption to delete.
     */
    where: collection_reward_redemptionWhereUniqueInput
  }

  /**
   * collection_reward_redemption deleteMany
   */
  export type collection_reward_redemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_reward_redemptions to delete
     */
    where?: collection_reward_redemptionWhereInput
  }

  /**
   * collection_reward_redemption without action
   */
  export type collection_reward_redemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_reward_redemption
     */
    select?: collection_reward_redemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_reward_redemptionInclude<ExtArgs> | null
  }


  /**
   * Model collection_sales_receivers
   */

  export type AggregateCollection_sales_receivers = {
    _count: Collection_sales_receiversCountAggregateOutputType | null
    _avg: Collection_sales_receiversAvgAggregateOutputType | null
    _sum: Collection_sales_receiversSumAggregateOutputType | null
    _min: Collection_sales_receiversMinAggregateOutputType | null
    _max: Collection_sales_receiversMaxAggregateOutputType | null
  }

  export type Collection_sales_receiversAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type Collection_sales_receiversSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type Collection_sales_receiversMinAggregateOutputType = {
    id: number | null
    collection_id: string | null
    address: string | null
    value: number | null
    type: string | null
  }

  export type Collection_sales_receiversMaxAggregateOutputType = {
    id: number | null
    collection_id: string | null
    address: string | null
    value: number | null
    type: string | null
  }

  export type Collection_sales_receiversCountAggregateOutputType = {
    id: number
    collection_id: number
    address: number
    value: number
    type: number
    _all: number
  }


  export type Collection_sales_receiversAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type Collection_sales_receiversSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type Collection_sales_receiversMinAggregateInputType = {
    id?: true
    collection_id?: true
    address?: true
    value?: true
    type?: true
  }

  export type Collection_sales_receiversMaxAggregateInputType = {
    id?: true
    collection_id?: true
    address?: true
    value?: true
    type?: true
  }

  export type Collection_sales_receiversCountAggregateInputType = {
    id?: true
    collection_id?: true
    address?: true
    value?: true
    type?: true
    _all?: true
  }

  export type Collection_sales_receiversAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_sales_receivers to aggregate.
     */
    where?: collection_sales_receiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sales_receivers to fetch.
     */
    orderBy?: collection_sales_receiversOrderByWithRelationInput | collection_sales_receiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_sales_receiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sales_receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sales_receivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_sales_receivers
    **/
    _count?: true | Collection_sales_receiversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_sales_receiversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_sales_receiversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_sales_receiversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_sales_receiversMaxAggregateInputType
  }

  export type GetCollection_sales_receiversAggregateType<T extends Collection_sales_receiversAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_sales_receivers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_sales_receivers[P]>
      : GetScalarType<T[P], AggregateCollection_sales_receivers[P]>
  }




  export type collection_sales_receiversGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_sales_receiversWhereInput
    orderBy?: collection_sales_receiversOrderByWithAggregationInput | collection_sales_receiversOrderByWithAggregationInput[]
    by: Collection_sales_receiversScalarFieldEnum[] | Collection_sales_receiversScalarFieldEnum
    having?: collection_sales_receiversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_sales_receiversCountAggregateInputType | true
    _avg?: Collection_sales_receiversAvgAggregateInputType
    _sum?: Collection_sales_receiversSumAggregateInputType
    _min?: Collection_sales_receiversMinAggregateInputType
    _max?: Collection_sales_receiversMaxAggregateInputType
  }

  export type Collection_sales_receiversGroupByOutputType = {
    id: number
    collection_id: string
    address: string
    value: number
    type: string
    _count: Collection_sales_receiversCountAggregateOutputType | null
    _avg: Collection_sales_receiversAvgAggregateOutputType | null
    _sum: Collection_sales_receiversSumAggregateOutputType | null
    _min: Collection_sales_receiversMinAggregateOutputType | null
    _max: Collection_sales_receiversMaxAggregateOutputType | null
  }

  type GetCollection_sales_receiversGroupByPayload<T extends collection_sales_receiversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_sales_receiversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_sales_receiversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_sales_receiversGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_sales_receiversGroupByOutputType[P]>
        }
      >
    >


  export type collection_sales_receiversSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    address?: boolean
    value?: boolean
    type?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_sales_receivers"]>

  export type collection_sales_receiversSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    address?: boolean
    value?: boolean
    type?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_sales_receivers"]>

  export type collection_sales_receiversSelectScalar = {
    id?: boolean
    collection_id?: boolean
    address?: boolean
    value?: boolean
    type?: boolean
  }

  export type collection_sales_receiversInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }
  export type collection_sales_receiversIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $collection_sales_receiversPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_sales_receivers"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      collection_id: string
      address: string
      value: number
      type: string
    }, ExtArgs["result"]["collection_sales_receivers"]>
    composites: {}
  }

  type collection_sales_receiversGetPayload<S extends boolean | null | undefined | collection_sales_receiversDefaultArgs> = $Result.GetResult<Prisma.$collection_sales_receiversPayload, S>

  type collection_sales_receiversCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_sales_receiversFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_sales_receiversCountAggregateInputType | true
    }

  export interface collection_sales_receiversDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_sales_receivers'], meta: { name: 'collection_sales_receivers' } }
    /**
     * Find zero or one Collection_sales_receivers that matches the filter.
     * @param {collection_sales_receiversFindUniqueArgs} args - Arguments to find a Collection_sales_receivers
     * @example
     * // Get one Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_sales_receiversFindUniqueArgs>(args: SelectSubset<T, collection_sales_receiversFindUniqueArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_sales_receivers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_sales_receiversFindUniqueOrThrowArgs} args - Arguments to find a Collection_sales_receivers
     * @example
     * // Get one Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_sales_receiversFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_sales_receiversFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_sales_receivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sales_receiversFindFirstArgs} args - Arguments to find a Collection_sales_receivers
     * @example
     * // Get one Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_sales_receiversFindFirstArgs>(args?: SelectSubset<T, collection_sales_receiversFindFirstArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_sales_receivers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sales_receiversFindFirstOrThrowArgs} args - Arguments to find a Collection_sales_receivers
     * @example
     * // Get one Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_sales_receiversFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_sales_receiversFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_sales_receivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sales_receiversFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.findMany()
     * 
     * // Get first 10 Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_sales_receiversWithIdOnly = await prisma.collection_sales_receivers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_sales_receiversFindManyArgs>(args?: SelectSubset<T, collection_sales_receiversFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_sales_receivers.
     * @param {collection_sales_receiversCreateArgs} args - Arguments to create a Collection_sales_receivers.
     * @example
     * // Create one Collection_sales_receivers
     * const Collection_sales_receivers = await prisma.collection_sales_receivers.create({
     *   data: {
     *     // ... data to create a Collection_sales_receivers
     *   }
     * })
     * 
     */
    create<T extends collection_sales_receiversCreateArgs>(args: SelectSubset<T, collection_sales_receiversCreateArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_sales_receivers.
     * @param {collection_sales_receiversCreateManyArgs} args - Arguments to create many Collection_sales_receivers.
     * @example
     * // Create many Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_sales_receiversCreateManyArgs>(args?: SelectSubset<T, collection_sales_receiversCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_sales_receivers and returns the data saved in the database.
     * @param {collection_sales_receiversCreateManyAndReturnArgs} args - Arguments to create many Collection_sales_receivers.
     * @example
     * // Create many Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_sales_receivers and only return the `id`
     * const collection_sales_receiversWithIdOnly = await prisma.collection_sales_receivers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_sales_receiversCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_sales_receiversCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_sales_receivers.
     * @param {collection_sales_receiversDeleteArgs} args - Arguments to delete one Collection_sales_receivers.
     * @example
     * // Delete one Collection_sales_receivers
     * const Collection_sales_receivers = await prisma.collection_sales_receivers.delete({
     *   where: {
     *     // ... filter to delete one Collection_sales_receivers
     *   }
     * })
     * 
     */
    delete<T extends collection_sales_receiversDeleteArgs>(args: SelectSubset<T, collection_sales_receiversDeleteArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_sales_receivers.
     * @param {collection_sales_receiversUpdateArgs} args - Arguments to update one Collection_sales_receivers.
     * @example
     * // Update one Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_sales_receiversUpdateArgs>(args: SelectSubset<T, collection_sales_receiversUpdateArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_sales_receivers.
     * @param {collection_sales_receiversDeleteManyArgs} args - Arguments to filter Collection_sales_receivers to delete.
     * @example
     * // Delete a few Collection_sales_receivers
     * const { count } = await prisma.collection_sales_receivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_sales_receiversDeleteManyArgs>(args?: SelectSubset<T, collection_sales_receiversDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_sales_receivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sales_receiversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_sales_receiversUpdateManyArgs>(args: SelectSubset<T, collection_sales_receiversUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_sales_receivers.
     * @param {collection_sales_receiversUpsertArgs} args - Arguments to update or create a Collection_sales_receivers.
     * @example
     * // Update or create a Collection_sales_receivers
     * const collection_sales_receivers = await prisma.collection_sales_receivers.upsert({
     *   create: {
     *     // ... data to create a Collection_sales_receivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_sales_receivers we want to update
     *   }
     * })
     */
    upsert<T extends collection_sales_receiversUpsertArgs>(args: SelectSubset<T, collection_sales_receiversUpsertArgs<ExtArgs>>): Prisma__collection_sales_receiversClient<$Result.GetResult<Prisma.$collection_sales_receiversPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_sales_receivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sales_receiversCountArgs} args - Arguments to filter Collection_sales_receivers to count.
     * @example
     * // Count the number of Collection_sales_receivers
     * const count = await prisma.collection_sales_receivers.count({
     *   where: {
     *     // ... the filter for the Collection_sales_receivers we want to count
     *   }
     * })
    **/
    count<T extends collection_sales_receiversCountArgs>(
      args?: Subset<T, collection_sales_receiversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_sales_receiversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_sales_receivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_sales_receiversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_sales_receiversAggregateArgs>(args: Subset<T, Collection_sales_receiversAggregateArgs>): Prisma.PrismaPromise<GetCollection_sales_receiversAggregateType<T>>

    /**
     * Group by Collection_sales_receivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sales_receiversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_sales_receiversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_sales_receiversGroupByArgs['orderBy'] }
        : { orderBy?: collection_sales_receiversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_sales_receiversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_sales_receiversGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_sales_receivers model
   */
  readonly fields: collection_sales_receiversFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_sales_receivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_sales_receiversClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_sales_receivers model
   */ 
  interface collection_sales_receiversFieldRefs {
    readonly id: FieldRef<"collection_sales_receivers", 'Int'>
    readonly collection_id: FieldRef<"collection_sales_receivers", 'String'>
    readonly address: FieldRef<"collection_sales_receivers", 'String'>
    readonly value: FieldRef<"collection_sales_receivers", 'Float'>
    readonly type: FieldRef<"collection_sales_receivers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collection_sales_receivers findUnique
   */
  export type collection_sales_receiversFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * Filter, which collection_sales_receivers to fetch.
     */
    where: collection_sales_receiversWhereUniqueInput
  }

  /**
   * collection_sales_receivers findUniqueOrThrow
   */
  export type collection_sales_receiversFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * Filter, which collection_sales_receivers to fetch.
     */
    where: collection_sales_receiversWhereUniqueInput
  }

  /**
   * collection_sales_receivers findFirst
   */
  export type collection_sales_receiversFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * Filter, which collection_sales_receivers to fetch.
     */
    where?: collection_sales_receiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sales_receivers to fetch.
     */
    orderBy?: collection_sales_receiversOrderByWithRelationInput | collection_sales_receiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_sales_receivers.
     */
    cursor?: collection_sales_receiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sales_receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sales_receivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_sales_receivers.
     */
    distinct?: Collection_sales_receiversScalarFieldEnum | Collection_sales_receiversScalarFieldEnum[]
  }

  /**
   * collection_sales_receivers findFirstOrThrow
   */
  export type collection_sales_receiversFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * Filter, which collection_sales_receivers to fetch.
     */
    where?: collection_sales_receiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sales_receivers to fetch.
     */
    orderBy?: collection_sales_receiversOrderByWithRelationInput | collection_sales_receiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_sales_receivers.
     */
    cursor?: collection_sales_receiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sales_receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sales_receivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_sales_receivers.
     */
    distinct?: Collection_sales_receiversScalarFieldEnum | Collection_sales_receiversScalarFieldEnum[]
  }

  /**
   * collection_sales_receivers findMany
   */
  export type collection_sales_receiversFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * Filter, which collection_sales_receivers to fetch.
     */
    where?: collection_sales_receiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sales_receivers to fetch.
     */
    orderBy?: collection_sales_receiversOrderByWithRelationInput | collection_sales_receiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_sales_receivers.
     */
    cursor?: collection_sales_receiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sales_receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sales_receivers.
     */
    skip?: number
    distinct?: Collection_sales_receiversScalarFieldEnum | Collection_sales_receiversScalarFieldEnum[]
  }

  /**
   * collection_sales_receivers create
   */
  export type collection_sales_receiversCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_sales_receivers.
     */
    data: XOR<collection_sales_receiversCreateInput, collection_sales_receiversUncheckedCreateInput>
  }

  /**
   * collection_sales_receivers createMany
   */
  export type collection_sales_receiversCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_sales_receivers.
     */
    data: collection_sales_receiversCreateManyInput | collection_sales_receiversCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_sales_receivers createManyAndReturn
   */
  export type collection_sales_receiversCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_sales_receivers.
     */
    data: collection_sales_receiversCreateManyInput | collection_sales_receiversCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_sales_receivers update
   */
  export type collection_sales_receiversUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_sales_receivers.
     */
    data: XOR<collection_sales_receiversUpdateInput, collection_sales_receiversUncheckedUpdateInput>
    /**
     * Choose, which collection_sales_receivers to update.
     */
    where: collection_sales_receiversWhereUniqueInput
  }

  /**
   * collection_sales_receivers updateMany
   */
  export type collection_sales_receiversUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_sales_receivers.
     */
    data: XOR<collection_sales_receiversUpdateManyMutationInput, collection_sales_receiversUncheckedUpdateManyInput>
    /**
     * Filter which collection_sales_receivers to update
     */
    where?: collection_sales_receiversWhereInput
  }

  /**
   * collection_sales_receivers upsert
   */
  export type collection_sales_receiversUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_sales_receivers to update in case it exists.
     */
    where: collection_sales_receiversWhereUniqueInput
    /**
     * In case the collection_sales_receivers found by the `where` argument doesn't exist, create a new collection_sales_receivers with this data.
     */
    create: XOR<collection_sales_receiversCreateInput, collection_sales_receiversUncheckedCreateInput>
    /**
     * In case the collection_sales_receivers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_sales_receiversUpdateInput, collection_sales_receiversUncheckedUpdateInput>
  }

  /**
   * collection_sales_receivers delete
   */
  export type collection_sales_receiversDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
    /**
     * Filter which collection_sales_receivers to delete.
     */
    where: collection_sales_receiversWhereUniqueInput
  }

  /**
   * collection_sales_receivers deleteMany
   */
  export type collection_sales_receiversDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_sales_receivers to delete
     */
    where?: collection_sales_receiversWhereInput
  }

  /**
   * collection_sales_receivers without action
   */
  export type collection_sales_receiversDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sales_receivers
     */
    select?: collection_sales_receiversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sales_receiversInclude<ExtArgs> | null
  }


  /**
   * Model collection_history
   */

  export type AggregateCollection_history = {
    _count: Collection_historyCountAggregateOutputType | null
    _avg: Collection_historyAvgAggregateOutputType | null
    _sum: Collection_historySumAggregateOutputType | null
    _min: Collection_historyMinAggregateOutputType | null
    _max: Collection_historyMaxAggregateOutputType | null
  }

  export type Collection_historyAvgAggregateOutputType = {
    id: number | null
  }

  export type Collection_historySumAggregateOutputType = {
    id: number | null
  }

  export type Collection_historyMinAggregateOutputType = {
    id: number | null
    event: string | null
    current_value: string | null
    new_value: string | null
    created_at: Date | null
    collection_id: string | null
  }

  export type Collection_historyMaxAggregateOutputType = {
    id: number | null
    event: string | null
    current_value: string | null
    new_value: string | null
    created_at: Date | null
    collection_id: string | null
  }

  export type Collection_historyCountAggregateOutputType = {
    id: number
    event: number
    current_value: number
    new_value: number
    created_at: number
    collection_id: number
    _all: number
  }


  export type Collection_historyAvgAggregateInputType = {
    id?: true
  }

  export type Collection_historySumAggregateInputType = {
    id?: true
  }

  export type Collection_historyMinAggregateInputType = {
    id?: true
    event?: true
    current_value?: true
    new_value?: true
    created_at?: true
    collection_id?: true
  }

  export type Collection_historyMaxAggregateInputType = {
    id?: true
    event?: true
    current_value?: true
    new_value?: true
    created_at?: true
    collection_id?: true
  }

  export type Collection_historyCountAggregateInputType = {
    id?: true
    event?: true
    current_value?: true
    new_value?: true
    created_at?: true
    collection_id?: true
    _all?: true
  }

  export type Collection_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_history to aggregate.
     */
    where?: collection_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_histories to fetch.
     */
    orderBy?: collection_historyOrderByWithRelationInput | collection_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_histories
    **/
    _count?: true | Collection_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_historyMaxAggregateInputType
  }

  export type GetCollection_historyAggregateType<T extends Collection_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_history[P]>
      : GetScalarType<T[P], AggregateCollection_history[P]>
  }




  export type collection_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_historyWhereInput
    orderBy?: collection_historyOrderByWithAggregationInput | collection_historyOrderByWithAggregationInput[]
    by: Collection_historyScalarFieldEnum[] | Collection_historyScalarFieldEnum
    having?: collection_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_historyCountAggregateInputType | true
    _avg?: Collection_historyAvgAggregateInputType
    _sum?: Collection_historySumAggregateInputType
    _min?: Collection_historyMinAggregateInputType
    _max?: Collection_historyMaxAggregateInputType
  }

  export type Collection_historyGroupByOutputType = {
    id: number
    event: string
    current_value: string
    new_value: string
    created_at: Date
    collection_id: string
    _count: Collection_historyCountAggregateOutputType | null
    _avg: Collection_historyAvgAggregateOutputType | null
    _sum: Collection_historySumAggregateOutputType | null
    _min: Collection_historyMinAggregateOutputType | null
    _max: Collection_historyMaxAggregateOutputType | null
  }

  type GetCollection_historyGroupByPayload<T extends collection_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_historyGroupByOutputType[P]>
        }
      >
    >


  export type collection_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    current_value?: boolean
    new_value?: boolean
    created_at?: boolean
    collection_id?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_history"]>

  export type collection_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    current_value?: boolean
    new_value?: boolean
    created_at?: boolean
    collection_id?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_history"]>

  export type collection_historySelectScalar = {
    id?: boolean
    event?: boolean
    current_value?: boolean
    new_value?: boolean
    created_at?: boolean
    collection_id?: boolean
  }

  export type collection_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }
  export type collection_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $collection_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_history"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      event: string
      current_value: string
      new_value: string
      created_at: Date
      collection_id: string
    }, ExtArgs["result"]["collection_history"]>
    composites: {}
  }

  type collection_historyGetPayload<S extends boolean | null | undefined | collection_historyDefaultArgs> = $Result.GetResult<Prisma.$collection_historyPayload, S>

  type collection_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_historyCountAggregateInputType | true
    }

  export interface collection_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_history'], meta: { name: 'collection_history' } }
    /**
     * Find zero or one Collection_history that matches the filter.
     * @param {collection_historyFindUniqueArgs} args - Arguments to find a Collection_history
     * @example
     * // Get one Collection_history
     * const collection_history = await prisma.collection_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_historyFindUniqueArgs>(args: SelectSubset<T, collection_historyFindUniqueArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_historyFindUniqueOrThrowArgs} args - Arguments to find a Collection_history
     * @example
     * // Get one Collection_history
     * const collection_history = await prisma.collection_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_historyFindFirstArgs} args - Arguments to find a Collection_history
     * @example
     * // Get one Collection_history
     * const collection_history = await prisma.collection_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_historyFindFirstArgs>(args?: SelectSubset<T, collection_historyFindFirstArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_historyFindFirstOrThrowArgs} args - Arguments to find a Collection_history
     * @example
     * // Get one Collection_history
     * const collection_history = await prisma.collection_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_histories
     * const collection_histories = await prisma.collection_history.findMany()
     * 
     * // Get first 10 Collection_histories
     * const collection_histories = await prisma.collection_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_historyWithIdOnly = await prisma.collection_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_historyFindManyArgs>(args?: SelectSubset<T, collection_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_history.
     * @param {collection_historyCreateArgs} args - Arguments to create a Collection_history.
     * @example
     * // Create one Collection_history
     * const Collection_history = await prisma.collection_history.create({
     *   data: {
     *     // ... data to create a Collection_history
     *   }
     * })
     * 
     */
    create<T extends collection_historyCreateArgs>(args: SelectSubset<T, collection_historyCreateArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_histories.
     * @param {collection_historyCreateManyArgs} args - Arguments to create many Collection_histories.
     * @example
     * // Create many Collection_histories
     * const collection_history = await prisma.collection_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_historyCreateManyArgs>(args?: SelectSubset<T, collection_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_histories and returns the data saved in the database.
     * @param {collection_historyCreateManyAndReturnArgs} args - Arguments to create many Collection_histories.
     * @example
     * // Create many Collection_histories
     * const collection_history = await prisma.collection_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_histories and only return the `id`
     * const collection_historyWithIdOnly = await prisma.collection_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_history.
     * @param {collection_historyDeleteArgs} args - Arguments to delete one Collection_history.
     * @example
     * // Delete one Collection_history
     * const Collection_history = await prisma.collection_history.delete({
     *   where: {
     *     // ... filter to delete one Collection_history
     *   }
     * })
     * 
     */
    delete<T extends collection_historyDeleteArgs>(args: SelectSubset<T, collection_historyDeleteArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_history.
     * @param {collection_historyUpdateArgs} args - Arguments to update one Collection_history.
     * @example
     * // Update one Collection_history
     * const collection_history = await prisma.collection_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_historyUpdateArgs>(args: SelectSubset<T, collection_historyUpdateArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_histories.
     * @param {collection_historyDeleteManyArgs} args - Arguments to filter Collection_histories to delete.
     * @example
     * // Delete a few Collection_histories
     * const { count } = await prisma.collection_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_historyDeleteManyArgs>(args?: SelectSubset<T, collection_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_histories
     * const collection_history = await prisma.collection_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_historyUpdateManyArgs>(args: SelectSubset<T, collection_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_history.
     * @param {collection_historyUpsertArgs} args - Arguments to update or create a Collection_history.
     * @example
     * // Update or create a Collection_history
     * const collection_history = await prisma.collection_history.upsert({
     *   create: {
     *     // ... data to create a Collection_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_history we want to update
     *   }
     * })
     */
    upsert<T extends collection_historyUpsertArgs>(args: SelectSubset<T, collection_historyUpsertArgs<ExtArgs>>): Prisma__collection_historyClient<$Result.GetResult<Prisma.$collection_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_historyCountArgs} args - Arguments to filter Collection_histories to count.
     * @example
     * // Count the number of Collection_histories
     * const count = await prisma.collection_history.count({
     *   where: {
     *     // ... the filter for the Collection_histories we want to count
     *   }
     * })
    **/
    count<T extends collection_historyCountArgs>(
      args?: Subset<T, collection_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_historyAggregateArgs>(args: Subset<T, Collection_historyAggregateArgs>): Prisma.PrismaPromise<GetCollection_historyAggregateType<T>>

    /**
     * Group by Collection_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_historyGroupByArgs['orderBy'] }
        : { orderBy?: collection_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_history model
   */
  readonly fields: collection_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_history model
   */ 
  interface collection_historyFieldRefs {
    readonly id: FieldRef<"collection_history", 'Int'>
    readonly event: FieldRef<"collection_history", 'String'>
    readonly current_value: FieldRef<"collection_history", 'String'>
    readonly new_value: FieldRef<"collection_history", 'String'>
    readonly created_at: FieldRef<"collection_history", 'DateTime'>
    readonly collection_id: FieldRef<"collection_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collection_history findUnique
   */
  export type collection_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * Filter, which collection_history to fetch.
     */
    where: collection_historyWhereUniqueInput
  }

  /**
   * collection_history findUniqueOrThrow
   */
  export type collection_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * Filter, which collection_history to fetch.
     */
    where: collection_historyWhereUniqueInput
  }

  /**
   * collection_history findFirst
   */
  export type collection_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * Filter, which collection_history to fetch.
     */
    where?: collection_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_histories to fetch.
     */
    orderBy?: collection_historyOrderByWithRelationInput | collection_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_histories.
     */
    cursor?: collection_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_histories.
     */
    distinct?: Collection_historyScalarFieldEnum | Collection_historyScalarFieldEnum[]
  }

  /**
   * collection_history findFirstOrThrow
   */
  export type collection_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * Filter, which collection_history to fetch.
     */
    where?: collection_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_histories to fetch.
     */
    orderBy?: collection_historyOrderByWithRelationInput | collection_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_histories.
     */
    cursor?: collection_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_histories.
     */
    distinct?: Collection_historyScalarFieldEnum | Collection_historyScalarFieldEnum[]
  }

  /**
   * collection_history findMany
   */
  export type collection_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * Filter, which collection_histories to fetch.
     */
    where?: collection_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_histories to fetch.
     */
    orderBy?: collection_historyOrderByWithRelationInput | collection_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_histories.
     */
    cursor?: collection_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_histories.
     */
    skip?: number
    distinct?: Collection_historyScalarFieldEnum | Collection_historyScalarFieldEnum[]
  }

  /**
   * collection_history create
   */
  export type collection_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_history.
     */
    data: XOR<collection_historyCreateInput, collection_historyUncheckedCreateInput>
  }

  /**
   * collection_history createMany
   */
  export type collection_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_histories.
     */
    data: collection_historyCreateManyInput | collection_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_history createManyAndReturn
   */
  export type collection_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_histories.
     */
    data: collection_historyCreateManyInput | collection_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_history update
   */
  export type collection_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_history.
     */
    data: XOR<collection_historyUpdateInput, collection_historyUncheckedUpdateInput>
    /**
     * Choose, which collection_history to update.
     */
    where: collection_historyWhereUniqueInput
  }

  /**
   * collection_history updateMany
   */
  export type collection_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_histories.
     */
    data: XOR<collection_historyUpdateManyMutationInput, collection_historyUncheckedUpdateManyInput>
    /**
     * Filter which collection_histories to update
     */
    where?: collection_historyWhereInput
  }

  /**
   * collection_history upsert
   */
  export type collection_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_history to update in case it exists.
     */
    where: collection_historyWhereUniqueInput
    /**
     * In case the collection_history found by the `where` argument doesn't exist, create a new collection_history with this data.
     */
    create: XOR<collection_historyCreateInput, collection_historyUncheckedCreateInput>
    /**
     * In case the collection_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_historyUpdateInput, collection_historyUncheckedUpdateInput>
  }

  /**
   * collection_history delete
   */
  export type collection_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
    /**
     * Filter which collection_history to delete.
     */
    where: collection_historyWhereUniqueInput
  }

  /**
   * collection_history deleteMany
   */
  export type collection_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_histories to delete
     */
    where?: collection_historyWhereInput
  }

  /**
   * collection_history without action
   */
  export type collection_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_history
     */
    select?: collection_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_historyInclude<ExtArgs> | null
  }


  /**
   * Model profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    profile_image: string | null
    profile_preference: string | null
    created_at: Date | null
    updated_at: Date | null
    profile_username: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    profile_image: string | null
    profile_preference: string | null
    created_at: Date | null
    updated_at: Date | null
    profile_username: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    profile_image: number
    profile_preference: number
    created_at: number
    updated_at: number
    profile_username: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    profile_image?: true
    profile_preference?: true
    created_at?: true
    updated_at?: true
    profile_username?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    profile_image?: true
    profile_preference?: true
    created_at?: true
    updated_at?: true
    profile_username?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    profile_image?: true
    profile_preference?: true
    created_at?: true
    updated_at?: true
    profile_username?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    profile_image: string | null
    profile_preference: string | null
    created_at: Date | null
    updated_at: Date | null
    profile_username: string | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_image?: boolean
    profile_preference?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile_username?: boolean
  }, ExtArgs["result"]["profile"]>

  export type profileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_image?: boolean
    profile_preference?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile_username?: boolean
  }, ExtArgs["result"]["profile"]>

  export type profileSelectScalar = {
    id?: boolean
    profile_image?: boolean
    profile_preference?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile_username?: boolean
  }


  export type $profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_image: string | null
      profile_preference: string | null
      created_at: Date | null
      updated_at: Date | null
      profile_username: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type profileGetPayload<S extends boolean | null | undefined | profileDefaultArgs> = $Result.GetResult<Prisma.$profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<profileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profileFindUniqueArgs>(args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs>(args: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profileFindFirstArgs>(args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs>(args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profileFindManyArgs>(args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends profileCreateArgs>(args: SelectSubset<T, profileCreateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profileCreateManyArgs>(args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {profileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends profileCreateManyAndReturnArgs>(args?: SelectSubset<T, profileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends profileDeleteArgs>(args: SelectSubset<T, profileDeleteArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profileUpdateArgs>(args: SelectSubset<T, profileUpdateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profileDeleteManyArgs>(args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profileUpdateManyArgs>(args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends profileUpsertArgs>(args: SelectSubset<T, profileUpsertArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profile model
   */ 
  interface profileFieldRefs {
    readonly id: FieldRef<"profile", 'String'>
    readonly profile_image: FieldRef<"profile", 'String'>
    readonly profile_preference: FieldRef<"profile", 'String'>
    readonly created_at: FieldRef<"profile", 'DateTime'>
    readonly updated_at: FieldRef<"profile", 'DateTime'>
    readonly profile_username: FieldRef<"profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }

  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profile createManyAndReturn
   */
  export type profileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
  }

  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }

  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
  }

  /**
   * profile without action
   */
  export type profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
  }


  /**
   * Model collection_preview
   */

  export type AggregateCollection_preview = {
    _count: Collection_previewCountAggregateOutputType | null
    _avg: Collection_previewAvgAggregateOutputType | null
    _sum: Collection_previewSumAggregateOutputType | null
    _min: Collection_previewMinAggregateOutputType | null
    _max: Collection_previewMaxAggregateOutputType | null
  }

  export type Collection_previewAvgAggregateOutputType = {
    id: number | null
    max_generations: number | null
    total_generations: number | null
  }

  export type Collection_previewSumAggregateOutputType = {
    id: bigint | null
    max_generations: number | null
    total_generations: number | null
  }

  export type Collection_previewMinAggregateOutputType = {
    id: bigint | null
    enabled: boolean | null
    max_generations: number | null
    total_generations: number | null
    collection_id: string | null
    access_level: string | null
    is_remixable: boolean | null
    farcaster_collection: boolean | null
  }

  export type Collection_previewMaxAggregateOutputType = {
    id: bigint | null
    enabled: boolean | null
    max_generations: number | null
    total_generations: number | null
    collection_id: string | null
    access_level: string | null
    is_remixable: boolean | null
    farcaster_collection: boolean | null
  }

  export type Collection_previewCountAggregateOutputType = {
    id: number
    enabled: number
    max_generations: number
    total_generations: number
    collection_id: number
    access_level: number
    is_remixable: number
    farcaster_collection: number
    _all: number
  }


  export type Collection_previewAvgAggregateInputType = {
    id?: true
    max_generations?: true
    total_generations?: true
  }

  export type Collection_previewSumAggregateInputType = {
    id?: true
    max_generations?: true
    total_generations?: true
  }

  export type Collection_previewMinAggregateInputType = {
    id?: true
    enabled?: true
    max_generations?: true
    total_generations?: true
    collection_id?: true
    access_level?: true
    is_remixable?: true
    farcaster_collection?: true
  }

  export type Collection_previewMaxAggregateInputType = {
    id?: true
    enabled?: true
    max_generations?: true
    total_generations?: true
    collection_id?: true
    access_level?: true
    is_remixable?: true
    farcaster_collection?: true
  }

  export type Collection_previewCountAggregateInputType = {
    id?: true
    enabled?: true
    max_generations?: true
    total_generations?: true
    collection_id?: true
    access_level?: true
    is_remixable?: true
    farcaster_collection?: true
    _all?: true
  }

  export type Collection_previewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_preview to aggregate.
     */
    where?: collection_previewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_previews to fetch.
     */
    orderBy?: collection_previewOrderByWithRelationInput | collection_previewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_previewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_previews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_previews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_previews
    **/
    _count?: true | Collection_previewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_previewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_previewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_previewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_previewMaxAggregateInputType
  }

  export type GetCollection_previewAggregateType<T extends Collection_previewAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_preview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_preview[P]>
      : GetScalarType<T[P], AggregateCollection_preview[P]>
  }




  export type collection_previewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_previewWhereInput
    orderBy?: collection_previewOrderByWithAggregationInput | collection_previewOrderByWithAggregationInput[]
    by: Collection_previewScalarFieldEnum[] | Collection_previewScalarFieldEnum
    having?: collection_previewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_previewCountAggregateInputType | true
    _avg?: Collection_previewAvgAggregateInputType
    _sum?: Collection_previewSumAggregateInputType
    _min?: Collection_previewMinAggregateInputType
    _max?: Collection_previewMaxAggregateInputType
  }

  export type Collection_previewGroupByOutputType = {
    id: bigint
    enabled: boolean
    max_generations: number
    total_generations: number
    collection_id: string
    access_level: string
    is_remixable: boolean
    farcaster_collection: boolean
    _count: Collection_previewCountAggregateOutputType | null
    _avg: Collection_previewAvgAggregateOutputType | null
    _sum: Collection_previewSumAggregateOutputType | null
    _min: Collection_previewMinAggregateOutputType | null
    _max: Collection_previewMaxAggregateOutputType | null
  }

  type GetCollection_previewGroupByPayload<T extends collection_previewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_previewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_previewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_previewGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_previewGroupByOutputType[P]>
        }
      >
    >


  export type collection_previewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    max_generations?: boolean
    total_generations?: boolean
    collection_id?: boolean
    access_level?: boolean
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    collection_preview_version?: boolean | collection_preview$collection_preview_versionArgs<ExtArgs>
    _count?: boolean | Collection_previewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_preview"]>

  export type collection_previewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    max_generations?: boolean
    total_generations?: boolean
    collection_id?: boolean
    access_level?: boolean
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_preview"]>

  export type collection_previewSelectScalar = {
    id?: boolean
    enabled?: boolean
    max_generations?: boolean
    total_generations?: boolean
    collection_id?: boolean
    access_level?: boolean
    is_remixable?: boolean
    farcaster_collection?: boolean
  }

  export type collection_previewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    collection_preview_version?: boolean | collection_preview$collection_preview_versionArgs<ExtArgs>
    _count?: boolean | Collection_previewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type collection_previewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $collection_previewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_preview"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
      collection_preview_version: Prisma.$collection_preview_versionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      enabled: boolean
      max_generations: number
      total_generations: number
      collection_id: string
      access_level: string
      is_remixable: boolean
      farcaster_collection: boolean
    }, ExtArgs["result"]["collection_preview"]>
    composites: {}
  }

  type collection_previewGetPayload<S extends boolean | null | undefined | collection_previewDefaultArgs> = $Result.GetResult<Prisma.$collection_previewPayload, S>

  type collection_previewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_previewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_previewCountAggregateInputType | true
    }

  export interface collection_previewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_preview'], meta: { name: 'collection_preview' } }
    /**
     * Find zero or one Collection_preview that matches the filter.
     * @param {collection_previewFindUniqueArgs} args - Arguments to find a Collection_preview
     * @example
     * // Get one Collection_preview
     * const collection_preview = await prisma.collection_preview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_previewFindUniqueArgs>(args: SelectSubset<T, collection_previewFindUniqueArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_preview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_previewFindUniqueOrThrowArgs} args - Arguments to find a Collection_preview
     * @example
     * // Get one Collection_preview
     * const collection_preview = await prisma.collection_preview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_previewFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_previewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_preview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_previewFindFirstArgs} args - Arguments to find a Collection_preview
     * @example
     * // Get one Collection_preview
     * const collection_preview = await prisma.collection_preview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_previewFindFirstArgs>(args?: SelectSubset<T, collection_previewFindFirstArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_preview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_previewFindFirstOrThrowArgs} args - Arguments to find a Collection_preview
     * @example
     * // Get one Collection_preview
     * const collection_preview = await prisma.collection_preview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_previewFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_previewFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_previews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_previewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_previews
     * const collection_previews = await prisma.collection_preview.findMany()
     * 
     * // Get first 10 Collection_previews
     * const collection_previews = await prisma.collection_preview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_previewWithIdOnly = await prisma.collection_preview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_previewFindManyArgs>(args?: SelectSubset<T, collection_previewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_preview.
     * @param {collection_previewCreateArgs} args - Arguments to create a Collection_preview.
     * @example
     * // Create one Collection_preview
     * const Collection_preview = await prisma.collection_preview.create({
     *   data: {
     *     // ... data to create a Collection_preview
     *   }
     * })
     * 
     */
    create<T extends collection_previewCreateArgs>(args: SelectSubset<T, collection_previewCreateArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_previews.
     * @param {collection_previewCreateManyArgs} args - Arguments to create many Collection_previews.
     * @example
     * // Create many Collection_previews
     * const collection_preview = await prisma.collection_preview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_previewCreateManyArgs>(args?: SelectSubset<T, collection_previewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_previews and returns the data saved in the database.
     * @param {collection_previewCreateManyAndReturnArgs} args - Arguments to create many Collection_previews.
     * @example
     * // Create many Collection_previews
     * const collection_preview = await prisma.collection_preview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_previews and only return the `id`
     * const collection_previewWithIdOnly = await prisma.collection_preview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_previewCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_previewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_preview.
     * @param {collection_previewDeleteArgs} args - Arguments to delete one Collection_preview.
     * @example
     * // Delete one Collection_preview
     * const Collection_preview = await prisma.collection_preview.delete({
     *   where: {
     *     // ... filter to delete one Collection_preview
     *   }
     * })
     * 
     */
    delete<T extends collection_previewDeleteArgs>(args: SelectSubset<T, collection_previewDeleteArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_preview.
     * @param {collection_previewUpdateArgs} args - Arguments to update one Collection_preview.
     * @example
     * // Update one Collection_preview
     * const collection_preview = await prisma.collection_preview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_previewUpdateArgs>(args: SelectSubset<T, collection_previewUpdateArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_previews.
     * @param {collection_previewDeleteManyArgs} args - Arguments to filter Collection_previews to delete.
     * @example
     * // Delete a few Collection_previews
     * const { count } = await prisma.collection_preview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_previewDeleteManyArgs>(args?: SelectSubset<T, collection_previewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_previews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_previewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_previews
     * const collection_preview = await prisma.collection_preview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_previewUpdateManyArgs>(args: SelectSubset<T, collection_previewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_preview.
     * @param {collection_previewUpsertArgs} args - Arguments to update or create a Collection_preview.
     * @example
     * // Update or create a Collection_preview
     * const collection_preview = await prisma.collection_preview.upsert({
     *   create: {
     *     // ... data to create a Collection_preview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_preview we want to update
     *   }
     * })
     */
    upsert<T extends collection_previewUpsertArgs>(args: SelectSubset<T, collection_previewUpsertArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_previews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_previewCountArgs} args - Arguments to filter Collection_previews to count.
     * @example
     * // Count the number of Collection_previews
     * const count = await prisma.collection_preview.count({
     *   where: {
     *     // ... the filter for the Collection_previews we want to count
     *   }
     * })
    **/
    count<T extends collection_previewCountArgs>(
      args?: Subset<T, collection_previewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_previewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_preview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_previewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_previewAggregateArgs>(args: Subset<T, Collection_previewAggregateArgs>): Prisma.PrismaPromise<GetCollection_previewAggregateType<T>>

    /**
     * Group by Collection_preview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_previewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_previewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_previewGroupByArgs['orderBy'] }
        : { orderBy?: collection_previewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_previewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_previewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_preview model
   */
  readonly fields: collection_previewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_preview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_previewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    collection_preview_version<T extends collection_preview$collection_preview_versionArgs<ExtArgs> = {}>(args?: Subset<T, collection_preview$collection_preview_versionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_preview model
   */ 
  interface collection_previewFieldRefs {
    readonly id: FieldRef<"collection_preview", 'BigInt'>
    readonly enabled: FieldRef<"collection_preview", 'Boolean'>
    readonly max_generations: FieldRef<"collection_preview", 'Int'>
    readonly total_generations: FieldRef<"collection_preview", 'Int'>
    readonly collection_id: FieldRef<"collection_preview", 'String'>
    readonly access_level: FieldRef<"collection_preview", 'String'>
    readonly is_remixable: FieldRef<"collection_preview", 'Boolean'>
    readonly farcaster_collection: FieldRef<"collection_preview", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * collection_preview findUnique
   */
  export type collection_previewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview to fetch.
     */
    where: collection_previewWhereUniqueInput
  }

  /**
   * collection_preview findUniqueOrThrow
   */
  export type collection_previewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview to fetch.
     */
    where: collection_previewWhereUniqueInput
  }

  /**
   * collection_preview findFirst
   */
  export type collection_previewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview to fetch.
     */
    where?: collection_previewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_previews to fetch.
     */
    orderBy?: collection_previewOrderByWithRelationInput | collection_previewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_previews.
     */
    cursor?: collection_previewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_previews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_previews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_previews.
     */
    distinct?: Collection_previewScalarFieldEnum | Collection_previewScalarFieldEnum[]
  }

  /**
   * collection_preview findFirstOrThrow
   */
  export type collection_previewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview to fetch.
     */
    where?: collection_previewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_previews to fetch.
     */
    orderBy?: collection_previewOrderByWithRelationInput | collection_previewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_previews.
     */
    cursor?: collection_previewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_previews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_previews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_previews.
     */
    distinct?: Collection_previewScalarFieldEnum | Collection_previewScalarFieldEnum[]
  }

  /**
   * collection_preview findMany
   */
  export type collection_previewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * Filter, which collection_previews to fetch.
     */
    where?: collection_previewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_previews to fetch.
     */
    orderBy?: collection_previewOrderByWithRelationInput | collection_previewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_previews.
     */
    cursor?: collection_previewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_previews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_previews.
     */
    skip?: number
    distinct?: Collection_previewScalarFieldEnum | Collection_previewScalarFieldEnum[]
  }

  /**
   * collection_preview create
   */
  export type collection_previewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_preview.
     */
    data: XOR<collection_previewCreateInput, collection_previewUncheckedCreateInput>
  }

  /**
   * collection_preview createMany
   */
  export type collection_previewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_previews.
     */
    data: collection_previewCreateManyInput | collection_previewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_preview createManyAndReturn
   */
  export type collection_previewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_previews.
     */
    data: collection_previewCreateManyInput | collection_previewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_preview update
   */
  export type collection_previewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_preview.
     */
    data: XOR<collection_previewUpdateInput, collection_previewUncheckedUpdateInput>
    /**
     * Choose, which collection_preview to update.
     */
    where: collection_previewWhereUniqueInput
  }

  /**
   * collection_preview updateMany
   */
  export type collection_previewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_previews.
     */
    data: XOR<collection_previewUpdateManyMutationInput, collection_previewUncheckedUpdateManyInput>
    /**
     * Filter which collection_previews to update
     */
    where?: collection_previewWhereInput
  }

  /**
   * collection_preview upsert
   */
  export type collection_previewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_preview to update in case it exists.
     */
    where: collection_previewWhereUniqueInput
    /**
     * In case the collection_preview found by the `where` argument doesn't exist, create a new collection_preview with this data.
     */
    create: XOR<collection_previewCreateInput, collection_previewUncheckedCreateInput>
    /**
     * In case the collection_preview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_previewUpdateInput, collection_previewUncheckedUpdateInput>
  }

  /**
   * collection_preview delete
   */
  export type collection_previewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
    /**
     * Filter which collection_preview to delete.
     */
    where: collection_previewWhereUniqueInput
  }

  /**
   * collection_preview deleteMany
   */
  export type collection_previewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_previews to delete
     */
    where?: collection_previewWhereInput
  }

  /**
   * collection_preview.collection_preview_version
   */
  export type collection_preview$collection_preview_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    where?: collection_preview_versionWhereInput
    orderBy?: collection_preview_versionOrderByWithRelationInput | collection_preview_versionOrderByWithRelationInput[]
    cursor?: collection_preview_versionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_preview_versionScalarFieldEnum | Collection_preview_versionScalarFieldEnum[]
  }

  /**
   * collection_preview without action
   */
  export type collection_previewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview
     */
    select?: collection_previewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_previewInclude<ExtArgs> | null
  }


  /**
   * Model collection_preview_version
   */

  export type AggregateCollection_preview_version = {
    _count: Collection_preview_versionCountAggregateOutputType | null
    _avg: Collection_preview_versionAvgAggregateOutputType | null
    _sum: Collection_preview_versionSumAggregateOutputType | null
    _min: Collection_preview_versionMinAggregateOutputType | null
    _max: Collection_preview_versionMaxAggregateOutputType | null
  }

  export type Collection_preview_versionAvgAggregateOutputType = {
    id: number | null
    version: number | null
    collection_preview_id: number | null
  }

  export type Collection_preview_versionSumAggregateOutputType = {
    id: bigint | null
    version: number | null
    collection_preview_id: bigint | null
  }

  export type Collection_preview_versionMinAggregateOutputType = {
    id: bigint | null
    version: number | null
    collection_preview_id: bigint | null
    is_latest: boolean | null
    created_at: Date | null
  }

  export type Collection_preview_versionMaxAggregateOutputType = {
    id: bigint | null
    version: number | null
    collection_preview_id: bigint | null
    is_latest: boolean | null
    created_at: Date | null
  }

  export type Collection_preview_versionCountAggregateOutputType = {
    id: number
    version: number
    collection_preview_id: number
    data: number
    is_latest: number
    created_at: number
    _all: number
  }


  export type Collection_preview_versionAvgAggregateInputType = {
    id?: true
    version?: true
    collection_preview_id?: true
  }

  export type Collection_preview_versionSumAggregateInputType = {
    id?: true
    version?: true
    collection_preview_id?: true
  }

  export type Collection_preview_versionMinAggregateInputType = {
    id?: true
    version?: true
    collection_preview_id?: true
    is_latest?: true
    created_at?: true
  }

  export type Collection_preview_versionMaxAggregateInputType = {
    id?: true
    version?: true
    collection_preview_id?: true
    is_latest?: true
    created_at?: true
  }

  export type Collection_preview_versionCountAggregateInputType = {
    id?: true
    version?: true
    collection_preview_id?: true
    data?: true
    is_latest?: true
    created_at?: true
    _all?: true
  }

  export type Collection_preview_versionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_preview_version to aggregate.
     */
    where?: collection_preview_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_preview_versions to fetch.
     */
    orderBy?: collection_preview_versionOrderByWithRelationInput | collection_preview_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_preview_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_preview_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_preview_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_preview_versions
    **/
    _count?: true | Collection_preview_versionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_preview_versionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_preview_versionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_preview_versionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_preview_versionMaxAggregateInputType
  }

  export type GetCollection_preview_versionAggregateType<T extends Collection_preview_versionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_preview_version]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_preview_version[P]>
      : GetScalarType<T[P], AggregateCollection_preview_version[P]>
  }




  export type collection_preview_versionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_preview_versionWhereInput
    orderBy?: collection_preview_versionOrderByWithAggregationInput | collection_preview_versionOrderByWithAggregationInput[]
    by: Collection_preview_versionScalarFieldEnum[] | Collection_preview_versionScalarFieldEnum
    having?: collection_preview_versionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_preview_versionCountAggregateInputType | true
    _avg?: Collection_preview_versionAvgAggregateInputType
    _sum?: Collection_preview_versionSumAggregateInputType
    _min?: Collection_preview_versionMinAggregateInputType
    _max?: Collection_preview_versionMaxAggregateInputType
  }

  export type Collection_preview_versionGroupByOutputType = {
    id: bigint
    version: number
    collection_preview_id: bigint
    data: JsonValue
    is_latest: boolean
    created_at: Date | null
    _count: Collection_preview_versionCountAggregateOutputType | null
    _avg: Collection_preview_versionAvgAggregateOutputType | null
    _sum: Collection_preview_versionSumAggregateOutputType | null
    _min: Collection_preview_versionMinAggregateOutputType | null
    _max: Collection_preview_versionMaxAggregateOutputType | null
  }

  type GetCollection_preview_versionGroupByPayload<T extends collection_preview_versionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_preview_versionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_preview_versionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_preview_versionGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_preview_versionGroupByOutputType[P]>
        }
      >
    >


  export type collection_preview_versionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    collection_preview_id?: boolean
    data?: boolean
    is_latest?: boolean
    created_at?: boolean
    collection_preview?: boolean | collection_previewDefaultArgs<ExtArgs>
    collection_remix?: boolean | collection_preview_version$collection_remixArgs<ExtArgs>
    _count?: boolean | Collection_preview_versionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_preview_version"]>

  export type collection_preview_versionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    collection_preview_id?: boolean
    data?: boolean
    is_latest?: boolean
    created_at?: boolean
    collection_preview?: boolean | collection_previewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_preview_version"]>

  export type collection_preview_versionSelectScalar = {
    id?: boolean
    version?: boolean
    collection_preview_id?: boolean
    data?: boolean
    is_latest?: boolean
    created_at?: boolean
  }

  export type collection_preview_versionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_preview?: boolean | collection_previewDefaultArgs<ExtArgs>
    collection_remix?: boolean | collection_preview_version$collection_remixArgs<ExtArgs>
    _count?: boolean | Collection_preview_versionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type collection_preview_versionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_preview?: boolean | collection_previewDefaultArgs<ExtArgs>
  }

  export type $collection_preview_versionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_preview_version"
    objects: {
      collection_preview: Prisma.$collection_previewPayload<ExtArgs>
      collection_remix: Prisma.$collection_remixPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      version: number
      collection_preview_id: bigint
      data: Prisma.JsonValue
      is_latest: boolean
      created_at: Date | null
    }, ExtArgs["result"]["collection_preview_version"]>
    composites: {}
  }

  type collection_preview_versionGetPayload<S extends boolean | null | undefined | collection_preview_versionDefaultArgs> = $Result.GetResult<Prisma.$collection_preview_versionPayload, S>

  type collection_preview_versionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_preview_versionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_preview_versionCountAggregateInputType | true
    }

  export interface collection_preview_versionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_preview_version'], meta: { name: 'collection_preview_version' } }
    /**
     * Find zero or one Collection_preview_version that matches the filter.
     * @param {collection_preview_versionFindUniqueArgs} args - Arguments to find a Collection_preview_version
     * @example
     * // Get one Collection_preview_version
     * const collection_preview_version = await prisma.collection_preview_version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_preview_versionFindUniqueArgs>(args: SelectSubset<T, collection_preview_versionFindUniqueArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_preview_version that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_preview_versionFindUniqueOrThrowArgs} args - Arguments to find a Collection_preview_version
     * @example
     * // Get one Collection_preview_version
     * const collection_preview_version = await prisma.collection_preview_version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_preview_versionFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_preview_versionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_preview_version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_preview_versionFindFirstArgs} args - Arguments to find a Collection_preview_version
     * @example
     * // Get one Collection_preview_version
     * const collection_preview_version = await prisma.collection_preview_version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_preview_versionFindFirstArgs>(args?: SelectSubset<T, collection_preview_versionFindFirstArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_preview_version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_preview_versionFindFirstOrThrowArgs} args - Arguments to find a Collection_preview_version
     * @example
     * // Get one Collection_preview_version
     * const collection_preview_version = await prisma.collection_preview_version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_preview_versionFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_preview_versionFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_preview_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_preview_versionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_preview_versions
     * const collection_preview_versions = await prisma.collection_preview_version.findMany()
     * 
     * // Get first 10 Collection_preview_versions
     * const collection_preview_versions = await prisma.collection_preview_version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_preview_versionWithIdOnly = await prisma.collection_preview_version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_preview_versionFindManyArgs>(args?: SelectSubset<T, collection_preview_versionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_preview_version.
     * @param {collection_preview_versionCreateArgs} args - Arguments to create a Collection_preview_version.
     * @example
     * // Create one Collection_preview_version
     * const Collection_preview_version = await prisma.collection_preview_version.create({
     *   data: {
     *     // ... data to create a Collection_preview_version
     *   }
     * })
     * 
     */
    create<T extends collection_preview_versionCreateArgs>(args: SelectSubset<T, collection_preview_versionCreateArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_preview_versions.
     * @param {collection_preview_versionCreateManyArgs} args - Arguments to create many Collection_preview_versions.
     * @example
     * // Create many Collection_preview_versions
     * const collection_preview_version = await prisma.collection_preview_version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_preview_versionCreateManyArgs>(args?: SelectSubset<T, collection_preview_versionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_preview_versions and returns the data saved in the database.
     * @param {collection_preview_versionCreateManyAndReturnArgs} args - Arguments to create many Collection_preview_versions.
     * @example
     * // Create many Collection_preview_versions
     * const collection_preview_version = await prisma.collection_preview_version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_preview_versions and only return the `id`
     * const collection_preview_versionWithIdOnly = await prisma.collection_preview_version.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_preview_versionCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_preview_versionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_preview_version.
     * @param {collection_preview_versionDeleteArgs} args - Arguments to delete one Collection_preview_version.
     * @example
     * // Delete one Collection_preview_version
     * const Collection_preview_version = await prisma.collection_preview_version.delete({
     *   where: {
     *     // ... filter to delete one Collection_preview_version
     *   }
     * })
     * 
     */
    delete<T extends collection_preview_versionDeleteArgs>(args: SelectSubset<T, collection_preview_versionDeleteArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_preview_version.
     * @param {collection_preview_versionUpdateArgs} args - Arguments to update one Collection_preview_version.
     * @example
     * // Update one Collection_preview_version
     * const collection_preview_version = await prisma.collection_preview_version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_preview_versionUpdateArgs>(args: SelectSubset<T, collection_preview_versionUpdateArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_preview_versions.
     * @param {collection_preview_versionDeleteManyArgs} args - Arguments to filter Collection_preview_versions to delete.
     * @example
     * // Delete a few Collection_preview_versions
     * const { count } = await prisma.collection_preview_version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_preview_versionDeleteManyArgs>(args?: SelectSubset<T, collection_preview_versionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_preview_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_preview_versionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_preview_versions
     * const collection_preview_version = await prisma.collection_preview_version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_preview_versionUpdateManyArgs>(args: SelectSubset<T, collection_preview_versionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_preview_version.
     * @param {collection_preview_versionUpsertArgs} args - Arguments to update or create a Collection_preview_version.
     * @example
     * // Update or create a Collection_preview_version
     * const collection_preview_version = await prisma.collection_preview_version.upsert({
     *   create: {
     *     // ... data to create a Collection_preview_version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_preview_version we want to update
     *   }
     * })
     */
    upsert<T extends collection_preview_versionUpsertArgs>(args: SelectSubset<T, collection_preview_versionUpsertArgs<ExtArgs>>): Prisma__collection_preview_versionClient<$Result.GetResult<Prisma.$collection_preview_versionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_preview_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_preview_versionCountArgs} args - Arguments to filter Collection_preview_versions to count.
     * @example
     * // Count the number of Collection_preview_versions
     * const count = await prisma.collection_preview_version.count({
     *   where: {
     *     // ... the filter for the Collection_preview_versions we want to count
     *   }
     * })
    **/
    count<T extends collection_preview_versionCountArgs>(
      args?: Subset<T, collection_preview_versionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_preview_versionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_preview_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_preview_versionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_preview_versionAggregateArgs>(args: Subset<T, Collection_preview_versionAggregateArgs>): Prisma.PrismaPromise<GetCollection_preview_versionAggregateType<T>>

    /**
     * Group by Collection_preview_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_preview_versionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_preview_versionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_preview_versionGroupByArgs['orderBy'] }
        : { orderBy?: collection_preview_versionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_preview_versionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_preview_versionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_preview_version model
   */
  readonly fields: collection_preview_versionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_preview_version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_preview_versionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_preview<T extends collection_previewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collection_previewDefaultArgs<ExtArgs>>): Prisma__collection_previewClient<$Result.GetResult<Prisma.$collection_previewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    collection_remix<T extends collection_preview_version$collection_remixArgs<ExtArgs> = {}>(args?: Subset<T, collection_preview_version$collection_remixArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_remixPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_preview_version model
   */ 
  interface collection_preview_versionFieldRefs {
    readonly id: FieldRef<"collection_preview_version", 'BigInt'>
    readonly version: FieldRef<"collection_preview_version", 'Int'>
    readonly collection_preview_id: FieldRef<"collection_preview_version", 'BigInt'>
    readonly data: FieldRef<"collection_preview_version", 'Json'>
    readonly is_latest: FieldRef<"collection_preview_version", 'Boolean'>
    readonly created_at: FieldRef<"collection_preview_version", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * collection_preview_version findUnique
   */
  export type collection_preview_versionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview_version to fetch.
     */
    where: collection_preview_versionWhereUniqueInput
  }

  /**
   * collection_preview_version findUniqueOrThrow
   */
  export type collection_preview_versionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview_version to fetch.
     */
    where: collection_preview_versionWhereUniqueInput
  }

  /**
   * collection_preview_version findFirst
   */
  export type collection_preview_versionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview_version to fetch.
     */
    where?: collection_preview_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_preview_versions to fetch.
     */
    orderBy?: collection_preview_versionOrderByWithRelationInput | collection_preview_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_preview_versions.
     */
    cursor?: collection_preview_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_preview_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_preview_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_preview_versions.
     */
    distinct?: Collection_preview_versionScalarFieldEnum | Collection_preview_versionScalarFieldEnum[]
  }

  /**
   * collection_preview_version findFirstOrThrow
   */
  export type collection_preview_versionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview_version to fetch.
     */
    where?: collection_preview_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_preview_versions to fetch.
     */
    orderBy?: collection_preview_versionOrderByWithRelationInput | collection_preview_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_preview_versions.
     */
    cursor?: collection_preview_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_preview_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_preview_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_preview_versions.
     */
    distinct?: Collection_preview_versionScalarFieldEnum | Collection_preview_versionScalarFieldEnum[]
  }

  /**
   * collection_preview_version findMany
   */
  export type collection_preview_versionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * Filter, which collection_preview_versions to fetch.
     */
    where?: collection_preview_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_preview_versions to fetch.
     */
    orderBy?: collection_preview_versionOrderByWithRelationInput | collection_preview_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_preview_versions.
     */
    cursor?: collection_preview_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_preview_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_preview_versions.
     */
    skip?: number
    distinct?: Collection_preview_versionScalarFieldEnum | Collection_preview_versionScalarFieldEnum[]
  }

  /**
   * collection_preview_version create
   */
  export type collection_preview_versionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_preview_version.
     */
    data: XOR<collection_preview_versionCreateInput, collection_preview_versionUncheckedCreateInput>
  }

  /**
   * collection_preview_version createMany
   */
  export type collection_preview_versionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_preview_versions.
     */
    data: collection_preview_versionCreateManyInput | collection_preview_versionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_preview_version createManyAndReturn
   */
  export type collection_preview_versionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_preview_versions.
     */
    data: collection_preview_versionCreateManyInput | collection_preview_versionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_preview_version update
   */
  export type collection_preview_versionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_preview_version.
     */
    data: XOR<collection_preview_versionUpdateInput, collection_preview_versionUncheckedUpdateInput>
    /**
     * Choose, which collection_preview_version to update.
     */
    where: collection_preview_versionWhereUniqueInput
  }

  /**
   * collection_preview_version updateMany
   */
  export type collection_preview_versionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_preview_versions.
     */
    data: XOR<collection_preview_versionUpdateManyMutationInput, collection_preview_versionUncheckedUpdateManyInput>
    /**
     * Filter which collection_preview_versions to update
     */
    where?: collection_preview_versionWhereInput
  }

  /**
   * collection_preview_version upsert
   */
  export type collection_preview_versionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_preview_version to update in case it exists.
     */
    where: collection_preview_versionWhereUniqueInput
    /**
     * In case the collection_preview_version found by the `where` argument doesn't exist, create a new collection_preview_version with this data.
     */
    create: XOR<collection_preview_versionCreateInput, collection_preview_versionUncheckedCreateInput>
    /**
     * In case the collection_preview_version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_preview_versionUpdateInput, collection_preview_versionUncheckedUpdateInput>
  }

  /**
   * collection_preview_version delete
   */
  export type collection_preview_versionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
    /**
     * Filter which collection_preview_version to delete.
     */
    where: collection_preview_versionWhereUniqueInput
  }

  /**
   * collection_preview_version deleteMany
   */
  export type collection_preview_versionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_preview_versions to delete
     */
    where?: collection_preview_versionWhereInput
  }

  /**
   * collection_preview_version.collection_remix
   */
  export type collection_preview_version$collection_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_remix
     */
    select?: collection_remixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_remixInclude<ExtArgs> | null
    where?: collection_remixWhereInput
    orderBy?: collection_remixOrderByWithRelationInput | collection_remixOrderByWithRelationInput[]
    cursor?: collection_remixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Collection_remixScalarFieldEnum | Collection_remixScalarFieldEnum[]
  }

  /**
   * collection_preview_version without action
   */
  export type collection_preview_versionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_preview_version
     */
    select?: collection_preview_versionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_preview_versionInclude<ExtArgs> | null
  }


  /**
   * Model collection_sample_images
   */

  export type AggregateCollection_sample_images = {
    _count: Collection_sample_imagesCountAggregateOutputType | null
    _avg: Collection_sample_imagesAvgAggregateOutputType | null
    _sum: Collection_sample_imagesSumAggregateOutputType | null
    _min: Collection_sample_imagesMinAggregateOutputType | null
    _max: Collection_sample_imagesMaxAggregateOutputType | null
  }

  export type Collection_sample_imagesAvgAggregateOutputType = {
    id: number | null
  }

  export type Collection_sample_imagesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Collection_sample_imagesMinAggregateOutputType = {
    id: bigint | null
    url: string | null
    collection_id: string | null
  }

  export type Collection_sample_imagesMaxAggregateOutputType = {
    id: bigint | null
    url: string | null
    collection_id: string | null
  }

  export type Collection_sample_imagesCountAggregateOutputType = {
    id: number
    url: number
    collection_id: number
    _all: number
  }


  export type Collection_sample_imagesAvgAggregateInputType = {
    id?: true
  }

  export type Collection_sample_imagesSumAggregateInputType = {
    id?: true
  }

  export type Collection_sample_imagesMinAggregateInputType = {
    id?: true
    url?: true
    collection_id?: true
  }

  export type Collection_sample_imagesMaxAggregateInputType = {
    id?: true
    url?: true
    collection_id?: true
  }

  export type Collection_sample_imagesCountAggregateInputType = {
    id?: true
    url?: true
    collection_id?: true
    _all?: true
  }

  export type Collection_sample_imagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_sample_images to aggregate.
     */
    where?: collection_sample_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sample_images to fetch.
     */
    orderBy?: collection_sample_imagesOrderByWithRelationInput | collection_sample_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collection_sample_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sample_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sample_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collection_sample_images
    **/
    _count?: true | Collection_sample_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collection_sample_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collection_sample_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collection_sample_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collection_sample_imagesMaxAggregateInputType
  }

  export type GetCollection_sample_imagesAggregateType<T extends Collection_sample_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection_sample_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection_sample_images[P]>
      : GetScalarType<T[P], AggregateCollection_sample_images[P]>
  }




  export type collection_sample_imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collection_sample_imagesWhereInput
    orderBy?: collection_sample_imagesOrderByWithAggregationInput | collection_sample_imagesOrderByWithAggregationInput[]
    by: Collection_sample_imagesScalarFieldEnum[] | Collection_sample_imagesScalarFieldEnum
    having?: collection_sample_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collection_sample_imagesCountAggregateInputType | true
    _avg?: Collection_sample_imagesAvgAggregateInputType
    _sum?: Collection_sample_imagesSumAggregateInputType
    _min?: Collection_sample_imagesMinAggregateInputType
    _max?: Collection_sample_imagesMaxAggregateInputType
  }

  export type Collection_sample_imagesGroupByOutputType = {
    id: bigint
    url: string
    collection_id: string
    _count: Collection_sample_imagesCountAggregateOutputType | null
    _avg: Collection_sample_imagesAvgAggregateOutputType | null
    _sum: Collection_sample_imagesSumAggregateOutputType | null
    _min: Collection_sample_imagesMinAggregateOutputType | null
    _max: Collection_sample_imagesMaxAggregateOutputType | null
  }

  type GetCollection_sample_imagesGroupByPayload<T extends collection_sample_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collection_sample_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collection_sample_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collection_sample_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Collection_sample_imagesGroupByOutputType[P]>
        }
      >
    >


  export type collection_sample_imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    collection_id?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_sample_images"]>

  export type collection_sample_imagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    collection_id?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection_sample_images"]>

  export type collection_sample_imagesSelectScalar = {
    id?: boolean
    url?: boolean
    collection_id?: boolean
  }

  export type collection_sample_imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }
  export type collection_sample_imagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $collection_sample_imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collection_sample_images"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      url: string
      collection_id: string
    }, ExtArgs["result"]["collection_sample_images"]>
    composites: {}
  }

  type collection_sample_imagesGetPayload<S extends boolean | null | undefined | collection_sample_imagesDefaultArgs> = $Result.GetResult<Prisma.$collection_sample_imagesPayload, S>

  type collection_sample_imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collection_sample_imagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Collection_sample_imagesCountAggregateInputType | true
    }

  export interface collection_sample_imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collection_sample_images'], meta: { name: 'collection_sample_images' } }
    /**
     * Find zero or one Collection_sample_images that matches the filter.
     * @param {collection_sample_imagesFindUniqueArgs} args - Arguments to find a Collection_sample_images
     * @example
     * // Get one Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collection_sample_imagesFindUniqueArgs>(args: SelectSubset<T, collection_sample_imagesFindUniqueArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection_sample_images that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collection_sample_imagesFindUniqueOrThrowArgs} args - Arguments to find a Collection_sample_images
     * @example
     * // Get one Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collection_sample_imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, collection_sample_imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection_sample_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sample_imagesFindFirstArgs} args - Arguments to find a Collection_sample_images
     * @example
     * // Get one Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collection_sample_imagesFindFirstArgs>(args?: SelectSubset<T, collection_sample_imagesFindFirstArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection_sample_images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sample_imagesFindFirstOrThrowArgs} args - Arguments to find a Collection_sample_images
     * @example
     * // Get one Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collection_sample_imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, collection_sample_imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collection_sample_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sample_imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.findMany()
     * 
     * // Get first 10 Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collection_sample_imagesWithIdOnly = await prisma.collection_sample_images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collection_sample_imagesFindManyArgs>(args?: SelectSubset<T, collection_sample_imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection_sample_images.
     * @param {collection_sample_imagesCreateArgs} args - Arguments to create a Collection_sample_images.
     * @example
     * // Create one Collection_sample_images
     * const Collection_sample_images = await prisma.collection_sample_images.create({
     *   data: {
     *     // ... data to create a Collection_sample_images
     *   }
     * })
     * 
     */
    create<T extends collection_sample_imagesCreateArgs>(args: SelectSubset<T, collection_sample_imagesCreateArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collection_sample_images.
     * @param {collection_sample_imagesCreateManyArgs} args - Arguments to create many Collection_sample_images.
     * @example
     * // Create many Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collection_sample_imagesCreateManyArgs>(args?: SelectSubset<T, collection_sample_imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collection_sample_images and returns the data saved in the database.
     * @param {collection_sample_imagesCreateManyAndReturnArgs} args - Arguments to create many Collection_sample_images.
     * @example
     * // Create many Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collection_sample_images and only return the `id`
     * const collection_sample_imagesWithIdOnly = await prisma.collection_sample_images.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collection_sample_imagesCreateManyAndReturnArgs>(args?: SelectSubset<T, collection_sample_imagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection_sample_images.
     * @param {collection_sample_imagesDeleteArgs} args - Arguments to delete one Collection_sample_images.
     * @example
     * // Delete one Collection_sample_images
     * const Collection_sample_images = await prisma.collection_sample_images.delete({
     *   where: {
     *     // ... filter to delete one Collection_sample_images
     *   }
     * })
     * 
     */
    delete<T extends collection_sample_imagesDeleteArgs>(args: SelectSubset<T, collection_sample_imagesDeleteArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection_sample_images.
     * @param {collection_sample_imagesUpdateArgs} args - Arguments to update one Collection_sample_images.
     * @example
     * // Update one Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collection_sample_imagesUpdateArgs>(args: SelectSubset<T, collection_sample_imagesUpdateArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collection_sample_images.
     * @param {collection_sample_imagesDeleteManyArgs} args - Arguments to filter Collection_sample_images to delete.
     * @example
     * // Delete a few Collection_sample_images
     * const { count } = await prisma.collection_sample_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collection_sample_imagesDeleteManyArgs>(args?: SelectSubset<T, collection_sample_imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collection_sample_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sample_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collection_sample_imagesUpdateManyArgs>(args: SelectSubset<T, collection_sample_imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection_sample_images.
     * @param {collection_sample_imagesUpsertArgs} args - Arguments to update or create a Collection_sample_images.
     * @example
     * // Update or create a Collection_sample_images
     * const collection_sample_images = await prisma.collection_sample_images.upsert({
     *   create: {
     *     // ... data to create a Collection_sample_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection_sample_images we want to update
     *   }
     * })
     */
    upsert<T extends collection_sample_imagesUpsertArgs>(args: SelectSubset<T, collection_sample_imagesUpsertArgs<ExtArgs>>): Prisma__collection_sample_imagesClient<$Result.GetResult<Prisma.$collection_sample_imagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collection_sample_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sample_imagesCountArgs} args - Arguments to filter Collection_sample_images to count.
     * @example
     * // Count the number of Collection_sample_images
     * const count = await prisma.collection_sample_images.count({
     *   where: {
     *     // ... the filter for the Collection_sample_images we want to count
     *   }
     * })
    **/
    count<T extends collection_sample_imagesCountArgs>(
      args?: Subset<T, collection_sample_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collection_sample_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection_sample_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collection_sample_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collection_sample_imagesAggregateArgs>(args: Subset<T, Collection_sample_imagesAggregateArgs>): Prisma.PrismaPromise<GetCollection_sample_imagesAggregateType<T>>

    /**
     * Group by Collection_sample_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collection_sample_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collection_sample_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collection_sample_imagesGroupByArgs['orderBy'] }
        : { orderBy?: collection_sample_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collection_sample_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollection_sample_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collection_sample_images model
   */
  readonly fields: collection_sample_imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collection_sample_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collection_sample_imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collection_sample_images model
   */ 
  interface collection_sample_imagesFieldRefs {
    readonly id: FieldRef<"collection_sample_images", 'BigInt'>
    readonly url: FieldRef<"collection_sample_images", 'String'>
    readonly collection_id: FieldRef<"collection_sample_images", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collection_sample_images findUnique
   */
  export type collection_sample_imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * Filter, which collection_sample_images to fetch.
     */
    where: collection_sample_imagesWhereUniqueInput
  }

  /**
   * collection_sample_images findUniqueOrThrow
   */
  export type collection_sample_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * Filter, which collection_sample_images to fetch.
     */
    where: collection_sample_imagesWhereUniqueInput
  }

  /**
   * collection_sample_images findFirst
   */
  export type collection_sample_imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * Filter, which collection_sample_images to fetch.
     */
    where?: collection_sample_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sample_images to fetch.
     */
    orderBy?: collection_sample_imagesOrderByWithRelationInput | collection_sample_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_sample_images.
     */
    cursor?: collection_sample_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sample_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sample_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_sample_images.
     */
    distinct?: Collection_sample_imagesScalarFieldEnum | Collection_sample_imagesScalarFieldEnum[]
  }

  /**
   * collection_sample_images findFirstOrThrow
   */
  export type collection_sample_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * Filter, which collection_sample_images to fetch.
     */
    where?: collection_sample_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sample_images to fetch.
     */
    orderBy?: collection_sample_imagesOrderByWithRelationInput | collection_sample_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collection_sample_images.
     */
    cursor?: collection_sample_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sample_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sample_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collection_sample_images.
     */
    distinct?: Collection_sample_imagesScalarFieldEnum | Collection_sample_imagesScalarFieldEnum[]
  }

  /**
   * collection_sample_images findMany
   */
  export type collection_sample_imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * Filter, which collection_sample_images to fetch.
     */
    where?: collection_sample_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collection_sample_images to fetch.
     */
    orderBy?: collection_sample_imagesOrderByWithRelationInput | collection_sample_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collection_sample_images.
     */
    cursor?: collection_sample_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collection_sample_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collection_sample_images.
     */
    skip?: number
    distinct?: Collection_sample_imagesScalarFieldEnum | Collection_sample_imagesScalarFieldEnum[]
  }

  /**
   * collection_sample_images create
   */
  export type collection_sample_imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a collection_sample_images.
     */
    data: XOR<collection_sample_imagesCreateInput, collection_sample_imagesUncheckedCreateInput>
  }

  /**
   * collection_sample_images createMany
   */
  export type collection_sample_imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collection_sample_images.
     */
    data: collection_sample_imagesCreateManyInput | collection_sample_imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collection_sample_images createManyAndReturn
   */
  export type collection_sample_imagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many collection_sample_images.
     */
    data: collection_sample_imagesCreateManyInput | collection_sample_imagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collection_sample_images update
   */
  export type collection_sample_imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a collection_sample_images.
     */
    data: XOR<collection_sample_imagesUpdateInput, collection_sample_imagesUncheckedUpdateInput>
    /**
     * Choose, which collection_sample_images to update.
     */
    where: collection_sample_imagesWhereUniqueInput
  }

  /**
   * collection_sample_images updateMany
   */
  export type collection_sample_imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collection_sample_images.
     */
    data: XOR<collection_sample_imagesUpdateManyMutationInput, collection_sample_imagesUncheckedUpdateManyInput>
    /**
     * Filter which collection_sample_images to update
     */
    where?: collection_sample_imagesWhereInput
  }

  /**
   * collection_sample_images upsert
   */
  export type collection_sample_imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the collection_sample_images to update in case it exists.
     */
    where: collection_sample_imagesWhereUniqueInput
    /**
     * In case the collection_sample_images found by the `where` argument doesn't exist, create a new collection_sample_images with this data.
     */
    create: XOR<collection_sample_imagesCreateInput, collection_sample_imagesUncheckedCreateInput>
    /**
     * In case the collection_sample_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collection_sample_imagesUpdateInput, collection_sample_imagesUncheckedUpdateInput>
  }

  /**
   * collection_sample_images delete
   */
  export type collection_sample_imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
    /**
     * Filter which collection_sample_images to delete.
     */
    where: collection_sample_imagesWhereUniqueInput
  }

  /**
   * collection_sample_images deleteMany
   */
  export type collection_sample_imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collection_sample_images to delete
     */
    where?: collection_sample_imagesWhereInput
  }

  /**
   * collection_sample_images without action
   */
  export type collection_sample_imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection_sample_images
     */
    select?: collection_sample_imagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collection_sample_imagesInclude<ExtArgs> | null
  }


  /**
   * Model chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    entity_type: string | null
    entity_id: string | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    entity_type: string | null
    entity_id: string | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    created_at: number
    entity_type: number
    entity_id: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    created_at?: true
    entity_type?: true
    entity_id?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    created_at?: true
    entity_type?: true
    entity_id?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    created_at?: true
    entity_type?: true
    entity_id?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat to aggregate.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type chatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatWhereInput
    orderBy?: chatOrderByWithAggregationInput | chatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: chatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    created_at: Date | null
    entity_type: string
    entity_id: string
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends chatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type chatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    entity_type?: boolean
    entity_id?: boolean
    chat_message?: boolean | chat$chat_messageArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type chatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    entity_type?: boolean
    entity_id?: boolean
  }, ExtArgs["result"]["chat"]>

  export type chatSelectScalar = {
    id?: boolean
    created_at?: boolean
    entity_type?: boolean
    entity_id?: boolean
  }

  export type chatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_message?: boolean | chat$chat_messageArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $chatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat"
    objects: {
      chat_message: Prisma.$chat_messagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date | null
      entity_type: string
      entity_id: string
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type chatGetPayload<S extends boolean | null | undefined | chatDefaultArgs> = $Result.GetResult<Prisma.$chatPayload, S>

  type chatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<chatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface chatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat'], meta: { name: 'chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {chatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatFindUniqueArgs>(args: SelectSubset<T, chatFindUniqueArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {chatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatFindUniqueOrThrowArgs>(args: SelectSubset<T, chatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatFindFirstArgs>(args?: SelectSubset<T, chatFindFirstArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatFindFirstOrThrowArgs>(args?: SelectSubset<T, chatFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatFindManyArgs>(args?: SelectSubset<T, chatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {chatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends chatCreateArgs>(args: SelectSubset<T, chatCreateArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {chatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatCreateManyArgs>(args?: SelectSubset<T, chatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {chatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatCreateManyAndReturnArgs>(args?: SelectSubset<T, chatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat.
     * @param {chatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends chatDeleteArgs>(args: SelectSubset<T, chatDeleteArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {chatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatUpdateArgs>(args: SelectSubset<T, chatUpdateArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {chatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatDeleteManyArgs>(args?: SelectSubset<T, chatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatUpdateManyArgs>(args: SelectSubset<T, chatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {chatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends chatUpsertArgs>(args: SelectSubset<T, chatUpsertArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends chatCountArgs>(
      args?: Subset<T, chatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatGroupByArgs['orderBy'] }
        : { orderBy?: chatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat model
   */
  readonly fields: chatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_message<T extends chat$chat_messageArgs<ExtArgs> = {}>(args?: Subset<T, chat$chat_messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat model
   */ 
  interface chatFieldRefs {
    readonly id: FieldRef<"chat", 'String'>
    readonly created_at: FieldRef<"chat", 'DateTime'>
    readonly entity_type: FieldRef<"chat", 'String'>
    readonly entity_id: FieldRef<"chat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chat findUnique
   */
  export type chatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat findUniqueOrThrow
   */
  export type chatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat findFirst
   */
  export type chatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * chat findFirstOrThrow
   */
  export type chatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * Filter, which chat to fetch.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * chat findMany
   */
  export type chatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatOrderByWithRelationInput | chatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chats.
     */
    cursor?: chatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * chat create
   */
  export type chatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * The data needed to create a chat.
     */
    data: XOR<chatCreateInput, chatUncheckedCreateInput>
  }

  /**
   * chat createMany
   */
  export type chatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chats.
     */
    data: chatCreateManyInput | chatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat createManyAndReturn
   */
  export type chatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many chats.
     */
    data: chatCreateManyInput | chatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat update
   */
  export type chatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * The data needed to update a chat.
     */
    data: XOR<chatUpdateInput, chatUncheckedUpdateInput>
    /**
     * Choose, which chat to update.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat updateMany
   */
  export type chatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chats.
     */
    data: XOR<chatUpdateManyMutationInput, chatUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatWhereInput
  }

  /**
   * chat upsert
   */
  export type chatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * The filter to search for the chat to update in case it exists.
     */
    where: chatWhereUniqueInput
    /**
     * In case the chat found by the `where` argument doesn't exist, create a new chat with this data.
     */
    create: XOR<chatCreateInput, chatUncheckedCreateInput>
    /**
     * In case the chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatUpdateInput, chatUncheckedUpdateInput>
  }

  /**
   * chat delete
   */
  export type chatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
    /**
     * Filter which chat to delete.
     */
    where: chatWhereUniqueInput
  }

  /**
   * chat deleteMany
   */
  export type chatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to delete
     */
    where?: chatWhereInput
  }

  /**
   * chat.chat_message
   */
  export type chat$chat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    where?: chat_messageWhereInput
    orderBy?: chat_messageOrderByWithRelationInput | chat_messageOrderByWithRelationInput[]
    cursor?: chat_messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messageScalarFieldEnum | Chat_messageScalarFieldEnum[]
  }

  /**
   * chat without action
   */
  export type chatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat
     */
    select?: chatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatInclude<ExtArgs> | null
  }


  /**
   * Model chat_message
   */

  export type AggregateChat_message = {
    _count: Chat_messageCountAggregateOutputType | null
    _avg: Chat_messageAvgAggregateOutputType | null
    _sum: Chat_messageSumAggregateOutputType | null
    _min: Chat_messageMinAggregateOutputType | null
    _max: Chat_messageMaxAggregateOutputType | null
  }

  export type Chat_messageAvgAggregateOutputType = {
    flat_file_id: number | null
  }

  export type Chat_messageSumAggregateOutputType = {
    flat_file_id: bigint | null
  }

  export type Chat_messageMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    content: string | null
    chat_id: string | null
    flat_file_id: bigint | null
  }

  export type Chat_messageMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    content: string | null
    chat_id: string | null
    flat_file_id: bigint | null
  }

  export type Chat_messageCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    user_id: number
    content: number
    chat_id: number
    flat_file_id: number
    _all: number
  }


  export type Chat_messageAvgAggregateInputType = {
    flat_file_id?: true
  }

  export type Chat_messageSumAggregateInputType = {
    flat_file_id?: true
  }

  export type Chat_messageMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    content?: true
    chat_id?: true
    flat_file_id?: true
  }

  export type Chat_messageMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    content?: true
    chat_id?: true
    flat_file_id?: true
  }

  export type Chat_messageCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    content?: true
    chat_id?: true
    flat_file_id?: true
    _all?: true
  }

  export type Chat_messageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_message to aggregate.
     */
    where?: chat_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messageOrderByWithRelationInput | chat_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_messages
    **/
    _count?: true | Chat_messageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_messageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_messageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_messageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_messageMaxAggregateInputType
  }

  export type GetChat_messageAggregateType<T extends Chat_messageAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_message]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_message[P]>
      : GetScalarType<T[P], AggregateChat_message[P]>
  }




  export type chat_messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messageWhereInput
    orderBy?: chat_messageOrderByWithAggregationInput | chat_messageOrderByWithAggregationInput[]
    by: Chat_messageScalarFieldEnum[] | Chat_messageScalarFieldEnum
    having?: chat_messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_messageCountAggregateInputType | true
    _avg?: Chat_messageAvgAggregateInputType
    _sum?: Chat_messageSumAggregateInputType
    _min?: Chat_messageMinAggregateInputType
    _max?: Chat_messageMaxAggregateInputType
  }

  export type Chat_messageGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    user_id: string
    content: string
    chat_id: string
    flat_file_id: bigint | null
    _count: Chat_messageCountAggregateOutputType | null
    _avg: Chat_messageAvgAggregateOutputType | null
    _sum: Chat_messageSumAggregateOutputType | null
    _min: Chat_messageMinAggregateOutputType | null
    _max: Chat_messageMaxAggregateOutputType | null
  }

  type GetChat_messageGroupByPayload<T extends chat_messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_messageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_messageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_messageGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_messageGroupByOutputType[P]>
        }
      >
    >


  export type chat_messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    content?: boolean
    chat_id?: boolean
    flat_file_id?: boolean
    chat?: boolean | chatDefaultArgs<ExtArgs>
    flat_file?: boolean | chat_message$flat_fileArgs<ExtArgs>
  }, ExtArgs["result"]["chat_message"]>

  export type chat_messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    content?: boolean
    chat_id?: boolean
    flat_file_id?: boolean
    chat?: boolean | chatDefaultArgs<ExtArgs>
    flat_file?: boolean | chat_message$flat_fileArgs<ExtArgs>
  }, ExtArgs["result"]["chat_message"]>

  export type chat_messageSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    content?: boolean
    chat_id?: boolean
    flat_file_id?: boolean
  }

  export type chat_messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | chatDefaultArgs<ExtArgs>
    flat_file?: boolean | chat_message$flat_fileArgs<ExtArgs>
  }
  export type chat_messageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | chatDefaultArgs<ExtArgs>
    flat_file?: boolean | chat_message$flat_fileArgs<ExtArgs>
  }

  export type $chat_messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_message"
    objects: {
      chat: Prisma.$chatPayload<ExtArgs>
      flat_file: Prisma.$flat_filePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date | null
      updated_at: Date | null
      user_id: string
      content: string
      chat_id: string
      flat_file_id: bigint | null
    }, ExtArgs["result"]["chat_message"]>
    composites: {}
  }

  type chat_messageGetPayload<S extends boolean | null | undefined | chat_messageDefaultArgs> = $Result.GetResult<Prisma.$chat_messagePayload, S>

  type chat_messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<chat_messageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Chat_messageCountAggregateInputType | true
    }

  export interface chat_messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_message'], meta: { name: 'chat_message' } }
    /**
     * Find zero or one Chat_message that matches the filter.
     * @param {chat_messageFindUniqueArgs} args - Arguments to find a Chat_message
     * @example
     * // Get one Chat_message
     * const chat_message = await prisma.chat_message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_messageFindUniqueArgs>(args: SelectSubset<T, chat_messageFindUniqueArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat_message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {chat_messageFindUniqueOrThrowArgs} args - Arguments to find a Chat_message
     * @example
     * // Get one Chat_message
     * const chat_message = await prisma.chat_message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_messageFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat_message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messageFindFirstArgs} args - Arguments to find a Chat_message
     * @example
     * // Get one Chat_message
     * const chat_message = await prisma.chat_message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_messageFindFirstArgs>(args?: SelectSubset<T, chat_messageFindFirstArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat_message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messageFindFirstOrThrowArgs} args - Arguments to find a Chat_message
     * @example
     * // Get one Chat_message
     * const chat_message = await prisma.chat_message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_messageFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_messages
     * const chat_messages = await prisma.chat_message.findMany()
     * 
     * // Get first 10 Chat_messages
     * const chat_messages = await prisma.chat_message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_messageWithIdOnly = await prisma.chat_message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_messageFindManyArgs>(args?: SelectSubset<T, chat_messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat_message.
     * @param {chat_messageCreateArgs} args - Arguments to create a Chat_message.
     * @example
     * // Create one Chat_message
     * const Chat_message = await prisma.chat_message.create({
     *   data: {
     *     // ... data to create a Chat_message
     *   }
     * })
     * 
     */
    create<T extends chat_messageCreateArgs>(args: SelectSubset<T, chat_messageCreateArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chat_messages.
     * @param {chat_messageCreateManyArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_message = await prisma.chat_message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_messageCreateManyArgs>(args?: SelectSubset<T, chat_messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_messages and returns the data saved in the database.
     * @param {chat_messageCreateManyAndReturnArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_message = await prisma.chat_message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_messages and only return the `id`
     * const chat_messageWithIdOnly = await prisma.chat_message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_messageCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat_message.
     * @param {chat_messageDeleteArgs} args - Arguments to delete one Chat_message.
     * @example
     * // Delete one Chat_message
     * const Chat_message = await prisma.chat_message.delete({
     *   where: {
     *     // ... filter to delete one Chat_message
     *   }
     * })
     * 
     */
    delete<T extends chat_messageDeleteArgs>(args: SelectSubset<T, chat_messageDeleteArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat_message.
     * @param {chat_messageUpdateArgs} args - Arguments to update one Chat_message.
     * @example
     * // Update one Chat_message
     * const chat_message = await prisma.chat_message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_messageUpdateArgs>(args: SelectSubset<T, chat_messageUpdateArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chat_messages.
     * @param {chat_messageDeleteManyArgs} args - Arguments to filter Chat_messages to delete.
     * @example
     * // Delete a few Chat_messages
     * const { count } = await prisma.chat_message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_messageDeleteManyArgs>(args?: SelectSubset<T, chat_messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_messages
     * const chat_message = await prisma.chat_message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_messageUpdateManyArgs>(args: SelectSubset<T, chat_messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat_message.
     * @param {chat_messageUpsertArgs} args - Arguments to update or create a Chat_message.
     * @example
     * // Update or create a Chat_message
     * const chat_message = await prisma.chat_message.upsert({
     *   create: {
     *     // ... data to create a Chat_message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_message we want to update
     *   }
     * })
     */
    upsert<T extends chat_messageUpsertArgs>(args: SelectSubset<T, chat_messageUpsertArgs<ExtArgs>>): Prisma__chat_messageClient<$Result.GetResult<Prisma.$chat_messagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messageCountArgs} args - Arguments to filter Chat_messages to count.
     * @example
     * // Count the number of Chat_messages
     * const count = await prisma.chat_message.count({
     *   where: {
     *     // ... the filter for the Chat_messages we want to count
     *   }
     * })
    **/
    count<T extends chat_messageCountArgs>(
      args?: Subset<T, chat_messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_messageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_messageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_messageAggregateArgs>(args: Subset<T, Chat_messageAggregateArgs>): Prisma.PrismaPromise<GetChat_messageAggregateType<T>>

    /**
     * Group by Chat_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_messageGroupByArgs['orderBy'] }
        : { orderBy?: chat_messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_messageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_message model
   */
  readonly fields: chat_messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends chatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatDefaultArgs<ExtArgs>>): Prisma__chatClient<$Result.GetResult<Prisma.$chatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    flat_file<T extends chat_message$flat_fileArgs<ExtArgs> = {}>(args?: Subset<T, chat_message$flat_fileArgs<ExtArgs>>): Prisma__flat_fileClient<$Result.GetResult<Prisma.$flat_filePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_message model
   */ 
  interface chat_messageFieldRefs {
    readonly id: FieldRef<"chat_message", 'String'>
    readonly created_at: FieldRef<"chat_message", 'DateTime'>
    readonly updated_at: FieldRef<"chat_message", 'DateTime'>
    readonly user_id: FieldRef<"chat_message", 'String'>
    readonly content: FieldRef<"chat_message", 'String'>
    readonly chat_id: FieldRef<"chat_message", 'String'>
    readonly flat_file_id: FieldRef<"chat_message", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * chat_message findUnique
   */
  export type chat_messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * Filter, which chat_message to fetch.
     */
    where: chat_messageWhereUniqueInput
  }

  /**
   * chat_message findUniqueOrThrow
   */
  export type chat_messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * Filter, which chat_message to fetch.
     */
    where: chat_messageWhereUniqueInput
  }

  /**
   * chat_message findFirst
   */
  export type chat_messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * Filter, which chat_message to fetch.
     */
    where?: chat_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messageOrderByWithRelationInput | chat_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messageScalarFieldEnum | Chat_messageScalarFieldEnum[]
  }

  /**
   * chat_message findFirstOrThrow
   */
  export type chat_messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * Filter, which chat_message to fetch.
     */
    where?: chat_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messageOrderByWithRelationInput | chat_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messageScalarFieldEnum | Chat_messageScalarFieldEnum[]
  }

  /**
   * chat_message findMany
   */
  export type chat_messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messageOrderByWithRelationInput | chat_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_messages.
     */
    cursor?: chat_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    distinct?: Chat_messageScalarFieldEnum | Chat_messageScalarFieldEnum[]
  }

  /**
   * chat_message create
   */
  export type chat_messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_message.
     */
    data: XOR<chat_messageCreateInput, chat_messageUncheckedCreateInput>
  }

  /**
   * chat_message createMany
   */
  export type chat_messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messageCreateManyInput | chat_messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_message createManyAndReturn
   */
  export type chat_messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messageCreateManyInput | chat_messageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_message update
   */
  export type chat_messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_message.
     */
    data: XOR<chat_messageUpdateInput, chat_messageUncheckedUpdateInput>
    /**
     * Choose, which chat_message to update.
     */
    where: chat_messageWhereUniqueInput
  }

  /**
   * chat_message updateMany
   */
  export type chat_messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messageUpdateManyMutationInput, chat_messageUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messageWhereInput
  }

  /**
   * chat_message upsert
   */
  export type chat_messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_message to update in case it exists.
     */
    where: chat_messageWhereUniqueInput
    /**
     * In case the chat_message found by the `where` argument doesn't exist, create a new chat_message with this data.
     */
    create: XOR<chat_messageCreateInput, chat_messageUncheckedCreateInput>
    /**
     * In case the chat_message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_messageUpdateInput, chat_messageUncheckedUpdateInput>
  }

  /**
   * chat_message delete
   */
  export type chat_messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
    /**
     * Filter which chat_message to delete.
     */
    where: chat_messageWhereUniqueInput
  }

  /**
   * chat_message deleteMany
   */
  export type chat_messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to delete
     */
    where?: chat_messageWhereInput
  }

  /**
   * chat_message.flat_file
   */
  export type chat_message$flat_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flat_file
     */
    select?: flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flat_fileInclude<ExtArgs> | null
    where?: flat_fileWhereInput
  }

  /**
   * chat_message without action
   */
  export type chat_messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_message
     */
    select?: chat_messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messageInclude<ExtArgs> | null
  }


  /**
   * Model socket_io_attachments
   */

  export type AggregateSocket_io_attachments = {
    _count: Socket_io_attachmentsCountAggregateOutputType | null
    _avg: Socket_io_attachmentsAvgAggregateOutputType | null
    _sum: Socket_io_attachmentsSumAggregateOutputType | null
    _min: Socket_io_attachmentsMinAggregateOutputType | null
    _max: Socket_io_attachmentsMaxAggregateOutputType | null
  }

  export type Socket_io_attachmentsAvgAggregateOutputType = {
    id: number | null
  }

  export type Socket_io_attachmentsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Socket_io_attachmentsMinAggregateOutputType = {
    id: bigint | null
    payload: Buffer | null
    created_at: Date | null
  }

  export type Socket_io_attachmentsMaxAggregateOutputType = {
    id: bigint | null
    payload: Buffer | null
    created_at: Date | null
  }

  export type Socket_io_attachmentsCountAggregateOutputType = {
    id: number
    payload: number
    created_at: number
    _all: number
  }


  export type Socket_io_attachmentsAvgAggregateInputType = {
    id?: true
  }

  export type Socket_io_attachmentsSumAggregateInputType = {
    id?: true
  }

  export type Socket_io_attachmentsMinAggregateInputType = {
    id?: true
    payload?: true
    created_at?: true
  }

  export type Socket_io_attachmentsMaxAggregateInputType = {
    id?: true
    payload?: true
    created_at?: true
  }

  export type Socket_io_attachmentsCountAggregateInputType = {
    id?: true
    payload?: true
    created_at?: true
    _all?: true
  }

  export type Socket_io_attachmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which socket_io_attachments to aggregate.
     */
    where?: socket_io_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socket_io_attachments to fetch.
     */
    orderBy?: socket_io_attachmentsOrderByWithRelationInput | socket_io_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: socket_io_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socket_io_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socket_io_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned socket_io_attachments
    **/
    _count?: true | Socket_io_attachmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Socket_io_attachmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Socket_io_attachmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Socket_io_attachmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Socket_io_attachmentsMaxAggregateInputType
  }

  export type GetSocket_io_attachmentsAggregateType<T extends Socket_io_attachmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateSocket_io_attachments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocket_io_attachments[P]>
      : GetScalarType<T[P], AggregateSocket_io_attachments[P]>
  }




  export type socket_io_attachmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: socket_io_attachmentsWhereInput
    orderBy?: socket_io_attachmentsOrderByWithAggregationInput | socket_io_attachmentsOrderByWithAggregationInput[]
    by: Socket_io_attachmentsScalarFieldEnum[] | Socket_io_attachmentsScalarFieldEnum
    having?: socket_io_attachmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Socket_io_attachmentsCountAggregateInputType | true
    _avg?: Socket_io_attachmentsAvgAggregateInputType
    _sum?: Socket_io_attachmentsSumAggregateInputType
    _min?: Socket_io_attachmentsMinAggregateInputType
    _max?: Socket_io_attachmentsMaxAggregateInputType
  }

  export type Socket_io_attachmentsGroupByOutputType = {
    id: bigint
    payload: Buffer
    created_at: Date | null
    _count: Socket_io_attachmentsCountAggregateOutputType | null
    _avg: Socket_io_attachmentsAvgAggregateOutputType | null
    _sum: Socket_io_attachmentsSumAggregateOutputType | null
    _min: Socket_io_attachmentsMinAggregateOutputType | null
    _max: Socket_io_attachmentsMaxAggregateOutputType | null
  }

  type GetSocket_io_attachmentsGroupByPayload<T extends socket_io_attachmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Socket_io_attachmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Socket_io_attachmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Socket_io_attachmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Socket_io_attachmentsGroupByOutputType[P]>
        }
      >
    >


  export type socket_io_attachmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payload?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["socket_io_attachments"]>

  export type socket_io_attachmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payload?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["socket_io_attachments"]>

  export type socket_io_attachmentsSelectScalar = {
    id?: boolean
    payload?: boolean
    created_at?: boolean
  }


  export type $socket_io_attachmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "socket_io_attachments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      payload: Buffer
      created_at: Date | null
    }, ExtArgs["result"]["socket_io_attachments"]>
    composites: {}
  }

  type socket_io_attachmentsGetPayload<S extends boolean | null | undefined | socket_io_attachmentsDefaultArgs> = $Result.GetResult<Prisma.$socket_io_attachmentsPayload, S>

  type socket_io_attachmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<socket_io_attachmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Socket_io_attachmentsCountAggregateInputType | true
    }

  export interface socket_io_attachmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['socket_io_attachments'], meta: { name: 'socket_io_attachments' } }
    /**
     * Find zero or one Socket_io_attachments that matches the filter.
     * @param {socket_io_attachmentsFindUniqueArgs} args - Arguments to find a Socket_io_attachments
     * @example
     * // Get one Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends socket_io_attachmentsFindUniqueArgs>(args: SelectSubset<T, socket_io_attachmentsFindUniqueArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Socket_io_attachments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {socket_io_attachmentsFindUniqueOrThrowArgs} args - Arguments to find a Socket_io_attachments
     * @example
     * // Get one Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends socket_io_attachmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, socket_io_attachmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Socket_io_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socket_io_attachmentsFindFirstArgs} args - Arguments to find a Socket_io_attachments
     * @example
     * // Get one Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends socket_io_attachmentsFindFirstArgs>(args?: SelectSubset<T, socket_io_attachmentsFindFirstArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Socket_io_attachments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socket_io_attachmentsFindFirstOrThrowArgs} args - Arguments to find a Socket_io_attachments
     * @example
     * // Get one Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends socket_io_attachmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, socket_io_attachmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Socket_io_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socket_io_attachmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.findMany()
     * 
     * // Get first 10 Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socket_io_attachmentsWithIdOnly = await prisma.socket_io_attachments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends socket_io_attachmentsFindManyArgs>(args?: SelectSubset<T, socket_io_attachmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Socket_io_attachments.
     * @param {socket_io_attachmentsCreateArgs} args - Arguments to create a Socket_io_attachments.
     * @example
     * // Create one Socket_io_attachments
     * const Socket_io_attachments = await prisma.socket_io_attachments.create({
     *   data: {
     *     // ... data to create a Socket_io_attachments
     *   }
     * })
     * 
     */
    create<T extends socket_io_attachmentsCreateArgs>(args: SelectSubset<T, socket_io_attachmentsCreateArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Socket_io_attachments.
     * @param {socket_io_attachmentsCreateManyArgs} args - Arguments to create many Socket_io_attachments.
     * @example
     * // Create many Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends socket_io_attachmentsCreateManyArgs>(args?: SelectSubset<T, socket_io_attachmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Socket_io_attachments and returns the data saved in the database.
     * @param {socket_io_attachmentsCreateManyAndReturnArgs} args - Arguments to create many Socket_io_attachments.
     * @example
     * // Create many Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Socket_io_attachments and only return the `id`
     * const socket_io_attachmentsWithIdOnly = await prisma.socket_io_attachments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends socket_io_attachmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, socket_io_attachmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Socket_io_attachments.
     * @param {socket_io_attachmentsDeleteArgs} args - Arguments to delete one Socket_io_attachments.
     * @example
     * // Delete one Socket_io_attachments
     * const Socket_io_attachments = await prisma.socket_io_attachments.delete({
     *   where: {
     *     // ... filter to delete one Socket_io_attachments
     *   }
     * })
     * 
     */
    delete<T extends socket_io_attachmentsDeleteArgs>(args: SelectSubset<T, socket_io_attachmentsDeleteArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Socket_io_attachments.
     * @param {socket_io_attachmentsUpdateArgs} args - Arguments to update one Socket_io_attachments.
     * @example
     * // Update one Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends socket_io_attachmentsUpdateArgs>(args: SelectSubset<T, socket_io_attachmentsUpdateArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Socket_io_attachments.
     * @param {socket_io_attachmentsDeleteManyArgs} args - Arguments to filter Socket_io_attachments to delete.
     * @example
     * // Delete a few Socket_io_attachments
     * const { count } = await prisma.socket_io_attachments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends socket_io_attachmentsDeleteManyArgs>(args?: SelectSubset<T, socket_io_attachmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Socket_io_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socket_io_attachmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends socket_io_attachmentsUpdateManyArgs>(args: SelectSubset<T, socket_io_attachmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Socket_io_attachments.
     * @param {socket_io_attachmentsUpsertArgs} args - Arguments to update or create a Socket_io_attachments.
     * @example
     * // Update or create a Socket_io_attachments
     * const socket_io_attachments = await prisma.socket_io_attachments.upsert({
     *   create: {
     *     // ... data to create a Socket_io_attachments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Socket_io_attachments we want to update
     *   }
     * })
     */
    upsert<T extends socket_io_attachmentsUpsertArgs>(args: SelectSubset<T, socket_io_attachmentsUpsertArgs<ExtArgs>>): Prisma__socket_io_attachmentsClient<$Result.GetResult<Prisma.$socket_io_attachmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Socket_io_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socket_io_attachmentsCountArgs} args - Arguments to filter Socket_io_attachments to count.
     * @example
     * // Count the number of Socket_io_attachments
     * const count = await prisma.socket_io_attachments.count({
     *   where: {
     *     // ... the filter for the Socket_io_attachments we want to count
     *   }
     * })
    **/
    count<T extends socket_io_attachmentsCountArgs>(
      args?: Subset<T, socket_io_attachmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Socket_io_attachmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Socket_io_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Socket_io_attachmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Socket_io_attachmentsAggregateArgs>(args: Subset<T, Socket_io_attachmentsAggregateArgs>): Prisma.PrismaPromise<GetSocket_io_attachmentsAggregateType<T>>

    /**
     * Group by Socket_io_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {socket_io_attachmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends socket_io_attachmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: socket_io_attachmentsGroupByArgs['orderBy'] }
        : { orderBy?: socket_io_attachmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, socket_io_attachmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocket_io_attachmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the socket_io_attachments model
   */
  readonly fields: socket_io_attachmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for socket_io_attachments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__socket_io_attachmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the socket_io_attachments model
   */ 
  interface socket_io_attachmentsFieldRefs {
    readonly id: FieldRef<"socket_io_attachments", 'BigInt'>
    readonly payload: FieldRef<"socket_io_attachments", 'Bytes'>
    readonly created_at: FieldRef<"socket_io_attachments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * socket_io_attachments findUnique
   */
  export type socket_io_attachmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * Filter, which socket_io_attachments to fetch.
     */
    where: socket_io_attachmentsWhereUniqueInput
  }

  /**
   * socket_io_attachments findUniqueOrThrow
   */
  export type socket_io_attachmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * Filter, which socket_io_attachments to fetch.
     */
    where: socket_io_attachmentsWhereUniqueInput
  }

  /**
   * socket_io_attachments findFirst
   */
  export type socket_io_attachmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * Filter, which socket_io_attachments to fetch.
     */
    where?: socket_io_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socket_io_attachments to fetch.
     */
    orderBy?: socket_io_attachmentsOrderByWithRelationInput | socket_io_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for socket_io_attachments.
     */
    cursor?: socket_io_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socket_io_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socket_io_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of socket_io_attachments.
     */
    distinct?: Socket_io_attachmentsScalarFieldEnum | Socket_io_attachmentsScalarFieldEnum[]
  }

  /**
   * socket_io_attachments findFirstOrThrow
   */
  export type socket_io_attachmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * Filter, which socket_io_attachments to fetch.
     */
    where?: socket_io_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socket_io_attachments to fetch.
     */
    orderBy?: socket_io_attachmentsOrderByWithRelationInput | socket_io_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for socket_io_attachments.
     */
    cursor?: socket_io_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socket_io_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socket_io_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of socket_io_attachments.
     */
    distinct?: Socket_io_attachmentsScalarFieldEnum | Socket_io_attachmentsScalarFieldEnum[]
  }

  /**
   * socket_io_attachments findMany
   */
  export type socket_io_attachmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * Filter, which socket_io_attachments to fetch.
     */
    where?: socket_io_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of socket_io_attachments to fetch.
     */
    orderBy?: socket_io_attachmentsOrderByWithRelationInput | socket_io_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing socket_io_attachments.
     */
    cursor?: socket_io_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` socket_io_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` socket_io_attachments.
     */
    skip?: number
    distinct?: Socket_io_attachmentsScalarFieldEnum | Socket_io_attachmentsScalarFieldEnum[]
  }

  /**
   * socket_io_attachments create
   */
  export type socket_io_attachmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * The data needed to create a socket_io_attachments.
     */
    data: XOR<socket_io_attachmentsCreateInput, socket_io_attachmentsUncheckedCreateInput>
  }

  /**
   * socket_io_attachments createMany
   */
  export type socket_io_attachmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many socket_io_attachments.
     */
    data: socket_io_attachmentsCreateManyInput | socket_io_attachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * socket_io_attachments createManyAndReturn
   */
  export type socket_io_attachmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many socket_io_attachments.
     */
    data: socket_io_attachmentsCreateManyInput | socket_io_attachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * socket_io_attachments update
   */
  export type socket_io_attachmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * The data needed to update a socket_io_attachments.
     */
    data: XOR<socket_io_attachmentsUpdateInput, socket_io_attachmentsUncheckedUpdateInput>
    /**
     * Choose, which socket_io_attachments to update.
     */
    where: socket_io_attachmentsWhereUniqueInput
  }

  /**
   * socket_io_attachments updateMany
   */
  export type socket_io_attachmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update socket_io_attachments.
     */
    data: XOR<socket_io_attachmentsUpdateManyMutationInput, socket_io_attachmentsUncheckedUpdateManyInput>
    /**
     * Filter which socket_io_attachments to update
     */
    where?: socket_io_attachmentsWhereInput
  }

  /**
   * socket_io_attachments upsert
   */
  export type socket_io_attachmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * The filter to search for the socket_io_attachments to update in case it exists.
     */
    where: socket_io_attachmentsWhereUniqueInput
    /**
     * In case the socket_io_attachments found by the `where` argument doesn't exist, create a new socket_io_attachments with this data.
     */
    create: XOR<socket_io_attachmentsCreateInput, socket_io_attachmentsUncheckedCreateInput>
    /**
     * In case the socket_io_attachments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<socket_io_attachmentsUpdateInput, socket_io_attachmentsUncheckedUpdateInput>
  }

  /**
   * socket_io_attachments delete
   */
  export type socket_io_attachmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
    /**
     * Filter which socket_io_attachments to delete.
     */
    where: socket_io_attachmentsWhereUniqueInput
  }

  /**
   * socket_io_attachments deleteMany
   */
  export type socket_io_attachmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which socket_io_attachments to delete
     */
    where?: socket_io_attachmentsWhereInput
  }

  /**
   * socket_io_attachments without action
   */
  export type socket_io_attachmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the socket_io_attachments
     */
    select?: socket_io_attachmentsSelect<ExtArgs> | null
  }


  /**
   * Model component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    id: number | null
  }

  export type ComponentSumAggregateOutputType = {
    id: bigint | null
  }

  export type ComponentMinAggregateOutputType = {
    id: bigint | null
    collection_id: string | null
    created_at: Date | null
  }

  export type ComponentMaxAggregateOutputType = {
    id: bigint | null
    collection_id: string | null
    created_at: Date | null
  }

  export type ComponentCountAggregateOutputType = {
    id: number
    collection_id: number
    created_at: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    id?: true
  }

  export type ComponentSumAggregateInputType = {
    id?: true
  }

  export type ComponentMinAggregateInputType = {
    id?: true
    collection_id?: true
    created_at?: true
  }

  export type ComponentMaxAggregateInputType = {
    id?: true
    collection_id?: true
    created_at?: true
  }

  export type ComponentCountAggregateInputType = {
    id?: true
    collection_id?: true
    created_at?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which component to aggregate.
     */
    where?: componentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of components to fetch.
     */
    orderBy?: componentOrderByWithRelationInput | componentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: componentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type componentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: componentWhereInput
    orderBy?: componentOrderByWithAggregationInput | componentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: componentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    id: bigint
    collection_id: string
    created_at: Date | null
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends componentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type componentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    created_at?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    component_flat_files?: boolean | component$component_flat_filesArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type componentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    created_at?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type componentSelectScalar = {
    id?: boolean
    collection_id?: boolean
    created_at?: boolean
  }

  export type componentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    component_flat_files?: boolean | component$component_flat_filesArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type componentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $componentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "component"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
      component_flat_files: Prisma.$component_flat_filePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      collection_id: string
      created_at: Date | null
    }, ExtArgs["result"]["component"]>
    composites: {}
  }

  type componentGetPayload<S extends boolean | null | undefined | componentDefaultArgs> = $Result.GetResult<Prisma.$componentPayload, S>

  type componentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<componentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface componentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['component'], meta: { name: 'component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {componentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends componentFindUniqueArgs>(args: SelectSubset<T, componentFindUniqueArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Component that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {componentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends componentFindUniqueOrThrowArgs>(args: SelectSubset<T, componentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {componentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends componentFindFirstArgs>(args?: SelectSubset<T, componentFindFirstArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {componentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends componentFindFirstOrThrowArgs>(args?: SelectSubset<T, componentFindFirstOrThrowArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {componentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentWithIdOnly = await prisma.component.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends componentFindManyArgs>(args?: SelectSubset<T, componentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Component.
     * @param {componentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
     */
    create<T extends componentCreateArgs>(args: SelectSubset<T, componentCreateArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Components.
     * @param {componentCreateManyArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends componentCreateManyArgs>(args?: SelectSubset<T, componentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Components and returns the data saved in the database.
     * @param {componentCreateManyAndReturnArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends componentCreateManyAndReturnArgs>(args?: SelectSubset<T, componentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Component.
     * @param {componentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
     */
    delete<T extends componentDeleteArgs>(args: SelectSubset<T, componentDeleteArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Component.
     * @param {componentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends componentUpdateArgs>(args: SelectSubset<T, componentUpdateArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Components.
     * @param {componentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends componentDeleteManyArgs>(args?: SelectSubset<T, componentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {componentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends componentUpdateManyArgs>(args: SelectSubset<T, componentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component.
     * @param {componentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
     */
    upsert<T extends componentUpsertArgs>(args: SelectSubset<T, componentUpsertArgs<ExtArgs>>): Prisma__componentClient<$Result.GetResult<Prisma.$componentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {componentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends componentCountArgs>(
      args?: Subset<T, componentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {componentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends componentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: componentGroupByArgs['orderBy'] }
        : { orderBy?: componentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, componentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the component model
   */
  readonly fields: componentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__componentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    component_flat_files<T extends component$component_flat_filesArgs<ExtArgs> = {}>(args?: Subset<T, component$component_flat_filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$component_flat_filePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the component model
   */ 
  interface componentFieldRefs {
    readonly id: FieldRef<"component", 'BigInt'>
    readonly collection_id: FieldRef<"component", 'String'>
    readonly created_at: FieldRef<"component", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * component findUnique
   */
  export type componentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * Filter, which component to fetch.
     */
    where: componentWhereUniqueInput
  }

  /**
   * component findUniqueOrThrow
   */
  export type componentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * Filter, which component to fetch.
     */
    where: componentWhereUniqueInput
  }

  /**
   * component findFirst
   */
  export type componentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * Filter, which component to fetch.
     */
    where?: componentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of components to fetch.
     */
    orderBy?: componentOrderByWithRelationInput | componentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for components.
     */
    cursor?: componentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * component findFirstOrThrow
   */
  export type componentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * Filter, which component to fetch.
     */
    where?: componentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of components to fetch.
     */
    orderBy?: componentOrderByWithRelationInput | componentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for components.
     */
    cursor?: componentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * component findMany
   */
  export type componentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * Filter, which components to fetch.
     */
    where?: componentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of components to fetch.
     */
    orderBy?: componentOrderByWithRelationInput | componentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing components.
     */
    cursor?: componentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * component create
   */
  export type componentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * The data needed to create a component.
     */
    data: XOR<componentCreateInput, componentUncheckedCreateInput>
  }

  /**
   * component createMany
   */
  export type componentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many components.
     */
    data: componentCreateManyInput | componentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * component createManyAndReturn
   */
  export type componentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many components.
     */
    data: componentCreateManyInput | componentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * component update
   */
  export type componentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * The data needed to update a component.
     */
    data: XOR<componentUpdateInput, componentUncheckedUpdateInput>
    /**
     * Choose, which component to update.
     */
    where: componentWhereUniqueInput
  }

  /**
   * component updateMany
   */
  export type componentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update components.
     */
    data: XOR<componentUpdateManyMutationInput, componentUncheckedUpdateManyInput>
    /**
     * Filter which components to update
     */
    where?: componentWhereInput
  }

  /**
   * component upsert
   */
  export type componentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * The filter to search for the component to update in case it exists.
     */
    where: componentWhereUniqueInput
    /**
     * In case the component found by the `where` argument doesn't exist, create a new component with this data.
     */
    create: XOR<componentCreateInput, componentUncheckedCreateInput>
    /**
     * In case the component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<componentUpdateInput, componentUncheckedUpdateInput>
  }

  /**
   * component delete
   */
  export type componentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
    /**
     * Filter which component to delete.
     */
    where: componentWhereUniqueInput
  }

  /**
   * component deleteMany
   */
  export type componentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which components to delete
     */
    where?: componentWhereInput
  }

  /**
   * component.component_flat_files
   */
  export type component$component_flat_filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file
     */
    select?: component_flat_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: component_flat_fileInclude<ExtArgs> | null
    where?: component_flat_fileWhereInput
    orderBy?: component_flat_fileOrderByWithRelationInput | component_flat_fileOrderByWithRelationInput[]
    cursor?: component_flat_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Component_flat_fileScalarFieldEnum | Component_flat_fileScalarFieldEnum[]
  }

  /**
   * component without action
   */
  export type componentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component
     */
    select?: componentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: componentInclude<ExtArgs> | null
  }


  /**
   * Model workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowAvgAggregateOutputType = {
    order: number | null
    min_vram: number | null
  }

  export type WorkflowSumAggregateOutputType = {
    order: number | null
    min_vram: number | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    server_id: string | null
    output_mime_type: string | null
    display: boolean | null
    label: string | null
    order: number | null
    type: string | null
    machine_type: string | null
    min_vram: number | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    server_id: string | null
    output_mime_type: string | null
    display: boolean | null
    label: string | null
    order: number | null
    type: string | null
    machine_type: string | null
    min_vram: number | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    name: number
    description: number
    data: number
    created_at: number
    server_id: number
    output_mime_type: number
    display: number
    label: number
    order: number
    type: number
    est_gen_time: number
    machine_type: number
    min_vram: number
    _all: number
  }


  export type WorkflowAvgAggregateInputType = {
    order?: true
    min_vram?: true
  }

  export type WorkflowSumAggregateInputType = {
    order?: true
    min_vram?: true
  }

  export type WorkflowMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    server_id?: true
    output_mime_type?: true
    display?: true
    label?: true
    order?: true
    type?: true
    machine_type?: true
    min_vram?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    server_id?: true
    output_mime_type?: true
    display?: true
    label?: true
    order?: true
    type?: true
    machine_type?: true
    min_vram?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    data?: true
    created_at?: true
    server_id?: true
    output_mime_type?: true
    display?: true
    label?: true
    order?: true
    type?: true
    est_gen_time?: true
    machine_type?: true
    min_vram?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workflow to aggregate.
     */
    where?: workflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflows to fetch.
     */
    orderBy?: workflowOrderByWithRelationInput | workflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: workflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type workflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workflowWhereInput
    orderBy?: workflowOrderByWithAggregationInput | workflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: workflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _avg?: WorkflowAvgAggregateInputType
    _sum?: WorkflowSumAggregateInputType
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    name: string
    description: string | null
    data: JsonValue | null
    created_at: Date
    server_id: string | null
    output_mime_type: string | null
    display: boolean | null
    label: string | null
    order: number | null
    type: string | null
    est_gen_time: JsonValue | null
    machine_type: string | null
    min_vram: number | null
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends workflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type workflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    data?: boolean
    created_at?: boolean
    server_id?: boolean
    output_mime_type?: boolean
    display?: boolean
    label?: boolean
    order?: boolean
    type?: boolean
    est_gen_time?: boolean
    machine_type?: boolean
    min_vram?: boolean
    server?: boolean | workflow$serverArgs<ExtArgs>
    workflow_custom_nodes?: boolean | workflow$workflow_custom_nodesArgs<ExtArgs>
    workflow_models?: boolean | workflow$workflow_modelsArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type workflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    data?: boolean
    created_at?: boolean
    server_id?: boolean
    output_mime_type?: boolean
    display?: boolean
    label?: boolean
    order?: boolean
    type?: boolean
    est_gen_time?: boolean
    machine_type?: boolean
    min_vram?: boolean
    server?: boolean | workflow$serverArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type workflowSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    data?: boolean
    created_at?: boolean
    server_id?: boolean
    output_mime_type?: boolean
    display?: boolean
    label?: boolean
    order?: boolean
    type?: boolean
    est_gen_time?: boolean
    machine_type?: boolean
    min_vram?: boolean
  }

  export type workflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | workflow$serverArgs<ExtArgs>
    workflow_custom_nodes?: boolean | workflow$workflow_custom_nodesArgs<ExtArgs>
    workflow_models?: boolean | workflow$workflow_modelsArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type workflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | workflow$serverArgs<ExtArgs>
  }

  export type $workflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "workflow"
    objects: {
      server: Prisma.$serverPayload<ExtArgs> | null
      workflow_custom_nodes: Prisma.$workflow_custom_nodesPayload<ExtArgs>[]
      workflow_models: Prisma.$WorkflowModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      data: Prisma.JsonValue | null
      created_at: Date
      server_id: string | null
      output_mime_type: string | null
      display: boolean | null
      label: string | null
      order: number | null
      type: string | null
      est_gen_time: Prisma.JsonValue | null
      machine_type: string | null
      min_vram: number | null
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type workflowGetPayload<S extends boolean | null | undefined | workflowDefaultArgs> = $Result.GetResult<Prisma.$workflowPayload, S>

  type workflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<workflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface workflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['workflow'], meta: { name: 'workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {workflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends workflowFindUniqueArgs>(args: SelectSubset<T, workflowFindUniqueArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {workflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends workflowFindUniqueOrThrowArgs>(args: SelectSubset<T, workflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends workflowFindFirstArgs>(args?: SelectSubset<T, workflowFindFirstArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends workflowFindFirstOrThrowArgs>(args?: SelectSubset<T, workflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends workflowFindManyArgs>(args?: SelectSubset<T, workflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workflow.
     * @param {workflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends workflowCreateArgs>(args: SelectSubset<T, workflowCreateArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workflows.
     * @param {workflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends workflowCreateManyArgs>(args?: SelectSubset<T, workflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {workflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends workflowCreateManyAndReturnArgs>(args?: SelectSubset<T, workflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workflow.
     * @param {workflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends workflowDeleteArgs>(args: SelectSubset<T, workflowDeleteArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workflow.
     * @param {workflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends workflowUpdateArgs>(args: SelectSubset<T, workflowUpdateArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workflows.
     * @param {workflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends workflowDeleteManyArgs>(args?: SelectSubset<T, workflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends workflowUpdateManyArgs>(args: SelectSubset<T, workflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow.
     * @param {workflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends workflowUpsertArgs>(args: SelectSubset<T, workflowUpsertArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends workflowCountArgs>(
      args?: Subset<T, workflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends workflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: workflowGroupByArgs['orderBy'] }
        : { orderBy?: workflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, workflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the workflow model
   */
  readonly fields: workflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__workflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    server<T extends workflow$serverArgs<ExtArgs> = {}>(args?: Subset<T, workflow$serverArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workflow_custom_nodes<T extends workflow$workflow_custom_nodesArgs<ExtArgs> = {}>(args?: Subset<T, workflow$workflow_custom_nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findMany"> | Null>
    workflow_models<T extends workflow$workflow_modelsArgs<ExtArgs> = {}>(args?: Subset<T, workflow$workflow_modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the workflow model
   */ 
  interface workflowFieldRefs {
    readonly id: FieldRef<"workflow", 'String'>
    readonly name: FieldRef<"workflow", 'String'>
    readonly description: FieldRef<"workflow", 'String'>
    readonly data: FieldRef<"workflow", 'Json'>
    readonly created_at: FieldRef<"workflow", 'DateTime'>
    readonly server_id: FieldRef<"workflow", 'String'>
    readonly output_mime_type: FieldRef<"workflow", 'String'>
    readonly display: FieldRef<"workflow", 'Boolean'>
    readonly label: FieldRef<"workflow", 'String'>
    readonly order: FieldRef<"workflow", 'Int'>
    readonly type: FieldRef<"workflow", 'String'>
    readonly est_gen_time: FieldRef<"workflow", 'Json'>
    readonly machine_type: FieldRef<"workflow", 'String'>
    readonly min_vram: FieldRef<"workflow", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * workflow findUnique
   */
  export type workflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * Filter, which workflow to fetch.
     */
    where: workflowWhereUniqueInput
  }

  /**
   * workflow findUniqueOrThrow
   */
  export type workflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * Filter, which workflow to fetch.
     */
    where: workflowWhereUniqueInput
  }

  /**
   * workflow findFirst
   */
  export type workflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * Filter, which workflow to fetch.
     */
    where?: workflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflows to fetch.
     */
    orderBy?: workflowOrderByWithRelationInput | workflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workflows.
     */
    cursor?: workflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * workflow findFirstOrThrow
   */
  export type workflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * Filter, which workflow to fetch.
     */
    where?: workflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflows to fetch.
     */
    orderBy?: workflowOrderByWithRelationInput | workflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workflows.
     */
    cursor?: workflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * workflow findMany
   */
  export type workflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * Filter, which workflows to fetch.
     */
    where?: workflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflows to fetch.
     */
    orderBy?: workflowOrderByWithRelationInput | workflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workflows.
     */
    cursor?: workflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * workflow create
   */
  export type workflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * The data needed to create a workflow.
     */
    data: XOR<workflowCreateInput, workflowUncheckedCreateInput>
  }

  /**
   * workflow createMany
   */
  export type workflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many workflows.
     */
    data: workflowCreateManyInput | workflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * workflow createManyAndReturn
   */
  export type workflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many workflows.
     */
    data: workflowCreateManyInput | workflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * workflow update
   */
  export type workflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * The data needed to update a workflow.
     */
    data: XOR<workflowUpdateInput, workflowUncheckedUpdateInput>
    /**
     * Choose, which workflow to update.
     */
    where: workflowWhereUniqueInput
  }

  /**
   * workflow updateMany
   */
  export type workflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update workflows.
     */
    data: XOR<workflowUpdateManyMutationInput, workflowUncheckedUpdateManyInput>
    /**
     * Filter which workflows to update
     */
    where?: workflowWhereInput
  }

  /**
   * workflow upsert
   */
  export type workflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * The filter to search for the workflow to update in case it exists.
     */
    where: workflowWhereUniqueInput
    /**
     * In case the workflow found by the `where` argument doesn't exist, create a new workflow with this data.
     */
    create: XOR<workflowCreateInput, workflowUncheckedCreateInput>
    /**
     * In case the workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<workflowUpdateInput, workflowUncheckedUpdateInput>
  }

  /**
   * workflow delete
   */
  export type workflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    /**
     * Filter which workflow to delete.
     */
    where: workflowWhereUniqueInput
  }

  /**
   * workflow deleteMany
   */
  export type workflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workflows to delete
     */
    where?: workflowWhereInput
  }

  /**
   * workflow.server
   */
  export type workflow$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    where?: serverWhereInput
  }

  /**
   * workflow.workflow_custom_nodes
   */
  export type workflow$workflow_custom_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    where?: workflow_custom_nodesWhereInput
    orderBy?: workflow_custom_nodesOrderByWithRelationInput | workflow_custom_nodesOrderByWithRelationInput[]
    cursor?: workflow_custom_nodesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Workflow_custom_nodesScalarFieldEnum | Workflow_custom_nodesScalarFieldEnum[]
  }

  /**
   * workflow.workflow_models
   */
  export type workflow$workflow_modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    where?: WorkflowModelWhereInput
    orderBy?: WorkflowModelOrderByWithRelationInput | WorkflowModelOrderByWithRelationInput[]
    cursor?: WorkflowModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowModelScalarFieldEnum | WorkflowModelScalarFieldEnum[]
  }

  /**
   * workflow without action
   */
  export type workflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
  }


  /**
   * Model server
   */

  export type AggregateServer = {
    _count: ServerCountAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  export type ServerMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServerCountAggregateOutputType = {
    id: number
    name: number
    url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServerMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    created_at?: true
    updated_at?: true
  }

  export type ServerMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    created_at?: true
    updated_at?: true
  }

  export type ServerCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server to aggregate.
     */
    where?: serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serverOrderByWithRelationInput | serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servers
    **/
    _count?: true | ServerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServerMaxAggregateInputType
  }

  export type GetServerAggregateType<T extends ServerAggregateArgs> = {
        [P in keyof T & keyof AggregateServer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer[P]>
      : GetScalarType<T[P], AggregateServer[P]>
  }




  export type serverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serverWhereInput
    orderBy?: serverOrderByWithAggregationInput | serverOrderByWithAggregationInput[]
    by: ServerScalarFieldEnum[] | ServerScalarFieldEnum
    having?: serverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServerCountAggregateInputType | true
    _min?: ServerMinAggregateInputType
    _max?: ServerMaxAggregateInputType
  }

  export type ServerGroupByOutputType = {
    id: string
    name: string
    url: string
    created_at: Date
    updated_at: Date
    _count: ServerCountAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  type GetServerGroupByPayload<T extends serverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServerGroupByOutputType[P]>
            : GetScalarType<T[P], ServerGroupByOutputType[P]>
        }
      >
    >


  export type serverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    created_at?: boolean
    updated_at?: boolean
    workflow?: boolean | server$workflowArgs<ExtArgs>
    _count?: boolean | ServerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["server"]>

  export type serverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["server"]>

  export type serverSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type serverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | server$workflowArgs<ExtArgs>
    _count?: boolean | ServerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type serverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $serverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "server"
    objects: {
      workflow: Prisma.$workflowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["server"]>
    composites: {}
  }

  type serverGetPayload<S extends boolean | null | undefined | serverDefaultArgs> = $Result.GetResult<Prisma.$serverPayload, S>

  type serverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServerCountAggregateInputType | true
    }

  export interface serverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['server'], meta: { name: 'server' } }
    /**
     * Find zero or one Server that matches the filter.
     * @param {serverFindUniqueArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serverFindUniqueArgs>(args: SelectSubset<T, serverFindUniqueArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Server that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serverFindUniqueOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serverFindUniqueOrThrowArgs>(args: SelectSubset<T, serverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Server that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverFindFirstArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serverFindFirstArgs>(args?: SelectSubset<T, serverFindFirstArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Server that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverFindFirstOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serverFindFirstOrThrowArgs>(args?: SelectSubset<T, serverFindFirstOrThrowArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servers
     * const servers = await prisma.server.findMany()
     * 
     * // Get first 10 Servers
     * const servers = await prisma.server.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serverWithIdOnly = await prisma.server.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serverFindManyArgs>(args?: SelectSubset<T, serverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Server.
     * @param {serverCreateArgs} args - Arguments to create a Server.
     * @example
     * // Create one Server
     * const Server = await prisma.server.create({
     *   data: {
     *     // ... data to create a Server
     *   }
     * })
     * 
     */
    create<T extends serverCreateArgs>(args: SelectSubset<T, serverCreateArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servers.
     * @param {serverCreateManyArgs} args - Arguments to create many Servers.
     * @example
     * // Create many Servers
     * const server = await prisma.server.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serverCreateManyArgs>(args?: SelectSubset<T, serverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servers and returns the data saved in the database.
     * @param {serverCreateManyAndReturnArgs} args - Arguments to create many Servers.
     * @example
     * // Create many Servers
     * const server = await prisma.server.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servers and only return the `id`
     * const serverWithIdOnly = await prisma.server.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends serverCreateManyAndReturnArgs>(args?: SelectSubset<T, serverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Server.
     * @param {serverDeleteArgs} args - Arguments to delete one Server.
     * @example
     * // Delete one Server
     * const Server = await prisma.server.delete({
     *   where: {
     *     // ... filter to delete one Server
     *   }
     * })
     * 
     */
    delete<T extends serverDeleteArgs>(args: SelectSubset<T, serverDeleteArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Server.
     * @param {serverUpdateArgs} args - Arguments to update one Server.
     * @example
     * // Update one Server
     * const server = await prisma.server.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serverUpdateArgs>(args: SelectSubset<T, serverUpdateArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servers.
     * @param {serverDeleteManyArgs} args - Arguments to filter Servers to delete.
     * @example
     * // Delete a few Servers
     * const { count } = await prisma.server.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serverDeleteManyArgs>(args?: SelectSubset<T, serverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servers
     * const server = await prisma.server.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serverUpdateManyArgs>(args: SelectSubset<T, serverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server.
     * @param {serverUpsertArgs} args - Arguments to update or create a Server.
     * @example
     * // Update or create a Server
     * const server = await prisma.server.upsert({
     *   create: {
     *     // ... data to create a Server
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server we want to update
     *   }
     * })
     */
    upsert<T extends serverUpsertArgs>(args: SelectSubset<T, serverUpsertArgs<ExtArgs>>): Prisma__serverClient<$Result.GetResult<Prisma.$serverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverCountArgs} args - Arguments to filter Servers to count.
     * @example
     * // Count the number of Servers
     * const count = await prisma.server.count({
     *   where: {
     *     // ... the filter for the Servers we want to count
     *   }
     * })
    **/
    count<T extends serverCountArgs>(
      args?: Subset<T, serverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServerAggregateArgs>(args: Subset<T, ServerAggregateArgs>): Prisma.PrismaPromise<GetServerAggregateType<T>>

    /**
     * Group by Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serverGroupByArgs['orderBy'] }
        : { orderBy?: serverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the server model
   */
  readonly fields: serverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for server.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends server$workflowArgs<ExtArgs> = {}>(args?: Subset<T, server$workflowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the server model
   */ 
  interface serverFieldRefs {
    readonly id: FieldRef<"server", 'String'>
    readonly name: FieldRef<"server", 'String'>
    readonly url: FieldRef<"server", 'String'>
    readonly created_at: FieldRef<"server", 'DateTime'>
    readonly updated_at: FieldRef<"server", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * server findUnique
   */
  export type serverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * Filter, which server to fetch.
     */
    where: serverWhereUniqueInput
  }

  /**
   * server findUniqueOrThrow
   */
  export type serverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * Filter, which server to fetch.
     */
    where: serverWhereUniqueInput
  }

  /**
   * server findFirst
   */
  export type serverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * Filter, which server to fetch.
     */
    where?: serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serverOrderByWithRelationInput | serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servers.
     */
    cursor?: serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * server findFirstOrThrow
   */
  export type serverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * Filter, which server to fetch.
     */
    where?: serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serverOrderByWithRelationInput | serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servers.
     */
    cursor?: serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * server findMany
   */
  export type serverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * Filter, which servers to fetch.
     */
    where?: serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serverOrderByWithRelationInput | serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servers.
     */
    cursor?: serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * server create
   */
  export type serverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * The data needed to create a server.
     */
    data: XOR<serverCreateInput, serverUncheckedCreateInput>
  }

  /**
   * server createMany
   */
  export type serverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servers.
     */
    data: serverCreateManyInput | serverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * server createManyAndReturn
   */
  export type serverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many servers.
     */
    data: serverCreateManyInput | serverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * server update
   */
  export type serverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * The data needed to update a server.
     */
    data: XOR<serverUpdateInput, serverUncheckedUpdateInput>
    /**
     * Choose, which server to update.
     */
    where: serverWhereUniqueInput
  }

  /**
   * server updateMany
   */
  export type serverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servers.
     */
    data: XOR<serverUpdateManyMutationInput, serverUncheckedUpdateManyInput>
    /**
     * Filter which servers to update
     */
    where?: serverWhereInput
  }

  /**
   * server upsert
   */
  export type serverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * The filter to search for the server to update in case it exists.
     */
    where: serverWhereUniqueInput
    /**
     * In case the server found by the `where` argument doesn't exist, create a new server with this data.
     */
    create: XOR<serverCreateInput, serverUncheckedCreateInput>
    /**
     * In case the server was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serverUpdateInput, serverUncheckedUpdateInput>
  }

  /**
   * server delete
   */
  export type serverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
    /**
     * Filter which server to delete.
     */
    where: serverWhereUniqueInput
  }

  /**
   * server deleteMany
   */
  export type serverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servers to delete
     */
    where?: serverWhereInput
  }

  /**
   * server.workflow
   */
  export type server$workflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow
     */
    select?: workflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflowInclude<ExtArgs> | null
    where?: workflowWhereInput
    orderBy?: workflowOrderByWithRelationInput | workflowOrderByWithRelationInput[]
    cursor?: workflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * server without action
   */
  export type serverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server
     */
    select?: serverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serverInclude<ExtArgs> | null
  }


  /**
   * Model form_config
   */

  export type AggregateForm_config = {
    _count: Form_configCountAggregateOutputType | null
    _min: Form_configMinAggregateOutputType | null
    _max: Form_configMaxAggregateOutputType | null
  }

  export type Form_configMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Form_configMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Form_configCountAggregateOutputType = {
    id: number
    name: number
    data: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Form_configMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Form_configMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Form_configCountAggregateInputType = {
    id?: true
    name?: true
    data?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Form_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which form_config to aggregate.
     */
    where?: form_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_configs to fetch.
     */
    orderBy?: form_configOrderByWithRelationInput | form_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: form_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned form_configs
    **/
    _count?: true | Form_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Form_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Form_configMaxAggregateInputType
  }

  export type GetForm_configAggregateType<T extends Form_configAggregateArgs> = {
        [P in keyof T & keyof AggregateForm_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm_config[P]>
      : GetScalarType<T[P], AggregateForm_config[P]>
  }




  export type form_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: form_configWhereInput
    orderBy?: form_configOrderByWithAggregationInput | form_configOrderByWithAggregationInput[]
    by: Form_configScalarFieldEnum[] | Form_configScalarFieldEnum
    having?: form_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Form_configCountAggregateInputType | true
    _min?: Form_configMinAggregateInputType
    _max?: Form_configMaxAggregateInputType
  }

  export type Form_configGroupByOutputType = {
    id: string
    name: string
    data: JsonValue
    created_at: Date
    updated_at: Date
    _count: Form_configCountAggregateOutputType | null
    _min: Form_configMinAggregateOutputType | null
    _max: Form_configMaxAggregateOutputType | null
  }

  type GetForm_configGroupByPayload<T extends form_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Form_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Form_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Form_configGroupByOutputType[P]>
            : GetScalarType<T[P], Form_configGroupByOutputType[P]>
        }
      >
    >


  export type form_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["form_config"]>

  export type form_configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["form_config"]>

  export type form_configSelectScalar = {
    id?: boolean
    name?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $form_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "form_config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      data: Prisma.JsonValue
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["form_config"]>
    composites: {}
  }

  type form_configGetPayload<S extends boolean | null | undefined | form_configDefaultArgs> = $Result.GetResult<Prisma.$form_configPayload, S>

  type form_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<form_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Form_configCountAggregateInputType | true
    }

  export interface form_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['form_config'], meta: { name: 'form_config' } }
    /**
     * Find zero or one Form_config that matches the filter.
     * @param {form_configFindUniqueArgs} args - Arguments to find a Form_config
     * @example
     * // Get one Form_config
     * const form_config = await prisma.form_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends form_configFindUniqueArgs>(args: SelectSubset<T, form_configFindUniqueArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Form_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {form_configFindUniqueOrThrowArgs} args - Arguments to find a Form_config
     * @example
     * // Get one Form_config
     * const form_config = await prisma.form_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends form_configFindUniqueOrThrowArgs>(args: SelectSubset<T, form_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Form_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_configFindFirstArgs} args - Arguments to find a Form_config
     * @example
     * // Get one Form_config
     * const form_config = await prisma.form_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends form_configFindFirstArgs>(args?: SelectSubset<T, form_configFindFirstArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Form_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_configFindFirstOrThrowArgs} args - Arguments to find a Form_config
     * @example
     * // Get one Form_config
     * const form_config = await prisma.form_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends form_configFindFirstOrThrowArgs>(args?: SelectSubset<T, form_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Form_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Form_configs
     * const form_configs = await prisma.form_config.findMany()
     * 
     * // Get first 10 Form_configs
     * const form_configs = await prisma.form_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const form_configWithIdOnly = await prisma.form_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends form_configFindManyArgs>(args?: SelectSubset<T, form_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Form_config.
     * @param {form_configCreateArgs} args - Arguments to create a Form_config.
     * @example
     * // Create one Form_config
     * const Form_config = await prisma.form_config.create({
     *   data: {
     *     // ... data to create a Form_config
     *   }
     * })
     * 
     */
    create<T extends form_configCreateArgs>(args: SelectSubset<T, form_configCreateArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Form_configs.
     * @param {form_configCreateManyArgs} args - Arguments to create many Form_configs.
     * @example
     * // Create many Form_configs
     * const form_config = await prisma.form_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends form_configCreateManyArgs>(args?: SelectSubset<T, form_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Form_configs and returns the data saved in the database.
     * @param {form_configCreateManyAndReturnArgs} args - Arguments to create many Form_configs.
     * @example
     * // Create many Form_configs
     * const form_config = await prisma.form_config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Form_configs and only return the `id`
     * const form_configWithIdOnly = await prisma.form_config.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends form_configCreateManyAndReturnArgs>(args?: SelectSubset<T, form_configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Form_config.
     * @param {form_configDeleteArgs} args - Arguments to delete one Form_config.
     * @example
     * // Delete one Form_config
     * const Form_config = await prisma.form_config.delete({
     *   where: {
     *     // ... filter to delete one Form_config
     *   }
     * })
     * 
     */
    delete<T extends form_configDeleteArgs>(args: SelectSubset<T, form_configDeleteArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Form_config.
     * @param {form_configUpdateArgs} args - Arguments to update one Form_config.
     * @example
     * // Update one Form_config
     * const form_config = await prisma.form_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends form_configUpdateArgs>(args: SelectSubset<T, form_configUpdateArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Form_configs.
     * @param {form_configDeleteManyArgs} args - Arguments to filter Form_configs to delete.
     * @example
     * // Delete a few Form_configs
     * const { count } = await prisma.form_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends form_configDeleteManyArgs>(args?: SelectSubset<T, form_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Form_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Form_configs
     * const form_config = await prisma.form_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends form_configUpdateManyArgs>(args: SelectSubset<T, form_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Form_config.
     * @param {form_configUpsertArgs} args - Arguments to update or create a Form_config.
     * @example
     * // Update or create a Form_config
     * const form_config = await prisma.form_config.upsert({
     *   create: {
     *     // ... data to create a Form_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form_config we want to update
     *   }
     * })
     */
    upsert<T extends form_configUpsertArgs>(args: SelectSubset<T, form_configUpsertArgs<ExtArgs>>): Prisma__form_configClient<$Result.GetResult<Prisma.$form_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Form_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_configCountArgs} args - Arguments to filter Form_configs to count.
     * @example
     * // Count the number of Form_configs
     * const count = await prisma.form_config.count({
     *   where: {
     *     // ... the filter for the Form_configs we want to count
     *   }
     * })
    **/
    count<T extends form_configCountArgs>(
      args?: Subset<T, form_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Form_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Form_configAggregateArgs>(args: Subset<T, Form_configAggregateArgs>): Prisma.PrismaPromise<GetForm_configAggregateType<T>>

    /**
     * Group by Form_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {form_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends form_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: form_configGroupByArgs['orderBy'] }
        : { orderBy?: form_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, form_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForm_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the form_config model
   */
  readonly fields: form_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for form_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__form_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the form_config model
   */ 
  interface form_configFieldRefs {
    readonly id: FieldRef<"form_config", 'String'>
    readonly name: FieldRef<"form_config", 'String'>
    readonly data: FieldRef<"form_config", 'Json'>
    readonly created_at: FieldRef<"form_config", 'DateTime'>
    readonly updated_at: FieldRef<"form_config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * form_config findUnique
   */
  export type form_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * Filter, which form_config to fetch.
     */
    where: form_configWhereUniqueInput
  }

  /**
   * form_config findUniqueOrThrow
   */
  export type form_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * Filter, which form_config to fetch.
     */
    where: form_configWhereUniqueInput
  }

  /**
   * form_config findFirst
   */
  export type form_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * Filter, which form_config to fetch.
     */
    where?: form_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_configs to fetch.
     */
    orderBy?: form_configOrderByWithRelationInput | form_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for form_configs.
     */
    cursor?: form_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of form_configs.
     */
    distinct?: Form_configScalarFieldEnum | Form_configScalarFieldEnum[]
  }

  /**
   * form_config findFirstOrThrow
   */
  export type form_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * Filter, which form_config to fetch.
     */
    where?: form_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_configs to fetch.
     */
    orderBy?: form_configOrderByWithRelationInput | form_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for form_configs.
     */
    cursor?: form_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of form_configs.
     */
    distinct?: Form_configScalarFieldEnum | Form_configScalarFieldEnum[]
  }

  /**
   * form_config findMany
   */
  export type form_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * Filter, which form_configs to fetch.
     */
    where?: form_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of form_configs to fetch.
     */
    orderBy?: form_configOrderByWithRelationInput | form_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing form_configs.
     */
    cursor?: form_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` form_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` form_configs.
     */
    skip?: number
    distinct?: Form_configScalarFieldEnum | Form_configScalarFieldEnum[]
  }

  /**
   * form_config create
   */
  export type form_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * The data needed to create a form_config.
     */
    data: XOR<form_configCreateInput, form_configUncheckedCreateInput>
  }

  /**
   * form_config createMany
   */
  export type form_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many form_configs.
     */
    data: form_configCreateManyInput | form_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * form_config createManyAndReturn
   */
  export type form_configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many form_configs.
     */
    data: form_configCreateManyInput | form_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * form_config update
   */
  export type form_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * The data needed to update a form_config.
     */
    data: XOR<form_configUpdateInput, form_configUncheckedUpdateInput>
    /**
     * Choose, which form_config to update.
     */
    where: form_configWhereUniqueInput
  }

  /**
   * form_config updateMany
   */
  export type form_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update form_configs.
     */
    data: XOR<form_configUpdateManyMutationInput, form_configUncheckedUpdateManyInput>
    /**
     * Filter which form_configs to update
     */
    where?: form_configWhereInput
  }

  /**
   * form_config upsert
   */
  export type form_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * The filter to search for the form_config to update in case it exists.
     */
    where: form_configWhereUniqueInput
    /**
     * In case the form_config found by the `where` argument doesn't exist, create a new form_config with this data.
     */
    create: XOR<form_configCreateInput, form_configUncheckedCreateInput>
    /**
     * In case the form_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<form_configUpdateInput, form_configUncheckedUpdateInput>
  }

  /**
   * form_config delete
   */
  export type form_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
    /**
     * Filter which form_config to delete.
     */
    where: form_configWhereUniqueInput
  }

  /**
   * form_config deleteMany
   */
  export type form_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which form_configs to delete
     */
    where?: form_configWhereInput
  }

  /**
   * form_config without action
   */
  export type form_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the form_config
     */
    select?: form_configSelect<ExtArgs> | null
  }


  /**
   * Model api_key
   */

  export type AggregateApi_key = {
    _count: Api_keyCountAggregateOutputType | null
    _min: Api_keyMinAggregateOutputType | null
    _max: Api_keyMaxAggregateOutputType | null
  }

  export type Api_keyMinAggregateOutputType = {
    id: string | null
    alias: string | null
    key: string | null
    workflow_name: string | null
    user_id: string | null
    created_at: Date | null
  }

  export type Api_keyMaxAggregateOutputType = {
    id: string | null
    alias: string | null
    key: string | null
    workflow_name: string | null
    user_id: string | null
    created_at: Date | null
  }

  export type Api_keyCountAggregateOutputType = {
    id: number
    alias: number
    key: number
    workflow_name: number
    user_id: number
    created_at: number
    _all: number
  }


  export type Api_keyMinAggregateInputType = {
    id?: true
    alias?: true
    key?: true
    workflow_name?: true
    user_id?: true
    created_at?: true
  }

  export type Api_keyMaxAggregateInputType = {
    id?: true
    alias?: true
    key?: true
    workflow_name?: true
    user_id?: true
    created_at?: true
  }

  export type Api_keyCountAggregateInputType = {
    id?: true
    alias?: true
    key?: true
    workflow_name?: true
    user_id?: true
    created_at?: true
    _all?: true
  }

  export type Api_keyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_key to aggregate.
     */
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     */
    orderBy?: api_keyOrderByWithRelationInput | api_keyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_keys
    **/
    _count?: true | Api_keyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_keyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_keyMaxAggregateInputType
  }

  export type GetApi_keyAggregateType<T extends Api_keyAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_key]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_key[P]>
      : GetScalarType<T[P], AggregateApi_key[P]>
  }




  export type api_keyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_keyWhereInput
    orderBy?: api_keyOrderByWithAggregationInput | api_keyOrderByWithAggregationInput[]
    by: Api_keyScalarFieldEnum[] | Api_keyScalarFieldEnum
    having?: api_keyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_keyCountAggregateInputType | true
    _min?: Api_keyMinAggregateInputType
    _max?: Api_keyMaxAggregateInputType
  }

  export type Api_keyGroupByOutputType = {
    id: string
    alias: string
    key: string
    workflow_name: string
    user_id: string
    created_at: Date
    _count: Api_keyCountAggregateOutputType | null
    _min: Api_keyMinAggregateOutputType | null
    _max: Api_keyMaxAggregateOutputType | null
  }

  type GetApi_keyGroupByPayload<T extends api_keyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Api_keyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_keyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_keyGroupByOutputType[P]>
            : GetScalarType<T[P], Api_keyGroupByOutputType[P]>
        }
      >
    >


  export type api_keySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alias?: boolean
    key?: boolean
    workflow_name?: boolean
    user_id?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["api_key"]>

  export type api_keySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alias?: boolean
    key?: boolean
    workflow_name?: boolean
    user_id?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["api_key"]>

  export type api_keySelectScalar = {
    id?: boolean
    alias?: boolean
    key?: boolean
    workflow_name?: boolean
    user_id?: boolean
    created_at?: boolean
  }


  export type $api_keyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "api_key"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alias: string
      key: string
      workflow_name: string
      user_id: string
      created_at: Date
    }, ExtArgs["result"]["api_key"]>
    composites: {}
  }

  type api_keyGetPayload<S extends boolean | null | undefined | api_keyDefaultArgs> = $Result.GetResult<Prisma.$api_keyPayload, S>

  type api_keyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<api_keyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Api_keyCountAggregateInputType | true
    }

  export interface api_keyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['api_key'], meta: { name: 'api_key' } }
    /**
     * Find zero or one Api_key that matches the filter.
     * @param {api_keyFindUniqueArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends api_keyFindUniqueArgs>(args: SelectSubset<T, api_keyFindUniqueArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Api_key that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {api_keyFindUniqueOrThrowArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends api_keyFindUniqueOrThrowArgs>(args: SelectSubset<T, api_keyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Api_key that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyFindFirstArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends api_keyFindFirstArgs>(args?: SelectSubset<T, api_keyFindFirstArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Api_key that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyFindFirstOrThrowArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends api_keyFindFirstOrThrowArgs>(args?: SelectSubset<T, api_keyFindFirstOrThrowArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Api_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_keys
     * const api_keys = await prisma.api_key.findMany()
     * 
     * // Get first 10 Api_keys
     * const api_keys = await prisma.api_key.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const api_keyWithIdOnly = await prisma.api_key.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends api_keyFindManyArgs>(args?: SelectSubset<T, api_keyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Api_key.
     * @param {api_keyCreateArgs} args - Arguments to create a Api_key.
     * @example
     * // Create one Api_key
     * const Api_key = await prisma.api_key.create({
     *   data: {
     *     // ... data to create a Api_key
     *   }
     * })
     * 
     */
    create<T extends api_keyCreateArgs>(args: SelectSubset<T, api_keyCreateArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Api_keys.
     * @param {api_keyCreateManyArgs} args - Arguments to create many Api_keys.
     * @example
     * // Create many Api_keys
     * const api_key = await prisma.api_key.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends api_keyCreateManyArgs>(args?: SelectSubset<T, api_keyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Api_keys and returns the data saved in the database.
     * @param {api_keyCreateManyAndReturnArgs} args - Arguments to create many Api_keys.
     * @example
     * // Create many Api_keys
     * const api_key = await prisma.api_key.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Api_keys and only return the `id`
     * const api_keyWithIdOnly = await prisma.api_key.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends api_keyCreateManyAndReturnArgs>(args?: SelectSubset<T, api_keyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Api_key.
     * @param {api_keyDeleteArgs} args - Arguments to delete one Api_key.
     * @example
     * // Delete one Api_key
     * const Api_key = await prisma.api_key.delete({
     *   where: {
     *     // ... filter to delete one Api_key
     *   }
     * })
     * 
     */
    delete<T extends api_keyDeleteArgs>(args: SelectSubset<T, api_keyDeleteArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Api_key.
     * @param {api_keyUpdateArgs} args - Arguments to update one Api_key.
     * @example
     * // Update one Api_key
     * const api_key = await prisma.api_key.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends api_keyUpdateArgs>(args: SelectSubset<T, api_keyUpdateArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Api_keys.
     * @param {api_keyDeleteManyArgs} args - Arguments to filter Api_keys to delete.
     * @example
     * // Delete a few Api_keys
     * const { count } = await prisma.api_key.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends api_keyDeleteManyArgs>(args?: SelectSubset<T, api_keyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_keys
     * const api_key = await prisma.api_key.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends api_keyUpdateManyArgs>(args: SelectSubset<T, api_keyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Api_key.
     * @param {api_keyUpsertArgs} args - Arguments to update or create a Api_key.
     * @example
     * // Update or create a Api_key
     * const api_key = await prisma.api_key.upsert({
     *   create: {
     *     // ... data to create a Api_key
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_key we want to update
     *   }
     * })
     */
    upsert<T extends api_keyUpsertArgs>(args: SelectSubset<T, api_keyUpsertArgs<ExtArgs>>): Prisma__api_keyClient<$Result.GetResult<Prisma.$api_keyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyCountArgs} args - Arguments to filter Api_keys to count.
     * @example
     * // Count the number of Api_keys
     * const count = await prisma.api_key.count({
     *   where: {
     *     // ... the filter for the Api_keys we want to count
     *   }
     * })
    **/
    count<T extends api_keyCountArgs>(
      args?: Subset<T, api_keyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_keyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_key.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_keyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_keyAggregateArgs>(args: Subset<T, Api_keyAggregateArgs>): Prisma.PrismaPromise<GetApi_keyAggregateType<T>>

    /**
     * Group by Api_key.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends api_keyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: api_keyGroupByArgs['orderBy'] }
        : { orderBy?: api_keyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, api_keyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_keyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the api_key model
   */
  readonly fields: api_keyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for api_key.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__api_keyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the api_key model
   */ 
  interface api_keyFieldRefs {
    readonly id: FieldRef<"api_key", 'String'>
    readonly alias: FieldRef<"api_key", 'String'>
    readonly key: FieldRef<"api_key", 'String'>
    readonly workflow_name: FieldRef<"api_key", 'String'>
    readonly user_id: FieldRef<"api_key", 'String'>
    readonly created_at: FieldRef<"api_key", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * api_key findUnique
   */
  export type api_keyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * Filter, which api_key to fetch.
     */
    where: api_keyWhereUniqueInput
  }

  /**
   * api_key findUniqueOrThrow
   */
  export type api_keyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * Filter, which api_key to fetch.
     */
    where: api_keyWhereUniqueInput
  }

  /**
   * api_key findFirst
   */
  export type api_keyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * Filter, which api_key to fetch.
     */
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     */
    orderBy?: api_keyOrderByWithRelationInput | api_keyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_keys.
     */
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_keys.
     */
    distinct?: Api_keyScalarFieldEnum | Api_keyScalarFieldEnum[]
  }

  /**
   * api_key findFirstOrThrow
   */
  export type api_keyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * Filter, which api_key to fetch.
     */
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     */
    orderBy?: api_keyOrderByWithRelationInput | api_keyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_keys.
     */
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_keys.
     */
    distinct?: Api_keyScalarFieldEnum | Api_keyScalarFieldEnum[]
  }

  /**
   * api_key findMany
   */
  export type api_keyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * Filter, which api_keys to fetch.
     */
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     */
    orderBy?: api_keyOrderByWithRelationInput | api_keyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_keys.
     */
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     */
    skip?: number
    distinct?: Api_keyScalarFieldEnum | Api_keyScalarFieldEnum[]
  }

  /**
   * api_key create
   */
  export type api_keyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * The data needed to create a api_key.
     */
    data: XOR<api_keyCreateInput, api_keyUncheckedCreateInput>
  }

  /**
   * api_key createMany
   */
  export type api_keyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many api_keys.
     */
    data: api_keyCreateManyInput | api_keyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_key createManyAndReturn
   */
  export type api_keyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many api_keys.
     */
    data: api_keyCreateManyInput | api_keyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_key update
   */
  export type api_keyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * The data needed to update a api_key.
     */
    data: XOR<api_keyUpdateInput, api_keyUncheckedUpdateInput>
    /**
     * Choose, which api_key to update.
     */
    where: api_keyWhereUniqueInput
  }

  /**
   * api_key updateMany
   */
  export type api_keyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update api_keys.
     */
    data: XOR<api_keyUpdateManyMutationInput, api_keyUncheckedUpdateManyInput>
    /**
     * Filter which api_keys to update
     */
    where?: api_keyWhereInput
  }

  /**
   * api_key upsert
   */
  export type api_keyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * The filter to search for the api_key to update in case it exists.
     */
    where: api_keyWhereUniqueInput
    /**
     * In case the api_key found by the `where` argument doesn't exist, create a new api_key with this data.
     */
    create: XOR<api_keyCreateInput, api_keyUncheckedCreateInput>
    /**
     * In case the api_key was found with the provided `where` argument, update it with this data.
     */
    update: XOR<api_keyUpdateInput, api_keyUncheckedUpdateInput>
  }

  /**
   * api_key delete
   */
  export type api_keyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
    /**
     * Filter which api_key to delete.
     */
    where: api_keyWhereUniqueInput
  }

  /**
   * api_key deleteMany
   */
  export type api_keyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_keys to delete
     */
    where?: api_keyWhereInput
  }

  /**
   * api_key without action
   */
  export type api_keyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_key
     */
    select?: api_keySelect<ExtArgs> | null
  }


  /**
   * Model user_api_keys
   */

  export type AggregateUser_api_keys = {
    _count: User_api_keysCountAggregateOutputType | null
    _min: User_api_keysMinAggregateOutputType | null
    _max: User_api_keysMaxAggregateOutputType | null
  }

  export type User_api_keysMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    key_hash: string | null
    name: string | null
    expires_at: Date | null
    created_at: Date | null
    is_active: boolean | null
  }

  export type User_api_keysMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    key_hash: string | null
    name: string | null
    expires_at: Date | null
    created_at: Date | null
    is_active: boolean | null
  }

  export type User_api_keysCountAggregateOutputType = {
    id: number
    user_id: number
    key_hash: number
    name: number
    expires_at: number
    created_at: number
    is_active: number
    _all: number
  }


  export type User_api_keysMinAggregateInputType = {
    id?: true
    user_id?: true
    key_hash?: true
    name?: true
    expires_at?: true
    created_at?: true
    is_active?: true
  }

  export type User_api_keysMaxAggregateInputType = {
    id?: true
    user_id?: true
    key_hash?: true
    name?: true
    expires_at?: true
    created_at?: true
    is_active?: true
  }

  export type User_api_keysCountAggregateInputType = {
    id?: true
    user_id?: true
    key_hash?: true
    name?: true
    expires_at?: true
    created_at?: true
    is_active?: true
    _all?: true
  }

  export type User_api_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_api_keys to aggregate.
     */
    where?: user_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_api_keys to fetch.
     */
    orderBy?: user_api_keysOrderByWithRelationInput | user_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_api_keys
    **/
    _count?: true | User_api_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_api_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_api_keysMaxAggregateInputType
  }

  export type GetUser_api_keysAggregateType<T extends User_api_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_api_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_api_keys[P]>
      : GetScalarType<T[P], AggregateUser_api_keys[P]>
  }




  export type user_api_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_api_keysWhereInput
    orderBy?: user_api_keysOrderByWithAggregationInput | user_api_keysOrderByWithAggregationInput[]
    by: User_api_keysScalarFieldEnum[] | User_api_keysScalarFieldEnum
    having?: user_api_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_api_keysCountAggregateInputType | true
    _min?: User_api_keysMinAggregateInputType
    _max?: User_api_keysMaxAggregateInputType
  }

  export type User_api_keysGroupByOutputType = {
    id: string
    user_id: string
    key_hash: string
    name: string | null
    expires_at: Date | null
    created_at: Date
    is_active: boolean
    _count: User_api_keysCountAggregateOutputType | null
    _min: User_api_keysMinAggregateOutputType | null
    _max: User_api_keysMaxAggregateOutputType | null
  }

  type GetUser_api_keysGroupByPayload<T extends user_api_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_api_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_api_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_api_keysGroupByOutputType[P]>
            : GetScalarType<T[P], User_api_keysGroupByOutputType[P]>
        }
      >
    >


  export type user_api_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    key_hash?: boolean
    name?: boolean
    expires_at?: boolean
    created_at?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["user_api_keys"]>

  export type user_api_keysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    key_hash?: boolean
    name?: boolean
    expires_at?: boolean
    created_at?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["user_api_keys"]>

  export type user_api_keysSelectScalar = {
    id?: boolean
    user_id?: boolean
    key_hash?: boolean
    name?: boolean
    expires_at?: boolean
    created_at?: boolean
    is_active?: boolean
  }


  export type $user_api_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_api_keys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      key_hash: string
      name: string | null
      expires_at: Date | null
      created_at: Date
      is_active: boolean
    }, ExtArgs["result"]["user_api_keys"]>
    composites: {}
  }

  type user_api_keysGetPayload<S extends boolean | null | undefined | user_api_keysDefaultArgs> = $Result.GetResult<Prisma.$user_api_keysPayload, S>

  type user_api_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_api_keysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_api_keysCountAggregateInputType | true
    }

  export interface user_api_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_api_keys'], meta: { name: 'user_api_keys' } }
    /**
     * Find zero or one User_api_keys that matches the filter.
     * @param {user_api_keysFindUniqueArgs} args - Arguments to find a User_api_keys
     * @example
     * // Get one User_api_keys
     * const user_api_keys = await prisma.user_api_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_api_keysFindUniqueArgs>(args: SelectSubset<T, user_api_keysFindUniqueArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_api_keys that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_api_keysFindUniqueOrThrowArgs} args - Arguments to find a User_api_keys
     * @example
     * // Get one User_api_keys
     * const user_api_keys = await prisma.user_api_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_api_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, user_api_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_api_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_api_keysFindFirstArgs} args - Arguments to find a User_api_keys
     * @example
     * // Get one User_api_keys
     * const user_api_keys = await prisma.user_api_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_api_keysFindFirstArgs>(args?: SelectSubset<T, user_api_keysFindFirstArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_api_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_api_keysFindFirstOrThrowArgs} args - Arguments to find a User_api_keys
     * @example
     * // Get one User_api_keys
     * const user_api_keys = await prisma.user_api_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_api_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, user_api_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_api_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_api_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_api_keys
     * const user_api_keys = await prisma.user_api_keys.findMany()
     * 
     * // Get first 10 User_api_keys
     * const user_api_keys = await prisma.user_api_keys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_api_keysWithIdOnly = await prisma.user_api_keys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_api_keysFindManyArgs>(args?: SelectSubset<T, user_api_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_api_keys.
     * @param {user_api_keysCreateArgs} args - Arguments to create a User_api_keys.
     * @example
     * // Create one User_api_keys
     * const User_api_keys = await prisma.user_api_keys.create({
     *   data: {
     *     // ... data to create a User_api_keys
     *   }
     * })
     * 
     */
    create<T extends user_api_keysCreateArgs>(args: SelectSubset<T, user_api_keysCreateArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_api_keys.
     * @param {user_api_keysCreateManyArgs} args - Arguments to create many User_api_keys.
     * @example
     * // Create many User_api_keys
     * const user_api_keys = await prisma.user_api_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_api_keysCreateManyArgs>(args?: SelectSubset<T, user_api_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_api_keys and returns the data saved in the database.
     * @param {user_api_keysCreateManyAndReturnArgs} args - Arguments to create many User_api_keys.
     * @example
     * // Create many User_api_keys
     * const user_api_keys = await prisma.user_api_keys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_api_keys and only return the `id`
     * const user_api_keysWithIdOnly = await prisma.user_api_keys.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_api_keysCreateManyAndReturnArgs>(args?: SelectSubset<T, user_api_keysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_api_keys.
     * @param {user_api_keysDeleteArgs} args - Arguments to delete one User_api_keys.
     * @example
     * // Delete one User_api_keys
     * const User_api_keys = await prisma.user_api_keys.delete({
     *   where: {
     *     // ... filter to delete one User_api_keys
     *   }
     * })
     * 
     */
    delete<T extends user_api_keysDeleteArgs>(args: SelectSubset<T, user_api_keysDeleteArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_api_keys.
     * @param {user_api_keysUpdateArgs} args - Arguments to update one User_api_keys.
     * @example
     * // Update one User_api_keys
     * const user_api_keys = await prisma.user_api_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_api_keysUpdateArgs>(args: SelectSubset<T, user_api_keysUpdateArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_api_keys.
     * @param {user_api_keysDeleteManyArgs} args - Arguments to filter User_api_keys to delete.
     * @example
     * // Delete a few User_api_keys
     * const { count } = await prisma.user_api_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_api_keysDeleteManyArgs>(args?: SelectSubset<T, user_api_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_api_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_api_keys
     * const user_api_keys = await prisma.user_api_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_api_keysUpdateManyArgs>(args: SelectSubset<T, user_api_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_api_keys.
     * @param {user_api_keysUpsertArgs} args - Arguments to update or create a User_api_keys.
     * @example
     * // Update or create a User_api_keys
     * const user_api_keys = await prisma.user_api_keys.upsert({
     *   create: {
     *     // ... data to create a User_api_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_api_keys we want to update
     *   }
     * })
     */
    upsert<T extends user_api_keysUpsertArgs>(args: SelectSubset<T, user_api_keysUpsertArgs<ExtArgs>>): Prisma__user_api_keysClient<$Result.GetResult<Prisma.$user_api_keysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_api_keysCountArgs} args - Arguments to filter User_api_keys to count.
     * @example
     * // Count the number of User_api_keys
     * const count = await prisma.user_api_keys.count({
     *   where: {
     *     // ... the filter for the User_api_keys we want to count
     *   }
     * })
    **/
    count<T extends user_api_keysCountArgs>(
      args?: Subset<T, user_api_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_api_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_api_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_api_keysAggregateArgs>(args: Subset<T, User_api_keysAggregateArgs>): Prisma.PrismaPromise<GetUser_api_keysAggregateType<T>>

    /**
     * Group by User_api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_api_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_api_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_api_keysGroupByArgs['orderBy'] }
        : { orderBy?: user_api_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_api_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_api_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_api_keys model
   */
  readonly fields: user_api_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_api_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_api_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_api_keys model
   */ 
  interface user_api_keysFieldRefs {
    readonly id: FieldRef<"user_api_keys", 'String'>
    readonly user_id: FieldRef<"user_api_keys", 'String'>
    readonly key_hash: FieldRef<"user_api_keys", 'String'>
    readonly name: FieldRef<"user_api_keys", 'String'>
    readonly expires_at: FieldRef<"user_api_keys", 'DateTime'>
    readonly created_at: FieldRef<"user_api_keys", 'DateTime'>
    readonly is_active: FieldRef<"user_api_keys", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * user_api_keys findUnique
   */
  export type user_api_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * Filter, which user_api_keys to fetch.
     */
    where: user_api_keysWhereUniqueInput
  }

  /**
   * user_api_keys findUniqueOrThrow
   */
  export type user_api_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * Filter, which user_api_keys to fetch.
     */
    where: user_api_keysWhereUniqueInput
  }

  /**
   * user_api_keys findFirst
   */
  export type user_api_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * Filter, which user_api_keys to fetch.
     */
    where?: user_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_api_keys to fetch.
     */
    orderBy?: user_api_keysOrderByWithRelationInput | user_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_api_keys.
     */
    cursor?: user_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_api_keys.
     */
    distinct?: User_api_keysScalarFieldEnum | User_api_keysScalarFieldEnum[]
  }

  /**
   * user_api_keys findFirstOrThrow
   */
  export type user_api_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * Filter, which user_api_keys to fetch.
     */
    where?: user_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_api_keys to fetch.
     */
    orderBy?: user_api_keysOrderByWithRelationInput | user_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_api_keys.
     */
    cursor?: user_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_api_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_api_keys.
     */
    distinct?: User_api_keysScalarFieldEnum | User_api_keysScalarFieldEnum[]
  }

  /**
   * user_api_keys findMany
   */
  export type user_api_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * Filter, which user_api_keys to fetch.
     */
    where?: user_api_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_api_keys to fetch.
     */
    orderBy?: user_api_keysOrderByWithRelationInput | user_api_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_api_keys.
     */
    cursor?: user_api_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_api_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_api_keys.
     */
    skip?: number
    distinct?: User_api_keysScalarFieldEnum | User_api_keysScalarFieldEnum[]
  }

  /**
   * user_api_keys create
   */
  export type user_api_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * The data needed to create a user_api_keys.
     */
    data: XOR<user_api_keysCreateInput, user_api_keysUncheckedCreateInput>
  }

  /**
   * user_api_keys createMany
   */
  export type user_api_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_api_keys.
     */
    data: user_api_keysCreateManyInput | user_api_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_api_keys createManyAndReturn
   */
  export type user_api_keysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_api_keys.
     */
    data: user_api_keysCreateManyInput | user_api_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_api_keys update
   */
  export type user_api_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * The data needed to update a user_api_keys.
     */
    data: XOR<user_api_keysUpdateInput, user_api_keysUncheckedUpdateInput>
    /**
     * Choose, which user_api_keys to update.
     */
    where: user_api_keysWhereUniqueInput
  }

  /**
   * user_api_keys updateMany
   */
  export type user_api_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_api_keys.
     */
    data: XOR<user_api_keysUpdateManyMutationInput, user_api_keysUncheckedUpdateManyInput>
    /**
     * Filter which user_api_keys to update
     */
    where?: user_api_keysWhereInput
  }

  /**
   * user_api_keys upsert
   */
  export type user_api_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * The filter to search for the user_api_keys to update in case it exists.
     */
    where: user_api_keysWhereUniqueInput
    /**
     * In case the user_api_keys found by the `where` argument doesn't exist, create a new user_api_keys with this data.
     */
    create: XOR<user_api_keysCreateInput, user_api_keysUncheckedCreateInput>
    /**
     * In case the user_api_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_api_keysUpdateInput, user_api_keysUncheckedUpdateInput>
  }

  /**
   * user_api_keys delete
   */
  export type user_api_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
    /**
     * Filter which user_api_keys to delete.
     */
    where: user_api_keysWhereUniqueInput
  }

  /**
   * user_api_keys deleteMany
   */
  export type user_api_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_api_keys to delete
     */
    where?: user_api_keysWhereInput
  }

  /**
   * user_api_keys without action
   */
  export type user_api_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_api_keys
     */
    select?: user_api_keysSelect<ExtArgs> | null
  }


  /**
   * Model job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    progress: number | null
    priority: number | null
  }

  export type JobSumAggregateOutputType = {
    progress: number | null
    priority: number | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    progress: number | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    started_at: Date | null
    completed_at: Date | null
    user_id: string | null
    job_type: string | null
    priority: number | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    progress: number | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    started_at: Date | null
    completed_at: Date | null
    user_id: string | null
    job_type: string | null
    priority: number | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    data: number
    progress: number
    error_message: number
    created_at: number
    updated_at: number
    started_at: number
    completed_at: number
    user_id: number
    job_type: number
    priority: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    progress?: true
    priority?: true
  }

  export type JobSumAggregateInputType = {
    progress?: true
    priority?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    progress?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    started_at?: true
    completed_at?: true
    user_id?: true
    job_type?: true
    priority?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    progress?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    started_at?: true
    completed_at?: true
    user_id?: true
    job_type?: true
    priority?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    data?: true
    progress?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    started_at?: true
    completed_at?: true
    user_id?: true
    job_type?: true
    priority?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job to aggregate.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type jobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
    orderBy?: jobOrderByWithAggregationInput | jobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: jobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    data: JsonValue | null
    progress: number | null
    error_message: string | null
    created_at: Date
    updated_at: Date
    started_at: Date | null
    completed_at: Date | null
    user_id: string
    job_type: string
    priority: number
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends jobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type jobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    data?: boolean
    progress?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    started_at?: boolean
    completed_at?: boolean
    user_id?: boolean
    job_type?: boolean
    priority?: boolean
    job_history?: boolean | job$job_historyArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type jobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    data?: boolean
    progress?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    started_at?: boolean
    completed_at?: boolean
    user_id?: boolean
    job_type?: boolean
    priority?: boolean
  }, ExtArgs["result"]["job"]>

  export type jobSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    data?: boolean
    progress?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    started_at?: boolean
    completed_at?: boolean
    user_id?: boolean
    job_type?: boolean
    priority?: boolean
  }

  export type jobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_history?: boolean | job$job_historyArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $jobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job"
    objects: {
      job_history: Prisma.$job_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      data: Prisma.JsonValue | null
      progress: number | null
      error_message: string | null
      created_at: Date
      updated_at: Date
      started_at: Date | null
      completed_at: Date | null
      user_id: string
      job_type: string
      priority: number
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type jobGetPayload<S extends boolean | null | undefined | jobDefaultArgs> = $Result.GetResult<Prisma.$jobPayload, S>

  type jobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<jobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface jobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job'], meta: { name: 'job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {jobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobFindUniqueArgs>(args: SelectSubset<T, jobFindUniqueArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {jobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobFindUniqueOrThrowArgs>(args: SelectSubset<T, jobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobFindFirstArgs>(args?: SelectSubset<T, jobFindFirstArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobFindFirstOrThrowArgs>(args?: SelectSubset<T, jobFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobFindManyArgs>(args?: SelectSubset<T, jobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Job.
     * @param {jobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends jobCreateArgs>(args: SelectSubset<T, jobCreateArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {jobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobCreateManyArgs>(args?: SelectSubset<T, jobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {jobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobCreateManyAndReturnArgs>(args?: SelectSubset<T, jobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Job.
     * @param {jobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends jobDeleteArgs>(args: SelectSubset<T, jobDeleteArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Job.
     * @param {jobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobUpdateArgs>(args: SelectSubset<T, jobUpdateArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {jobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobDeleteManyArgs>(args?: SelectSubset<T, jobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobUpdateManyArgs>(args: SelectSubset<T, jobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {jobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends jobUpsertArgs>(args: SelectSubset<T, jobUpsertArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobCountArgs>(
      args?: Subset<T, jobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobGroupByArgs['orderBy'] }
        : { orderBy?: jobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job model
   */
  readonly fields: jobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_history<T extends job$job_historyArgs<ExtArgs> = {}>(args?: Subset<T, job$job_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job model
   */ 
  interface jobFieldRefs {
    readonly id: FieldRef<"job", 'String'>
    readonly name: FieldRef<"job", 'String'>
    readonly description: FieldRef<"job", 'String'>
    readonly status: FieldRef<"job", 'String'>
    readonly data: FieldRef<"job", 'Json'>
    readonly progress: FieldRef<"job", 'Int'>
    readonly error_message: FieldRef<"job", 'String'>
    readonly created_at: FieldRef<"job", 'DateTime'>
    readonly updated_at: FieldRef<"job", 'DateTime'>
    readonly started_at: FieldRef<"job", 'DateTime'>
    readonly completed_at: FieldRef<"job", 'DateTime'>
    readonly user_id: FieldRef<"job", 'String'>
    readonly job_type: FieldRef<"job", 'String'>
    readonly priority: FieldRef<"job", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * job findUnique
   */
  export type jobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job findUniqueOrThrow
   */
  export type jobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job findFirst
   */
  export type jobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job findFirstOrThrow
   */
  export type jobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job findMany
   */
  export type jobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job create
   */
  export type jobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to create a job.
     */
    data: XOR<jobCreateInput, jobUncheckedCreateInput>
  }

  /**
   * job createMany
   */
  export type jobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobCreateManyInput | jobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job createManyAndReturn
   */
  export type jobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many jobs.
     */
    data: jobCreateManyInput | jobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job update
   */
  export type jobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to update a job.
     */
    data: XOR<jobUpdateInput, jobUncheckedUpdateInput>
    /**
     * Choose, which job to update.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job updateMany
   */
  export type jobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobWhereInput
  }

  /**
   * job upsert
   */
  export type jobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The filter to search for the job to update in case it exists.
     */
    where: jobWhereUniqueInput
    /**
     * In case the job found by the `where` argument doesn't exist, create a new job with this data.
     */
    create: XOR<jobCreateInput, jobUncheckedCreateInput>
    /**
     * In case the job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobUpdateInput, jobUncheckedUpdateInput>
  }

  /**
   * job delete
   */
  export type jobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter which job to delete.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job deleteMany
   */
  export type jobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobWhereInput
  }

  /**
   * job.job_history
   */
  export type job$job_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    where?: job_historyWhereInput
    orderBy?: job_historyOrderByWithRelationInput | job_historyOrderByWithRelationInput[]
    cursor?: job_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_historyScalarFieldEnum | Job_historyScalarFieldEnum[]
  }

  /**
   * job without action
   */
  export type jobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
  }


  /**
   * Model job_history
   */

  export type AggregateJob_history = {
    _count: Job_historyCountAggregateOutputType | null
    _min: Job_historyMinAggregateOutputType | null
    _max: Job_historyMaxAggregateOutputType | null
  }

  export type Job_historyMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    status: string | null
    created_at: Date | null
    message: string | null
  }

  export type Job_historyMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    status: string | null
    created_at: Date | null
    message: string | null
  }

  export type Job_historyCountAggregateOutputType = {
    id: number
    job_id: number
    status: number
    data: number
    created_at: number
    message: number
    _all: number
  }


  export type Job_historyMinAggregateInputType = {
    id?: true
    job_id?: true
    status?: true
    created_at?: true
    message?: true
  }

  export type Job_historyMaxAggregateInputType = {
    id?: true
    job_id?: true
    status?: true
    created_at?: true
    message?: true
  }

  export type Job_historyCountAggregateInputType = {
    id?: true
    job_id?: true
    status?: true
    data?: true
    created_at?: true
    message?: true
    _all?: true
  }

  export type Job_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_history to aggregate.
     */
    where?: job_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_histories to fetch.
     */
    orderBy?: job_historyOrderByWithRelationInput | job_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_histories
    **/
    _count?: true | Job_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_historyMaxAggregateInputType
  }

  export type GetJob_historyAggregateType<T extends Job_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_history[P]>
      : GetScalarType<T[P], AggregateJob_history[P]>
  }




  export type job_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_historyWhereInput
    orderBy?: job_historyOrderByWithAggregationInput | job_historyOrderByWithAggregationInput[]
    by: Job_historyScalarFieldEnum[] | Job_historyScalarFieldEnum
    having?: job_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_historyCountAggregateInputType | true
    _min?: Job_historyMinAggregateInputType
    _max?: Job_historyMaxAggregateInputType
  }

  export type Job_historyGroupByOutputType = {
    id: string
    job_id: string
    status: string
    data: JsonValue | null
    created_at: Date
    message: string | null
    _count: Job_historyCountAggregateOutputType | null
    _min: Job_historyMinAggregateOutputType | null
    _max: Job_historyMaxAggregateOutputType | null
  }

  type GetJob_historyGroupByPayload<T extends job_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Job_historyGroupByOutputType[P]>
        }
      >
    >


  export type job_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    status?: boolean
    data?: boolean
    created_at?: boolean
    message?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_history"]>

  export type job_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    status?: boolean
    data?: boolean
    created_at?: boolean
    message?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_history"]>

  export type job_historySelectScalar = {
    id?: boolean
    job_id?: boolean
    status?: boolean
    data?: boolean
    created_at?: boolean
    message?: boolean
  }

  export type job_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
  }
  export type job_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
  }

  export type $job_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_history"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string
      status: string
      data: Prisma.JsonValue | null
      created_at: Date
      message: string | null
    }, ExtArgs["result"]["job_history"]>
    composites: {}
  }

  type job_historyGetPayload<S extends boolean | null | undefined | job_historyDefaultArgs> = $Result.GetResult<Prisma.$job_historyPayload, S>

  type job_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<job_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Job_historyCountAggregateInputType | true
    }

  export interface job_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_history'], meta: { name: 'job_history' } }
    /**
     * Find zero or one Job_history that matches the filter.
     * @param {job_historyFindUniqueArgs} args - Arguments to find a Job_history
     * @example
     * // Get one Job_history
     * const job_history = await prisma.job_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_historyFindUniqueArgs>(args: SelectSubset<T, job_historyFindUniqueArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Job_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {job_historyFindUniqueOrThrowArgs} args - Arguments to find a Job_history
     * @example
     * // Get one Job_history
     * const job_history = await prisma.job_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, job_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Job_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_historyFindFirstArgs} args - Arguments to find a Job_history
     * @example
     * // Get one Job_history
     * const job_history = await prisma.job_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_historyFindFirstArgs>(args?: SelectSubset<T, job_historyFindFirstArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Job_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_historyFindFirstOrThrowArgs} args - Arguments to find a Job_history
     * @example
     * // Get one Job_history
     * const job_history = await prisma.job_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, job_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Job_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_histories
     * const job_histories = await prisma.job_history.findMany()
     * 
     * // Get first 10 Job_histories
     * const job_histories = await prisma.job_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_historyWithIdOnly = await prisma.job_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_historyFindManyArgs>(args?: SelectSubset<T, job_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Job_history.
     * @param {job_historyCreateArgs} args - Arguments to create a Job_history.
     * @example
     * // Create one Job_history
     * const Job_history = await prisma.job_history.create({
     *   data: {
     *     // ... data to create a Job_history
     *   }
     * })
     * 
     */
    create<T extends job_historyCreateArgs>(args: SelectSubset<T, job_historyCreateArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Job_histories.
     * @param {job_historyCreateManyArgs} args - Arguments to create many Job_histories.
     * @example
     * // Create many Job_histories
     * const job_history = await prisma.job_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_historyCreateManyArgs>(args?: SelectSubset<T, job_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_histories and returns the data saved in the database.
     * @param {job_historyCreateManyAndReturnArgs} args - Arguments to create many Job_histories.
     * @example
     * // Create many Job_histories
     * const job_history = await prisma.job_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_histories and only return the `id`
     * const job_historyWithIdOnly = await prisma.job_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, job_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Job_history.
     * @param {job_historyDeleteArgs} args - Arguments to delete one Job_history.
     * @example
     * // Delete one Job_history
     * const Job_history = await prisma.job_history.delete({
     *   where: {
     *     // ... filter to delete one Job_history
     *   }
     * })
     * 
     */
    delete<T extends job_historyDeleteArgs>(args: SelectSubset<T, job_historyDeleteArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Job_history.
     * @param {job_historyUpdateArgs} args - Arguments to update one Job_history.
     * @example
     * // Update one Job_history
     * const job_history = await prisma.job_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_historyUpdateArgs>(args: SelectSubset<T, job_historyUpdateArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Job_histories.
     * @param {job_historyDeleteManyArgs} args - Arguments to filter Job_histories to delete.
     * @example
     * // Delete a few Job_histories
     * const { count } = await prisma.job_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_historyDeleteManyArgs>(args?: SelectSubset<T, job_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_histories
     * const job_history = await prisma.job_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_historyUpdateManyArgs>(args: SelectSubset<T, job_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job_history.
     * @param {job_historyUpsertArgs} args - Arguments to update or create a Job_history.
     * @example
     * // Update or create a Job_history
     * const job_history = await prisma.job_history.upsert({
     *   create: {
     *     // ... data to create a Job_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_history we want to update
     *   }
     * })
     */
    upsert<T extends job_historyUpsertArgs>(args: SelectSubset<T, job_historyUpsertArgs<ExtArgs>>): Prisma__job_historyClient<$Result.GetResult<Prisma.$job_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Job_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_historyCountArgs} args - Arguments to filter Job_histories to count.
     * @example
     * // Count the number of Job_histories
     * const count = await prisma.job_history.count({
     *   where: {
     *     // ... the filter for the Job_histories we want to count
     *   }
     * })
    **/
    count<T extends job_historyCountArgs>(
      args?: Subset<T, job_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_historyAggregateArgs>(args: Subset<T, Job_historyAggregateArgs>): Prisma.PrismaPromise<GetJob_historyAggregateType<T>>

    /**
     * Group by Job_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_historyGroupByArgs['orderBy'] }
        : { orderBy?: job_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_history model
   */
  readonly fields: job_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_history model
   */ 
  interface job_historyFieldRefs {
    readonly id: FieldRef<"job_history", 'String'>
    readonly job_id: FieldRef<"job_history", 'String'>
    readonly status: FieldRef<"job_history", 'String'>
    readonly data: FieldRef<"job_history", 'Json'>
    readonly created_at: FieldRef<"job_history", 'DateTime'>
    readonly message: FieldRef<"job_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * job_history findUnique
   */
  export type job_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * Filter, which job_history to fetch.
     */
    where: job_historyWhereUniqueInput
  }

  /**
   * job_history findUniqueOrThrow
   */
  export type job_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * Filter, which job_history to fetch.
     */
    where: job_historyWhereUniqueInput
  }

  /**
   * job_history findFirst
   */
  export type job_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * Filter, which job_history to fetch.
     */
    where?: job_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_histories to fetch.
     */
    orderBy?: job_historyOrderByWithRelationInput | job_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_histories.
     */
    cursor?: job_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_histories.
     */
    distinct?: Job_historyScalarFieldEnum | Job_historyScalarFieldEnum[]
  }

  /**
   * job_history findFirstOrThrow
   */
  export type job_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * Filter, which job_history to fetch.
     */
    where?: job_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_histories to fetch.
     */
    orderBy?: job_historyOrderByWithRelationInput | job_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_histories.
     */
    cursor?: job_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_histories.
     */
    distinct?: Job_historyScalarFieldEnum | Job_historyScalarFieldEnum[]
  }

  /**
   * job_history findMany
   */
  export type job_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * Filter, which job_histories to fetch.
     */
    where?: job_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_histories to fetch.
     */
    orderBy?: job_historyOrderByWithRelationInput | job_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_histories.
     */
    cursor?: job_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_histories.
     */
    skip?: number
    distinct?: Job_historyScalarFieldEnum | Job_historyScalarFieldEnum[]
  }

  /**
   * job_history create
   */
  export type job_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a job_history.
     */
    data: XOR<job_historyCreateInput, job_historyUncheckedCreateInput>
  }

  /**
   * job_history createMany
   */
  export type job_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_histories.
     */
    data: job_historyCreateManyInput | job_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_history createManyAndReturn
   */
  export type job_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many job_histories.
     */
    data: job_historyCreateManyInput | job_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_history update
   */
  export type job_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a job_history.
     */
    data: XOR<job_historyUpdateInput, job_historyUncheckedUpdateInput>
    /**
     * Choose, which job_history to update.
     */
    where: job_historyWhereUniqueInput
  }

  /**
   * job_history updateMany
   */
  export type job_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_histories.
     */
    data: XOR<job_historyUpdateManyMutationInput, job_historyUncheckedUpdateManyInput>
    /**
     * Filter which job_histories to update
     */
    where?: job_historyWhereInput
  }

  /**
   * job_history upsert
   */
  export type job_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the job_history to update in case it exists.
     */
    where: job_historyWhereUniqueInput
    /**
     * In case the job_history found by the `where` argument doesn't exist, create a new job_history with this data.
     */
    create: XOR<job_historyCreateInput, job_historyUncheckedCreateInput>
    /**
     * In case the job_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_historyUpdateInput, job_historyUncheckedUpdateInput>
  }

  /**
   * job_history delete
   */
  export type job_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
    /**
     * Filter which job_history to delete.
     */
    where: job_historyWhereUniqueInput
  }

  /**
   * job_history deleteMany
   */
  export type job_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_histories to delete
     */
    where?: job_historyWhereInput
  }

  /**
   * job_history without action
   */
  export type job_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_history
     */
    select?: job_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_historyInclude<ExtArgs> | null
  }


  /**
   * Model miniapp_user
   */

  export type AggregateMiniapp_user = {
    _count: Miniapp_userCountAggregateOutputType | null
    _min: Miniapp_userMinAggregateOutputType | null
    _max: Miniapp_userMaxAggregateOutputType | null
  }

  export type Miniapp_userMinAggregateOutputType = {
    id: string | null
    farcaster_id: string | null
    farcaster_username: string | null
    farcaster_pfp: string | null
    wallet_address: string | null
    created_at: Date | null
    updated_at: Date | null
    notification_token: string | null
  }

  export type Miniapp_userMaxAggregateOutputType = {
    id: string | null
    farcaster_id: string | null
    farcaster_username: string | null
    farcaster_pfp: string | null
    wallet_address: string | null
    created_at: Date | null
    updated_at: Date | null
    notification_token: string | null
  }

  export type Miniapp_userCountAggregateOutputType = {
    id: number
    farcaster_id: number
    farcaster_username: number
    farcaster_pfp: number
    wallet_address: number
    created_at: number
    updated_at: number
    notification_token: number
    _all: number
  }


  export type Miniapp_userMinAggregateInputType = {
    id?: true
    farcaster_id?: true
    farcaster_username?: true
    farcaster_pfp?: true
    wallet_address?: true
    created_at?: true
    updated_at?: true
    notification_token?: true
  }

  export type Miniapp_userMaxAggregateInputType = {
    id?: true
    farcaster_id?: true
    farcaster_username?: true
    farcaster_pfp?: true
    wallet_address?: true
    created_at?: true
    updated_at?: true
    notification_token?: true
  }

  export type Miniapp_userCountAggregateInputType = {
    id?: true
    farcaster_id?: true
    farcaster_username?: true
    farcaster_pfp?: true
    wallet_address?: true
    created_at?: true
    updated_at?: true
    notification_token?: true
    _all?: true
  }

  export type Miniapp_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_user to aggregate.
     */
    where?: miniapp_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_users to fetch.
     */
    orderBy?: miniapp_userOrderByWithRelationInput | miniapp_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: miniapp_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned miniapp_users
    **/
    _count?: true | Miniapp_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Miniapp_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Miniapp_userMaxAggregateInputType
  }

  export type GetMiniapp_userAggregateType<T extends Miniapp_userAggregateArgs> = {
        [P in keyof T & keyof AggregateMiniapp_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiniapp_user[P]>
      : GetScalarType<T[P], AggregateMiniapp_user[P]>
  }




  export type miniapp_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_userWhereInput
    orderBy?: miniapp_userOrderByWithAggregationInput | miniapp_userOrderByWithAggregationInput[]
    by: Miniapp_userScalarFieldEnum[] | Miniapp_userScalarFieldEnum
    having?: miniapp_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Miniapp_userCountAggregateInputType | true
    _min?: Miniapp_userMinAggregateInputType
    _max?: Miniapp_userMaxAggregateInputType
  }

  export type Miniapp_userGroupByOutputType = {
    id: string
    farcaster_id: string
    farcaster_username: string | null
    farcaster_pfp: string | null
    wallet_address: string | null
    created_at: Date
    updated_at: Date
    notification_token: string | null
    _count: Miniapp_userCountAggregateOutputType | null
    _min: Miniapp_userMinAggregateOutputType | null
    _max: Miniapp_userMaxAggregateOutputType | null
  }

  type GetMiniapp_userGroupByPayload<T extends miniapp_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Miniapp_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Miniapp_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Miniapp_userGroupByOutputType[P]>
            : GetScalarType<T[P], Miniapp_userGroupByOutputType[P]>
        }
      >
    >


  export type miniapp_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farcaster_id?: boolean
    farcaster_username?: boolean
    farcaster_pfp?: boolean
    wallet_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    notification_token?: boolean
    miniapp_generation?: boolean | miniapp_user$miniapp_generationArgs<ExtArgs>
    miniapp_payment?: boolean | miniapp_user$miniapp_paymentArgs<ExtArgs>
    social_links?: boolean | miniapp_user$social_linksArgs<ExtArgs>
    _count?: boolean | Miniapp_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_user"]>

  export type miniapp_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farcaster_id?: boolean
    farcaster_username?: boolean
    farcaster_pfp?: boolean
    wallet_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    notification_token?: boolean
  }, ExtArgs["result"]["miniapp_user"]>

  export type miniapp_userSelectScalar = {
    id?: boolean
    farcaster_id?: boolean
    farcaster_username?: boolean
    farcaster_pfp?: boolean
    wallet_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    notification_token?: boolean
  }

  export type miniapp_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniapp_generation?: boolean | miniapp_user$miniapp_generationArgs<ExtArgs>
    miniapp_payment?: boolean | miniapp_user$miniapp_paymentArgs<ExtArgs>
    social_links?: boolean | miniapp_user$social_linksArgs<ExtArgs>
    _count?: boolean | Miniapp_userCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type miniapp_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $miniapp_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "miniapp_user"
    objects: {
      miniapp_generation: Prisma.$miniapp_generationPayload<ExtArgs>[]
      miniapp_payment: Prisma.$miniapp_paymentPayload<ExtArgs>[]
      social_links: Prisma.$social_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      farcaster_id: string
      farcaster_username: string | null
      farcaster_pfp: string | null
      wallet_address: string | null
      created_at: Date
      updated_at: Date
      notification_token: string | null
    }, ExtArgs["result"]["miniapp_user"]>
    composites: {}
  }

  type miniapp_userGetPayload<S extends boolean | null | undefined | miniapp_userDefaultArgs> = $Result.GetResult<Prisma.$miniapp_userPayload, S>

  type miniapp_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<miniapp_userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Miniapp_userCountAggregateInputType | true
    }

  export interface miniapp_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['miniapp_user'], meta: { name: 'miniapp_user' } }
    /**
     * Find zero or one Miniapp_user that matches the filter.
     * @param {miniapp_userFindUniqueArgs} args - Arguments to find a Miniapp_user
     * @example
     * // Get one Miniapp_user
     * const miniapp_user = await prisma.miniapp_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends miniapp_userFindUniqueArgs>(args: SelectSubset<T, miniapp_userFindUniqueArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Miniapp_user that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {miniapp_userFindUniqueOrThrowArgs} args - Arguments to find a Miniapp_user
     * @example
     * // Get one Miniapp_user
     * const miniapp_user = await prisma.miniapp_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends miniapp_userFindUniqueOrThrowArgs>(args: SelectSubset<T, miniapp_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Miniapp_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_userFindFirstArgs} args - Arguments to find a Miniapp_user
     * @example
     * // Get one Miniapp_user
     * const miniapp_user = await prisma.miniapp_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends miniapp_userFindFirstArgs>(args?: SelectSubset<T, miniapp_userFindFirstArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Miniapp_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_userFindFirstOrThrowArgs} args - Arguments to find a Miniapp_user
     * @example
     * // Get one Miniapp_user
     * const miniapp_user = await prisma.miniapp_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends miniapp_userFindFirstOrThrowArgs>(args?: SelectSubset<T, miniapp_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Miniapp_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Miniapp_users
     * const miniapp_users = await prisma.miniapp_user.findMany()
     * 
     * // Get first 10 Miniapp_users
     * const miniapp_users = await prisma.miniapp_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miniapp_userWithIdOnly = await prisma.miniapp_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends miniapp_userFindManyArgs>(args?: SelectSubset<T, miniapp_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Miniapp_user.
     * @param {miniapp_userCreateArgs} args - Arguments to create a Miniapp_user.
     * @example
     * // Create one Miniapp_user
     * const Miniapp_user = await prisma.miniapp_user.create({
     *   data: {
     *     // ... data to create a Miniapp_user
     *   }
     * })
     * 
     */
    create<T extends miniapp_userCreateArgs>(args: SelectSubset<T, miniapp_userCreateArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Miniapp_users.
     * @param {miniapp_userCreateManyArgs} args - Arguments to create many Miniapp_users.
     * @example
     * // Create many Miniapp_users
     * const miniapp_user = await prisma.miniapp_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends miniapp_userCreateManyArgs>(args?: SelectSubset<T, miniapp_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Miniapp_users and returns the data saved in the database.
     * @param {miniapp_userCreateManyAndReturnArgs} args - Arguments to create many Miniapp_users.
     * @example
     * // Create many Miniapp_users
     * const miniapp_user = await prisma.miniapp_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Miniapp_users and only return the `id`
     * const miniapp_userWithIdOnly = await prisma.miniapp_user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends miniapp_userCreateManyAndReturnArgs>(args?: SelectSubset<T, miniapp_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Miniapp_user.
     * @param {miniapp_userDeleteArgs} args - Arguments to delete one Miniapp_user.
     * @example
     * // Delete one Miniapp_user
     * const Miniapp_user = await prisma.miniapp_user.delete({
     *   where: {
     *     // ... filter to delete one Miniapp_user
     *   }
     * })
     * 
     */
    delete<T extends miniapp_userDeleteArgs>(args: SelectSubset<T, miniapp_userDeleteArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Miniapp_user.
     * @param {miniapp_userUpdateArgs} args - Arguments to update one Miniapp_user.
     * @example
     * // Update one Miniapp_user
     * const miniapp_user = await prisma.miniapp_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends miniapp_userUpdateArgs>(args: SelectSubset<T, miniapp_userUpdateArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Miniapp_users.
     * @param {miniapp_userDeleteManyArgs} args - Arguments to filter Miniapp_users to delete.
     * @example
     * // Delete a few Miniapp_users
     * const { count } = await prisma.miniapp_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends miniapp_userDeleteManyArgs>(args?: SelectSubset<T, miniapp_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Miniapp_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Miniapp_users
     * const miniapp_user = await prisma.miniapp_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends miniapp_userUpdateManyArgs>(args: SelectSubset<T, miniapp_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Miniapp_user.
     * @param {miniapp_userUpsertArgs} args - Arguments to update or create a Miniapp_user.
     * @example
     * // Update or create a Miniapp_user
     * const miniapp_user = await prisma.miniapp_user.upsert({
     *   create: {
     *     // ... data to create a Miniapp_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Miniapp_user we want to update
     *   }
     * })
     */
    upsert<T extends miniapp_userUpsertArgs>(args: SelectSubset<T, miniapp_userUpsertArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Miniapp_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_userCountArgs} args - Arguments to filter Miniapp_users to count.
     * @example
     * // Count the number of Miniapp_users
     * const count = await prisma.miniapp_user.count({
     *   where: {
     *     // ... the filter for the Miniapp_users we want to count
     *   }
     * })
    **/
    count<T extends miniapp_userCountArgs>(
      args?: Subset<T, miniapp_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Miniapp_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Miniapp_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Miniapp_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Miniapp_userAggregateArgs>(args: Subset<T, Miniapp_userAggregateArgs>): Prisma.PrismaPromise<GetMiniapp_userAggregateType<T>>

    /**
     * Group by Miniapp_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends miniapp_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: miniapp_userGroupByArgs['orderBy'] }
        : { orderBy?: miniapp_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, miniapp_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiniapp_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the miniapp_user model
   */
  readonly fields: miniapp_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for miniapp_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__miniapp_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    miniapp_generation<T extends miniapp_user$miniapp_generationArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_user$miniapp_generationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findMany"> | Null>
    miniapp_payment<T extends miniapp_user$miniapp_paymentArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_user$miniapp_paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findMany"> | Null>
    social_links<T extends miniapp_user$social_linksArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_user$social_linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the miniapp_user model
   */ 
  interface miniapp_userFieldRefs {
    readonly id: FieldRef<"miniapp_user", 'String'>
    readonly farcaster_id: FieldRef<"miniapp_user", 'String'>
    readonly farcaster_username: FieldRef<"miniapp_user", 'String'>
    readonly farcaster_pfp: FieldRef<"miniapp_user", 'String'>
    readonly wallet_address: FieldRef<"miniapp_user", 'String'>
    readonly created_at: FieldRef<"miniapp_user", 'DateTime'>
    readonly updated_at: FieldRef<"miniapp_user", 'DateTime'>
    readonly notification_token: FieldRef<"miniapp_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * miniapp_user findUnique
   */
  export type miniapp_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_user to fetch.
     */
    where: miniapp_userWhereUniqueInput
  }

  /**
   * miniapp_user findUniqueOrThrow
   */
  export type miniapp_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_user to fetch.
     */
    where: miniapp_userWhereUniqueInput
  }

  /**
   * miniapp_user findFirst
   */
  export type miniapp_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_user to fetch.
     */
    where?: miniapp_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_users to fetch.
     */
    orderBy?: miniapp_userOrderByWithRelationInput | miniapp_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_users.
     */
    cursor?: miniapp_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_users.
     */
    distinct?: Miniapp_userScalarFieldEnum | Miniapp_userScalarFieldEnum[]
  }

  /**
   * miniapp_user findFirstOrThrow
   */
  export type miniapp_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_user to fetch.
     */
    where?: miniapp_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_users to fetch.
     */
    orderBy?: miniapp_userOrderByWithRelationInput | miniapp_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_users.
     */
    cursor?: miniapp_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_users.
     */
    distinct?: Miniapp_userScalarFieldEnum | Miniapp_userScalarFieldEnum[]
  }

  /**
   * miniapp_user findMany
   */
  export type miniapp_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_users to fetch.
     */
    where?: miniapp_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_users to fetch.
     */
    orderBy?: miniapp_userOrderByWithRelationInput | miniapp_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing miniapp_users.
     */
    cursor?: miniapp_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_users.
     */
    skip?: number
    distinct?: Miniapp_userScalarFieldEnum | Miniapp_userScalarFieldEnum[]
  }

  /**
   * miniapp_user create
   */
  export type miniapp_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * The data needed to create a miniapp_user.
     */
    data: XOR<miniapp_userCreateInput, miniapp_userUncheckedCreateInput>
  }

  /**
   * miniapp_user createMany
   */
  export type miniapp_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many miniapp_users.
     */
    data: miniapp_userCreateManyInput | miniapp_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * miniapp_user createManyAndReturn
   */
  export type miniapp_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many miniapp_users.
     */
    data: miniapp_userCreateManyInput | miniapp_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * miniapp_user update
   */
  export type miniapp_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * The data needed to update a miniapp_user.
     */
    data: XOR<miniapp_userUpdateInput, miniapp_userUncheckedUpdateInput>
    /**
     * Choose, which miniapp_user to update.
     */
    where: miniapp_userWhereUniqueInput
  }

  /**
   * miniapp_user updateMany
   */
  export type miniapp_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update miniapp_users.
     */
    data: XOR<miniapp_userUpdateManyMutationInput, miniapp_userUncheckedUpdateManyInput>
    /**
     * Filter which miniapp_users to update
     */
    where?: miniapp_userWhereInput
  }

  /**
   * miniapp_user upsert
   */
  export type miniapp_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * The filter to search for the miniapp_user to update in case it exists.
     */
    where: miniapp_userWhereUniqueInput
    /**
     * In case the miniapp_user found by the `where` argument doesn't exist, create a new miniapp_user with this data.
     */
    create: XOR<miniapp_userCreateInput, miniapp_userUncheckedCreateInput>
    /**
     * In case the miniapp_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<miniapp_userUpdateInput, miniapp_userUncheckedUpdateInput>
  }

  /**
   * miniapp_user delete
   */
  export type miniapp_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    /**
     * Filter which miniapp_user to delete.
     */
    where: miniapp_userWhereUniqueInput
  }

  /**
   * miniapp_user deleteMany
   */
  export type miniapp_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_users to delete
     */
    where?: miniapp_userWhereInput
  }

  /**
   * miniapp_user.miniapp_generation
   */
  export type miniapp_user$miniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    where?: miniapp_generationWhereInput
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    cursor?: miniapp_generationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Miniapp_generationScalarFieldEnum | Miniapp_generationScalarFieldEnum[]
  }

  /**
   * miniapp_user.miniapp_payment
   */
  export type miniapp_user$miniapp_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    where?: miniapp_paymentWhereInput
    orderBy?: miniapp_paymentOrderByWithRelationInput | miniapp_paymentOrderByWithRelationInput[]
    cursor?: miniapp_paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Miniapp_paymentScalarFieldEnum | Miniapp_paymentScalarFieldEnum[]
  }

  /**
   * miniapp_user.social_links
   */
  export type miniapp_user$social_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    where?: social_linkWhereInput
    orderBy?: social_linkOrderByWithRelationInput | social_linkOrderByWithRelationInput[]
    cursor?: social_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Social_linkScalarFieldEnum | Social_linkScalarFieldEnum[]
  }

  /**
   * miniapp_user without action
   */
  export type miniapp_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
  }


  /**
   * Model miniapp_collection_config
   */

  export type AggregateMiniapp_collection_config = {
    _count: Miniapp_collection_configCountAggregateOutputType | null
    _avg: Miniapp_collection_configAvgAggregateOutputType | null
    _sum: Miniapp_collection_configSumAggregateOutputType | null
    _min: Miniapp_collection_configMinAggregateOutputType | null
    _max: Miniapp_collection_configMaxAggregateOutputType | null
  }

  export type Miniapp_collection_configAvgAggregateOutputType = {
    price: number | null
    generations_per_payment: number | null
    max_retries: number | null
  }

  export type Miniapp_collection_configSumAggregateOutputType = {
    price: number | null
    generations_per_payment: number | null
    max_retries: number | null
  }

  export type Miniapp_collection_configMinAggregateOutputType = {
    id: string | null
    collection_id: string | null
    price: number | null
    generations_per_payment: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    max_retries: number | null
  }

  export type Miniapp_collection_configMaxAggregateOutputType = {
    id: string | null
    collection_id: string | null
    price: number | null
    generations_per_payment: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    max_retries: number | null
  }

  export type Miniapp_collection_configCountAggregateOutputType = {
    id: number
    collection_id: number
    price: number
    generations_per_payment: number
    is_active: number
    created_at: number
    updated_at: number
    max_retries: number
    _all: number
  }


  export type Miniapp_collection_configAvgAggregateInputType = {
    price?: true
    generations_per_payment?: true
    max_retries?: true
  }

  export type Miniapp_collection_configSumAggregateInputType = {
    price?: true
    generations_per_payment?: true
    max_retries?: true
  }

  export type Miniapp_collection_configMinAggregateInputType = {
    id?: true
    collection_id?: true
    price?: true
    generations_per_payment?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    max_retries?: true
  }

  export type Miniapp_collection_configMaxAggregateInputType = {
    id?: true
    collection_id?: true
    price?: true
    generations_per_payment?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    max_retries?: true
  }

  export type Miniapp_collection_configCountAggregateInputType = {
    id?: true
    collection_id?: true
    price?: true
    generations_per_payment?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    max_retries?: true
    _all?: true
  }

  export type Miniapp_collection_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_collection_config to aggregate.
     */
    where?: miniapp_collection_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_collection_configs to fetch.
     */
    orderBy?: miniapp_collection_configOrderByWithRelationInput | miniapp_collection_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: miniapp_collection_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_collection_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_collection_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned miniapp_collection_configs
    **/
    _count?: true | Miniapp_collection_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Miniapp_collection_configAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Miniapp_collection_configSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Miniapp_collection_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Miniapp_collection_configMaxAggregateInputType
  }

  export type GetMiniapp_collection_configAggregateType<T extends Miniapp_collection_configAggregateArgs> = {
        [P in keyof T & keyof AggregateMiniapp_collection_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiniapp_collection_config[P]>
      : GetScalarType<T[P], AggregateMiniapp_collection_config[P]>
  }




  export type miniapp_collection_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_collection_configWhereInput
    orderBy?: miniapp_collection_configOrderByWithAggregationInput | miniapp_collection_configOrderByWithAggregationInput[]
    by: Miniapp_collection_configScalarFieldEnum[] | Miniapp_collection_configScalarFieldEnum
    having?: miniapp_collection_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Miniapp_collection_configCountAggregateInputType | true
    _avg?: Miniapp_collection_configAvgAggregateInputType
    _sum?: Miniapp_collection_configSumAggregateInputType
    _min?: Miniapp_collection_configMinAggregateInputType
    _max?: Miniapp_collection_configMaxAggregateInputType
  }

  export type Miniapp_collection_configGroupByOutputType = {
    id: string
    collection_id: string
    price: number
    generations_per_payment: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    max_retries: number
    _count: Miniapp_collection_configCountAggregateOutputType | null
    _avg: Miniapp_collection_configAvgAggregateOutputType | null
    _sum: Miniapp_collection_configSumAggregateOutputType | null
    _min: Miniapp_collection_configMinAggregateOutputType | null
    _max: Miniapp_collection_configMaxAggregateOutputType | null
  }

  type GetMiniapp_collection_configGroupByPayload<T extends miniapp_collection_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Miniapp_collection_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Miniapp_collection_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Miniapp_collection_configGroupByOutputType[P]>
            : GetScalarType<T[P], Miniapp_collection_configGroupByOutputType[P]>
        }
      >
    >


  export type miniapp_collection_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    price?: boolean
    generations_per_payment?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    max_retries?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_collection_config"]>

  export type miniapp_collection_configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_id?: boolean
    price?: boolean
    generations_per_payment?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    max_retries?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_collection_config"]>

  export type miniapp_collection_configSelectScalar = {
    id?: boolean
    collection_id?: boolean
    price?: boolean
    generations_per_payment?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    max_retries?: boolean
  }

  export type miniapp_collection_configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }
  export type miniapp_collection_configIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
  }

  export type $miniapp_collection_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "miniapp_collection_config"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collection_id: string
      price: number
      generations_per_payment: number
      is_active: boolean
      created_at: Date
      updated_at: Date
      max_retries: number
    }, ExtArgs["result"]["miniapp_collection_config"]>
    composites: {}
  }

  type miniapp_collection_configGetPayload<S extends boolean | null | undefined | miniapp_collection_configDefaultArgs> = $Result.GetResult<Prisma.$miniapp_collection_configPayload, S>

  type miniapp_collection_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<miniapp_collection_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Miniapp_collection_configCountAggregateInputType | true
    }

  export interface miniapp_collection_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['miniapp_collection_config'], meta: { name: 'miniapp_collection_config' } }
    /**
     * Find zero or one Miniapp_collection_config that matches the filter.
     * @param {miniapp_collection_configFindUniqueArgs} args - Arguments to find a Miniapp_collection_config
     * @example
     * // Get one Miniapp_collection_config
     * const miniapp_collection_config = await prisma.miniapp_collection_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends miniapp_collection_configFindUniqueArgs>(args: SelectSubset<T, miniapp_collection_configFindUniqueArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Miniapp_collection_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {miniapp_collection_configFindUniqueOrThrowArgs} args - Arguments to find a Miniapp_collection_config
     * @example
     * // Get one Miniapp_collection_config
     * const miniapp_collection_config = await prisma.miniapp_collection_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends miniapp_collection_configFindUniqueOrThrowArgs>(args: SelectSubset<T, miniapp_collection_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Miniapp_collection_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_collection_configFindFirstArgs} args - Arguments to find a Miniapp_collection_config
     * @example
     * // Get one Miniapp_collection_config
     * const miniapp_collection_config = await prisma.miniapp_collection_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends miniapp_collection_configFindFirstArgs>(args?: SelectSubset<T, miniapp_collection_configFindFirstArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Miniapp_collection_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_collection_configFindFirstOrThrowArgs} args - Arguments to find a Miniapp_collection_config
     * @example
     * // Get one Miniapp_collection_config
     * const miniapp_collection_config = await prisma.miniapp_collection_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends miniapp_collection_configFindFirstOrThrowArgs>(args?: SelectSubset<T, miniapp_collection_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Miniapp_collection_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_collection_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Miniapp_collection_configs
     * const miniapp_collection_configs = await prisma.miniapp_collection_config.findMany()
     * 
     * // Get first 10 Miniapp_collection_configs
     * const miniapp_collection_configs = await prisma.miniapp_collection_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miniapp_collection_configWithIdOnly = await prisma.miniapp_collection_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends miniapp_collection_configFindManyArgs>(args?: SelectSubset<T, miniapp_collection_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Miniapp_collection_config.
     * @param {miniapp_collection_configCreateArgs} args - Arguments to create a Miniapp_collection_config.
     * @example
     * // Create one Miniapp_collection_config
     * const Miniapp_collection_config = await prisma.miniapp_collection_config.create({
     *   data: {
     *     // ... data to create a Miniapp_collection_config
     *   }
     * })
     * 
     */
    create<T extends miniapp_collection_configCreateArgs>(args: SelectSubset<T, miniapp_collection_configCreateArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Miniapp_collection_configs.
     * @param {miniapp_collection_configCreateManyArgs} args - Arguments to create many Miniapp_collection_configs.
     * @example
     * // Create many Miniapp_collection_configs
     * const miniapp_collection_config = await prisma.miniapp_collection_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends miniapp_collection_configCreateManyArgs>(args?: SelectSubset<T, miniapp_collection_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Miniapp_collection_configs and returns the data saved in the database.
     * @param {miniapp_collection_configCreateManyAndReturnArgs} args - Arguments to create many Miniapp_collection_configs.
     * @example
     * // Create many Miniapp_collection_configs
     * const miniapp_collection_config = await prisma.miniapp_collection_config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Miniapp_collection_configs and only return the `id`
     * const miniapp_collection_configWithIdOnly = await prisma.miniapp_collection_config.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends miniapp_collection_configCreateManyAndReturnArgs>(args?: SelectSubset<T, miniapp_collection_configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Miniapp_collection_config.
     * @param {miniapp_collection_configDeleteArgs} args - Arguments to delete one Miniapp_collection_config.
     * @example
     * // Delete one Miniapp_collection_config
     * const Miniapp_collection_config = await prisma.miniapp_collection_config.delete({
     *   where: {
     *     // ... filter to delete one Miniapp_collection_config
     *   }
     * })
     * 
     */
    delete<T extends miniapp_collection_configDeleteArgs>(args: SelectSubset<T, miniapp_collection_configDeleteArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Miniapp_collection_config.
     * @param {miniapp_collection_configUpdateArgs} args - Arguments to update one Miniapp_collection_config.
     * @example
     * // Update one Miniapp_collection_config
     * const miniapp_collection_config = await prisma.miniapp_collection_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends miniapp_collection_configUpdateArgs>(args: SelectSubset<T, miniapp_collection_configUpdateArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Miniapp_collection_configs.
     * @param {miniapp_collection_configDeleteManyArgs} args - Arguments to filter Miniapp_collection_configs to delete.
     * @example
     * // Delete a few Miniapp_collection_configs
     * const { count } = await prisma.miniapp_collection_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends miniapp_collection_configDeleteManyArgs>(args?: SelectSubset<T, miniapp_collection_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Miniapp_collection_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_collection_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Miniapp_collection_configs
     * const miniapp_collection_config = await prisma.miniapp_collection_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends miniapp_collection_configUpdateManyArgs>(args: SelectSubset<T, miniapp_collection_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Miniapp_collection_config.
     * @param {miniapp_collection_configUpsertArgs} args - Arguments to update or create a Miniapp_collection_config.
     * @example
     * // Update or create a Miniapp_collection_config
     * const miniapp_collection_config = await prisma.miniapp_collection_config.upsert({
     *   create: {
     *     // ... data to create a Miniapp_collection_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Miniapp_collection_config we want to update
     *   }
     * })
     */
    upsert<T extends miniapp_collection_configUpsertArgs>(args: SelectSubset<T, miniapp_collection_configUpsertArgs<ExtArgs>>): Prisma__miniapp_collection_configClient<$Result.GetResult<Prisma.$miniapp_collection_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Miniapp_collection_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_collection_configCountArgs} args - Arguments to filter Miniapp_collection_configs to count.
     * @example
     * // Count the number of Miniapp_collection_configs
     * const count = await prisma.miniapp_collection_config.count({
     *   where: {
     *     // ... the filter for the Miniapp_collection_configs we want to count
     *   }
     * })
    **/
    count<T extends miniapp_collection_configCountArgs>(
      args?: Subset<T, miniapp_collection_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Miniapp_collection_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Miniapp_collection_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Miniapp_collection_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Miniapp_collection_configAggregateArgs>(args: Subset<T, Miniapp_collection_configAggregateArgs>): Prisma.PrismaPromise<GetMiniapp_collection_configAggregateType<T>>

    /**
     * Group by Miniapp_collection_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_collection_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends miniapp_collection_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: miniapp_collection_configGroupByArgs['orderBy'] }
        : { orderBy?: miniapp_collection_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, miniapp_collection_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiniapp_collection_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the miniapp_collection_config model
   */
  readonly fields: miniapp_collection_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for miniapp_collection_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__miniapp_collection_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the miniapp_collection_config model
   */ 
  interface miniapp_collection_configFieldRefs {
    readonly id: FieldRef<"miniapp_collection_config", 'String'>
    readonly collection_id: FieldRef<"miniapp_collection_config", 'String'>
    readonly price: FieldRef<"miniapp_collection_config", 'Float'>
    readonly generations_per_payment: FieldRef<"miniapp_collection_config", 'Int'>
    readonly is_active: FieldRef<"miniapp_collection_config", 'Boolean'>
    readonly created_at: FieldRef<"miniapp_collection_config", 'DateTime'>
    readonly updated_at: FieldRef<"miniapp_collection_config", 'DateTime'>
    readonly max_retries: FieldRef<"miniapp_collection_config", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * miniapp_collection_config findUnique
   */
  export type miniapp_collection_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_collection_config to fetch.
     */
    where: miniapp_collection_configWhereUniqueInput
  }

  /**
   * miniapp_collection_config findUniqueOrThrow
   */
  export type miniapp_collection_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_collection_config to fetch.
     */
    where: miniapp_collection_configWhereUniqueInput
  }

  /**
   * miniapp_collection_config findFirst
   */
  export type miniapp_collection_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_collection_config to fetch.
     */
    where?: miniapp_collection_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_collection_configs to fetch.
     */
    orderBy?: miniapp_collection_configOrderByWithRelationInput | miniapp_collection_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_collection_configs.
     */
    cursor?: miniapp_collection_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_collection_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_collection_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_collection_configs.
     */
    distinct?: Miniapp_collection_configScalarFieldEnum | Miniapp_collection_configScalarFieldEnum[]
  }

  /**
   * miniapp_collection_config findFirstOrThrow
   */
  export type miniapp_collection_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_collection_config to fetch.
     */
    where?: miniapp_collection_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_collection_configs to fetch.
     */
    orderBy?: miniapp_collection_configOrderByWithRelationInput | miniapp_collection_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_collection_configs.
     */
    cursor?: miniapp_collection_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_collection_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_collection_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_collection_configs.
     */
    distinct?: Miniapp_collection_configScalarFieldEnum | Miniapp_collection_configScalarFieldEnum[]
  }

  /**
   * miniapp_collection_config findMany
   */
  export type miniapp_collection_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_collection_configs to fetch.
     */
    where?: miniapp_collection_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_collection_configs to fetch.
     */
    orderBy?: miniapp_collection_configOrderByWithRelationInput | miniapp_collection_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing miniapp_collection_configs.
     */
    cursor?: miniapp_collection_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_collection_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_collection_configs.
     */
    skip?: number
    distinct?: Miniapp_collection_configScalarFieldEnum | Miniapp_collection_configScalarFieldEnum[]
  }

  /**
   * miniapp_collection_config create
   */
  export type miniapp_collection_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * The data needed to create a miniapp_collection_config.
     */
    data: XOR<miniapp_collection_configCreateInput, miniapp_collection_configUncheckedCreateInput>
  }

  /**
   * miniapp_collection_config createMany
   */
  export type miniapp_collection_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many miniapp_collection_configs.
     */
    data: miniapp_collection_configCreateManyInput | miniapp_collection_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * miniapp_collection_config createManyAndReturn
   */
  export type miniapp_collection_configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many miniapp_collection_configs.
     */
    data: miniapp_collection_configCreateManyInput | miniapp_collection_configCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * miniapp_collection_config update
   */
  export type miniapp_collection_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * The data needed to update a miniapp_collection_config.
     */
    data: XOR<miniapp_collection_configUpdateInput, miniapp_collection_configUncheckedUpdateInput>
    /**
     * Choose, which miniapp_collection_config to update.
     */
    where: miniapp_collection_configWhereUniqueInput
  }

  /**
   * miniapp_collection_config updateMany
   */
  export type miniapp_collection_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update miniapp_collection_configs.
     */
    data: XOR<miniapp_collection_configUpdateManyMutationInput, miniapp_collection_configUncheckedUpdateManyInput>
    /**
     * Filter which miniapp_collection_configs to update
     */
    where?: miniapp_collection_configWhereInput
  }

  /**
   * miniapp_collection_config upsert
   */
  export type miniapp_collection_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * The filter to search for the miniapp_collection_config to update in case it exists.
     */
    where: miniapp_collection_configWhereUniqueInput
    /**
     * In case the miniapp_collection_config found by the `where` argument doesn't exist, create a new miniapp_collection_config with this data.
     */
    create: XOR<miniapp_collection_configCreateInput, miniapp_collection_configUncheckedCreateInput>
    /**
     * In case the miniapp_collection_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<miniapp_collection_configUpdateInput, miniapp_collection_configUncheckedUpdateInput>
  }

  /**
   * miniapp_collection_config delete
   */
  export type miniapp_collection_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
    /**
     * Filter which miniapp_collection_config to delete.
     */
    where: miniapp_collection_configWhereUniqueInput
  }

  /**
   * miniapp_collection_config deleteMany
   */
  export type miniapp_collection_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_collection_configs to delete
     */
    where?: miniapp_collection_configWhereInput
  }

  /**
   * miniapp_collection_config without action
   */
  export type miniapp_collection_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_collection_config
     */
    select?: miniapp_collection_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_collection_configInclude<ExtArgs> | null
  }


  /**
   * Model miniapp_payment
   */

  export type AggregateMiniapp_payment = {
    _count: Miniapp_paymentCountAggregateOutputType | null
    _avg: Miniapp_paymentAvgAggregateOutputType | null
    _sum: Miniapp_paymentSumAggregateOutputType | null
    _min: Miniapp_paymentMinAggregateOutputType | null
    _max: Miniapp_paymentMaxAggregateOutputType | null
  }

  export type Miniapp_paymentAvgAggregateOutputType = {
    amount: number | null
    generations_allowed: number | null
    generations_used: number | null
  }

  export type Miniapp_paymentSumAggregateOutputType = {
    amount: number | null
    generations_allowed: number | null
    generations_used: number | null
  }

  export type Miniapp_paymentMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    collection_id: string | null
    amount: number | null
    transaction_hash: string | null
    payment_status: string | null
    generations_allowed: number | null
    generations_used: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Miniapp_paymentMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    collection_id: string | null
    amount: number | null
    transaction_hash: string | null
    payment_status: string | null
    generations_allowed: number | null
    generations_used: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Miniapp_paymentCountAggregateOutputType = {
    id: number
    user_id: number
    collection_id: number
    amount: number
    transaction_hash: number
    payment_status: number
    generations_allowed: number
    generations_used: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Miniapp_paymentAvgAggregateInputType = {
    amount?: true
    generations_allowed?: true
    generations_used?: true
  }

  export type Miniapp_paymentSumAggregateInputType = {
    amount?: true
    generations_allowed?: true
    generations_used?: true
  }

  export type Miniapp_paymentMinAggregateInputType = {
    id?: true
    user_id?: true
    collection_id?: true
    amount?: true
    transaction_hash?: true
    payment_status?: true
    generations_allowed?: true
    generations_used?: true
    created_at?: true
    updated_at?: true
  }

  export type Miniapp_paymentMaxAggregateInputType = {
    id?: true
    user_id?: true
    collection_id?: true
    amount?: true
    transaction_hash?: true
    payment_status?: true
    generations_allowed?: true
    generations_used?: true
    created_at?: true
    updated_at?: true
  }

  export type Miniapp_paymentCountAggregateInputType = {
    id?: true
    user_id?: true
    collection_id?: true
    amount?: true
    transaction_hash?: true
    payment_status?: true
    generations_allowed?: true
    generations_used?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Miniapp_paymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_payment to aggregate.
     */
    where?: miniapp_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_payments to fetch.
     */
    orderBy?: miniapp_paymentOrderByWithRelationInput | miniapp_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: miniapp_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned miniapp_payments
    **/
    _count?: true | Miniapp_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Miniapp_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Miniapp_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Miniapp_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Miniapp_paymentMaxAggregateInputType
  }

  export type GetMiniapp_paymentAggregateType<T extends Miniapp_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateMiniapp_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiniapp_payment[P]>
      : GetScalarType<T[P], AggregateMiniapp_payment[P]>
  }




  export type miniapp_paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_paymentWhereInput
    orderBy?: miniapp_paymentOrderByWithAggregationInput | miniapp_paymentOrderByWithAggregationInput[]
    by: Miniapp_paymentScalarFieldEnum[] | Miniapp_paymentScalarFieldEnum
    having?: miniapp_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Miniapp_paymentCountAggregateInputType | true
    _avg?: Miniapp_paymentAvgAggregateInputType
    _sum?: Miniapp_paymentSumAggregateInputType
    _min?: Miniapp_paymentMinAggregateInputType
    _max?: Miniapp_paymentMaxAggregateInputType
  }

  export type Miniapp_paymentGroupByOutputType = {
    id: string
    user_id: string
    collection_id: string
    amount: number
    transaction_hash: string | null
    payment_status: string
    generations_allowed: number
    generations_used: number
    created_at: Date
    updated_at: Date
    _count: Miniapp_paymentCountAggregateOutputType | null
    _avg: Miniapp_paymentAvgAggregateOutputType | null
    _sum: Miniapp_paymentSumAggregateOutputType | null
    _min: Miniapp_paymentMinAggregateOutputType | null
    _max: Miniapp_paymentMaxAggregateOutputType | null
  }

  type GetMiniapp_paymentGroupByPayload<T extends miniapp_paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Miniapp_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Miniapp_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Miniapp_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Miniapp_paymentGroupByOutputType[P]>
        }
      >
    >


  export type miniapp_paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    collection_id?: boolean
    amount?: boolean
    transaction_hash?: boolean
    payment_status?: boolean
    generations_allowed?: boolean
    generations_used?: boolean
    created_at?: boolean
    updated_at?: boolean
    miniapp_generation?: boolean | miniapp_payment$miniapp_generationArgs<ExtArgs>
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
    _count?: boolean | Miniapp_paymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_payment"]>

  export type miniapp_paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    collection_id?: boolean
    amount?: boolean
    transaction_hash?: boolean
    payment_status?: boolean
    generations_allowed?: boolean
    generations_used?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_payment"]>

  export type miniapp_paymentSelectScalar = {
    id?: boolean
    user_id?: boolean
    collection_id?: boolean
    amount?: boolean
    transaction_hash?: boolean
    payment_status?: boolean
    generations_allowed?: boolean
    generations_used?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type miniapp_paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniapp_generation?: boolean | miniapp_payment$miniapp_generationArgs<ExtArgs>
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
    _count?: boolean | Miniapp_paymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type miniapp_paymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
  }

  export type $miniapp_paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "miniapp_payment"
    objects: {
      miniapp_generation: Prisma.$miniapp_generationPayload<ExtArgs>[]
      collection: Prisma.$collectionPayload<ExtArgs>
      miniapp_user: Prisma.$miniapp_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      collection_id: string
      amount: number
      transaction_hash: string | null
      payment_status: string
      generations_allowed: number
      generations_used: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["miniapp_payment"]>
    composites: {}
  }

  type miniapp_paymentGetPayload<S extends boolean | null | undefined | miniapp_paymentDefaultArgs> = $Result.GetResult<Prisma.$miniapp_paymentPayload, S>

  type miniapp_paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<miniapp_paymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Miniapp_paymentCountAggregateInputType | true
    }

  export interface miniapp_paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['miniapp_payment'], meta: { name: 'miniapp_payment' } }
    /**
     * Find zero or one Miniapp_payment that matches the filter.
     * @param {miniapp_paymentFindUniqueArgs} args - Arguments to find a Miniapp_payment
     * @example
     * // Get one Miniapp_payment
     * const miniapp_payment = await prisma.miniapp_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends miniapp_paymentFindUniqueArgs>(args: SelectSubset<T, miniapp_paymentFindUniqueArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Miniapp_payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {miniapp_paymentFindUniqueOrThrowArgs} args - Arguments to find a Miniapp_payment
     * @example
     * // Get one Miniapp_payment
     * const miniapp_payment = await prisma.miniapp_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends miniapp_paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, miniapp_paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Miniapp_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_paymentFindFirstArgs} args - Arguments to find a Miniapp_payment
     * @example
     * // Get one Miniapp_payment
     * const miniapp_payment = await prisma.miniapp_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends miniapp_paymentFindFirstArgs>(args?: SelectSubset<T, miniapp_paymentFindFirstArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Miniapp_payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_paymentFindFirstOrThrowArgs} args - Arguments to find a Miniapp_payment
     * @example
     * // Get one Miniapp_payment
     * const miniapp_payment = await prisma.miniapp_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends miniapp_paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, miniapp_paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Miniapp_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Miniapp_payments
     * const miniapp_payments = await prisma.miniapp_payment.findMany()
     * 
     * // Get first 10 Miniapp_payments
     * const miniapp_payments = await prisma.miniapp_payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miniapp_paymentWithIdOnly = await prisma.miniapp_payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends miniapp_paymentFindManyArgs>(args?: SelectSubset<T, miniapp_paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Miniapp_payment.
     * @param {miniapp_paymentCreateArgs} args - Arguments to create a Miniapp_payment.
     * @example
     * // Create one Miniapp_payment
     * const Miniapp_payment = await prisma.miniapp_payment.create({
     *   data: {
     *     // ... data to create a Miniapp_payment
     *   }
     * })
     * 
     */
    create<T extends miniapp_paymentCreateArgs>(args: SelectSubset<T, miniapp_paymentCreateArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Miniapp_payments.
     * @param {miniapp_paymentCreateManyArgs} args - Arguments to create many Miniapp_payments.
     * @example
     * // Create many Miniapp_payments
     * const miniapp_payment = await prisma.miniapp_payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends miniapp_paymentCreateManyArgs>(args?: SelectSubset<T, miniapp_paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Miniapp_payments and returns the data saved in the database.
     * @param {miniapp_paymentCreateManyAndReturnArgs} args - Arguments to create many Miniapp_payments.
     * @example
     * // Create many Miniapp_payments
     * const miniapp_payment = await prisma.miniapp_payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Miniapp_payments and only return the `id`
     * const miniapp_paymentWithIdOnly = await prisma.miniapp_payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends miniapp_paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, miniapp_paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Miniapp_payment.
     * @param {miniapp_paymentDeleteArgs} args - Arguments to delete one Miniapp_payment.
     * @example
     * // Delete one Miniapp_payment
     * const Miniapp_payment = await prisma.miniapp_payment.delete({
     *   where: {
     *     // ... filter to delete one Miniapp_payment
     *   }
     * })
     * 
     */
    delete<T extends miniapp_paymentDeleteArgs>(args: SelectSubset<T, miniapp_paymentDeleteArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Miniapp_payment.
     * @param {miniapp_paymentUpdateArgs} args - Arguments to update one Miniapp_payment.
     * @example
     * // Update one Miniapp_payment
     * const miniapp_payment = await prisma.miniapp_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends miniapp_paymentUpdateArgs>(args: SelectSubset<T, miniapp_paymentUpdateArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Miniapp_payments.
     * @param {miniapp_paymentDeleteManyArgs} args - Arguments to filter Miniapp_payments to delete.
     * @example
     * // Delete a few Miniapp_payments
     * const { count } = await prisma.miniapp_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends miniapp_paymentDeleteManyArgs>(args?: SelectSubset<T, miniapp_paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Miniapp_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Miniapp_payments
     * const miniapp_payment = await prisma.miniapp_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends miniapp_paymentUpdateManyArgs>(args: SelectSubset<T, miniapp_paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Miniapp_payment.
     * @param {miniapp_paymentUpsertArgs} args - Arguments to update or create a Miniapp_payment.
     * @example
     * // Update or create a Miniapp_payment
     * const miniapp_payment = await prisma.miniapp_payment.upsert({
     *   create: {
     *     // ... data to create a Miniapp_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Miniapp_payment we want to update
     *   }
     * })
     */
    upsert<T extends miniapp_paymentUpsertArgs>(args: SelectSubset<T, miniapp_paymentUpsertArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Miniapp_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_paymentCountArgs} args - Arguments to filter Miniapp_payments to count.
     * @example
     * // Count the number of Miniapp_payments
     * const count = await prisma.miniapp_payment.count({
     *   where: {
     *     // ... the filter for the Miniapp_payments we want to count
     *   }
     * })
    **/
    count<T extends miniapp_paymentCountArgs>(
      args?: Subset<T, miniapp_paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Miniapp_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Miniapp_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Miniapp_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Miniapp_paymentAggregateArgs>(args: Subset<T, Miniapp_paymentAggregateArgs>): Prisma.PrismaPromise<GetMiniapp_paymentAggregateType<T>>

    /**
     * Group by Miniapp_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends miniapp_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: miniapp_paymentGroupByArgs['orderBy'] }
        : { orderBy?: miniapp_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, miniapp_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiniapp_paymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the miniapp_payment model
   */
  readonly fields: miniapp_paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for miniapp_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__miniapp_paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    miniapp_generation<T extends miniapp_payment$miniapp_generationArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_payment$miniapp_generationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findMany"> | Null>
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    miniapp_user<T extends miniapp_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_userDefaultArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the miniapp_payment model
   */ 
  interface miniapp_paymentFieldRefs {
    readonly id: FieldRef<"miniapp_payment", 'String'>
    readonly user_id: FieldRef<"miniapp_payment", 'String'>
    readonly collection_id: FieldRef<"miniapp_payment", 'String'>
    readonly amount: FieldRef<"miniapp_payment", 'Float'>
    readonly transaction_hash: FieldRef<"miniapp_payment", 'String'>
    readonly payment_status: FieldRef<"miniapp_payment", 'String'>
    readonly generations_allowed: FieldRef<"miniapp_payment", 'Int'>
    readonly generations_used: FieldRef<"miniapp_payment", 'Int'>
    readonly created_at: FieldRef<"miniapp_payment", 'DateTime'>
    readonly updated_at: FieldRef<"miniapp_payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * miniapp_payment findUnique
   */
  export type miniapp_paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_payment to fetch.
     */
    where: miniapp_paymentWhereUniqueInput
  }

  /**
   * miniapp_payment findUniqueOrThrow
   */
  export type miniapp_paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_payment to fetch.
     */
    where: miniapp_paymentWhereUniqueInput
  }

  /**
   * miniapp_payment findFirst
   */
  export type miniapp_paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_payment to fetch.
     */
    where?: miniapp_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_payments to fetch.
     */
    orderBy?: miniapp_paymentOrderByWithRelationInput | miniapp_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_payments.
     */
    cursor?: miniapp_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_payments.
     */
    distinct?: Miniapp_paymentScalarFieldEnum | Miniapp_paymentScalarFieldEnum[]
  }

  /**
   * miniapp_payment findFirstOrThrow
   */
  export type miniapp_paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_payment to fetch.
     */
    where?: miniapp_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_payments to fetch.
     */
    orderBy?: miniapp_paymentOrderByWithRelationInput | miniapp_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_payments.
     */
    cursor?: miniapp_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_payments.
     */
    distinct?: Miniapp_paymentScalarFieldEnum | Miniapp_paymentScalarFieldEnum[]
  }

  /**
   * miniapp_payment findMany
   */
  export type miniapp_paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_payments to fetch.
     */
    where?: miniapp_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_payments to fetch.
     */
    orderBy?: miniapp_paymentOrderByWithRelationInput | miniapp_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing miniapp_payments.
     */
    cursor?: miniapp_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_payments.
     */
    skip?: number
    distinct?: Miniapp_paymentScalarFieldEnum | Miniapp_paymentScalarFieldEnum[]
  }

  /**
   * miniapp_payment create
   */
  export type miniapp_paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a miniapp_payment.
     */
    data: XOR<miniapp_paymentCreateInput, miniapp_paymentUncheckedCreateInput>
  }

  /**
   * miniapp_payment createMany
   */
  export type miniapp_paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many miniapp_payments.
     */
    data: miniapp_paymentCreateManyInput | miniapp_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * miniapp_payment createManyAndReturn
   */
  export type miniapp_paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many miniapp_payments.
     */
    data: miniapp_paymentCreateManyInput | miniapp_paymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * miniapp_payment update
   */
  export type miniapp_paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a miniapp_payment.
     */
    data: XOR<miniapp_paymentUpdateInput, miniapp_paymentUncheckedUpdateInput>
    /**
     * Choose, which miniapp_payment to update.
     */
    where: miniapp_paymentWhereUniqueInput
  }

  /**
   * miniapp_payment updateMany
   */
  export type miniapp_paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update miniapp_payments.
     */
    data: XOR<miniapp_paymentUpdateManyMutationInput, miniapp_paymentUncheckedUpdateManyInput>
    /**
     * Filter which miniapp_payments to update
     */
    where?: miniapp_paymentWhereInput
  }

  /**
   * miniapp_payment upsert
   */
  export type miniapp_paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the miniapp_payment to update in case it exists.
     */
    where: miniapp_paymentWhereUniqueInput
    /**
     * In case the miniapp_payment found by the `where` argument doesn't exist, create a new miniapp_payment with this data.
     */
    create: XOR<miniapp_paymentCreateInput, miniapp_paymentUncheckedCreateInput>
    /**
     * In case the miniapp_payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<miniapp_paymentUpdateInput, miniapp_paymentUncheckedUpdateInput>
  }

  /**
   * miniapp_payment delete
   */
  export type miniapp_paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    /**
     * Filter which miniapp_payment to delete.
     */
    where: miniapp_paymentWhereUniqueInput
  }

  /**
   * miniapp_payment deleteMany
   */
  export type miniapp_paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_payments to delete
     */
    where?: miniapp_paymentWhereInput
  }

  /**
   * miniapp_payment.miniapp_generation
   */
  export type miniapp_payment$miniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    where?: miniapp_generationWhereInput
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    cursor?: miniapp_generationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Miniapp_generationScalarFieldEnum | Miniapp_generationScalarFieldEnum[]
  }

  /**
   * miniapp_payment without action
   */
  export type miniapp_paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
  }


  /**
   * Model miniapp_generation
   */

  export type AggregateMiniapp_generation = {
    _count: Miniapp_generationCountAggregateOutputType | null
    _avg: Miniapp_generationAvgAggregateOutputType | null
    _sum: Miniapp_generationSumAggregateOutputType | null
    _min: Miniapp_generationMinAggregateOutputType | null
    _max: Miniapp_generationMaxAggregateOutputType | null
  }

  export type Miniapp_generationAvgAggregateOutputType = {
    retry_count: number | null
  }

  export type Miniapp_generationSumAggregateOutputType = {
    retry_count: number | null
  }

  export type Miniapp_generationMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    collection_id: string | null
    payment_id: string | null
    output_url: string | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    job_id: string | null
    generated_image: string | null
    status: $Enums.GenerationStatus | null
    retry_count: number | null
  }

  export type Miniapp_generationMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    collection_id: string | null
    payment_id: string | null
    output_url: string | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    job_id: string | null
    generated_image: string | null
    status: $Enums.GenerationStatus | null
    retry_count: number | null
  }

  export type Miniapp_generationCountAggregateOutputType = {
    id: number
    user_id: number
    collection_id: number
    payment_id: number
    input_data: number
    output_url: number
    output_data: number
    error_message: number
    created_at: number
    updated_at: number
    job_id: number
    generated_image: number
    status: number
    retry_count: number
    _all: number
  }


  export type Miniapp_generationAvgAggregateInputType = {
    retry_count?: true
  }

  export type Miniapp_generationSumAggregateInputType = {
    retry_count?: true
  }

  export type Miniapp_generationMinAggregateInputType = {
    id?: true
    user_id?: true
    collection_id?: true
    payment_id?: true
    output_url?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    job_id?: true
    generated_image?: true
    status?: true
    retry_count?: true
  }

  export type Miniapp_generationMaxAggregateInputType = {
    id?: true
    user_id?: true
    collection_id?: true
    payment_id?: true
    output_url?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    job_id?: true
    generated_image?: true
    status?: true
    retry_count?: true
  }

  export type Miniapp_generationCountAggregateInputType = {
    id?: true
    user_id?: true
    collection_id?: true
    payment_id?: true
    input_data?: true
    output_url?: true
    output_data?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    job_id?: true
    generated_image?: true
    status?: true
    retry_count?: true
    _all?: true
  }

  export type Miniapp_generationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_generation to aggregate.
     */
    where?: miniapp_generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_generations to fetch.
     */
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: miniapp_generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned miniapp_generations
    **/
    _count?: true | Miniapp_generationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Miniapp_generationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Miniapp_generationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Miniapp_generationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Miniapp_generationMaxAggregateInputType
  }

  export type GetMiniapp_generationAggregateType<T extends Miniapp_generationAggregateArgs> = {
        [P in keyof T & keyof AggregateMiniapp_generation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiniapp_generation[P]>
      : GetScalarType<T[P], AggregateMiniapp_generation[P]>
  }




  export type miniapp_generationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: miniapp_generationWhereInput
    orderBy?: miniapp_generationOrderByWithAggregationInput | miniapp_generationOrderByWithAggregationInput[]
    by: Miniapp_generationScalarFieldEnum[] | Miniapp_generationScalarFieldEnum
    having?: miniapp_generationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Miniapp_generationCountAggregateInputType | true
    _avg?: Miniapp_generationAvgAggregateInputType
    _sum?: Miniapp_generationSumAggregateInputType
    _min?: Miniapp_generationMinAggregateInputType
    _max?: Miniapp_generationMaxAggregateInputType
  }

  export type Miniapp_generationGroupByOutputType = {
    id: string
    user_id: string
    collection_id: string
    payment_id: string | null
    input_data: JsonValue | null
    output_url: string | null
    output_data: JsonValue | null
    error_message: string | null
    created_at: Date
    updated_at: Date
    job_id: string | null
    generated_image: string | null
    status: $Enums.GenerationStatus
    retry_count: number
    _count: Miniapp_generationCountAggregateOutputType | null
    _avg: Miniapp_generationAvgAggregateOutputType | null
    _sum: Miniapp_generationSumAggregateOutputType | null
    _min: Miniapp_generationMinAggregateOutputType | null
    _max: Miniapp_generationMaxAggregateOutputType | null
  }

  type GetMiniapp_generationGroupByPayload<T extends miniapp_generationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Miniapp_generationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Miniapp_generationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Miniapp_generationGroupByOutputType[P]>
            : GetScalarType<T[P], Miniapp_generationGroupByOutputType[P]>
        }
      >
    >


  export type miniapp_generationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    collection_id?: boolean
    payment_id?: boolean
    input_data?: boolean
    output_url?: boolean
    output_data?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_id?: boolean
    generated_image?: boolean
    status?: boolean
    retry_count?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_payment?: boolean | miniapp_generation$miniapp_paymentArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_generation"]>

  export type miniapp_generationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    collection_id?: boolean
    payment_id?: boolean
    input_data?: boolean
    output_url?: boolean
    output_data?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_id?: boolean
    generated_image?: boolean
    status?: boolean
    retry_count?: boolean
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_payment?: boolean | miniapp_generation$miniapp_paymentArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniapp_generation"]>

  export type miniapp_generationSelectScalar = {
    id?: boolean
    user_id?: boolean
    collection_id?: boolean
    payment_id?: boolean
    input_data?: boolean
    output_url?: boolean
    output_data?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_id?: boolean
    generated_image?: boolean
    status?: boolean
    retry_count?: boolean
  }

  export type miniapp_generationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_payment?: boolean | miniapp_generation$miniapp_paymentArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
  }
  export type miniapp_generationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | collectionDefaultArgs<ExtArgs>
    miniapp_payment?: boolean | miniapp_generation$miniapp_paymentArgs<ExtArgs>
    miniapp_user?: boolean | miniapp_userDefaultArgs<ExtArgs>
  }

  export type $miniapp_generationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "miniapp_generation"
    objects: {
      collection: Prisma.$collectionPayload<ExtArgs>
      miniapp_payment: Prisma.$miniapp_paymentPayload<ExtArgs> | null
      miniapp_user: Prisma.$miniapp_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      collection_id: string
      payment_id: string | null
      input_data: Prisma.JsonValue | null
      output_url: string | null
      output_data: Prisma.JsonValue | null
      error_message: string | null
      created_at: Date
      updated_at: Date
      job_id: string | null
      generated_image: string | null
      status: $Enums.GenerationStatus
      retry_count: number
    }, ExtArgs["result"]["miniapp_generation"]>
    composites: {}
  }

  type miniapp_generationGetPayload<S extends boolean | null | undefined | miniapp_generationDefaultArgs> = $Result.GetResult<Prisma.$miniapp_generationPayload, S>

  type miniapp_generationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<miniapp_generationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Miniapp_generationCountAggregateInputType | true
    }

  export interface miniapp_generationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['miniapp_generation'], meta: { name: 'miniapp_generation' } }
    /**
     * Find zero or one Miniapp_generation that matches the filter.
     * @param {miniapp_generationFindUniqueArgs} args - Arguments to find a Miniapp_generation
     * @example
     * // Get one Miniapp_generation
     * const miniapp_generation = await prisma.miniapp_generation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends miniapp_generationFindUniqueArgs>(args: SelectSubset<T, miniapp_generationFindUniqueArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Miniapp_generation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {miniapp_generationFindUniqueOrThrowArgs} args - Arguments to find a Miniapp_generation
     * @example
     * // Get one Miniapp_generation
     * const miniapp_generation = await prisma.miniapp_generation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends miniapp_generationFindUniqueOrThrowArgs>(args: SelectSubset<T, miniapp_generationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Miniapp_generation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_generationFindFirstArgs} args - Arguments to find a Miniapp_generation
     * @example
     * // Get one Miniapp_generation
     * const miniapp_generation = await prisma.miniapp_generation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends miniapp_generationFindFirstArgs>(args?: SelectSubset<T, miniapp_generationFindFirstArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Miniapp_generation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_generationFindFirstOrThrowArgs} args - Arguments to find a Miniapp_generation
     * @example
     * // Get one Miniapp_generation
     * const miniapp_generation = await prisma.miniapp_generation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends miniapp_generationFindFirstOrThrowArgs>(args?: SelectSubset<T, miniapp_generationFindFirstOrThrowArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Miniapp_generations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_generationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Miniapp_generations
     * const miniapp_generations = await prisma.miniapp_generation.findMany()
     * 
     * // Get first 10 Miniapp_generations
     * const miniapp_generations = await prisma.miniapp_generation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miniapp_generationWithIdOnly = await prisma.miniapp_generation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends miniapp_generationFindManyArgs>(args?: SelectSubset<T, miniapp_generationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Miniapp_generation.
     * @param {miniapp_generationCreateArgs} args - Arguments to create a Miniapp_generation.
     * @example
     * // Create one Miniapp_generation
     * const Miniapp_generation = await prisma.miniapp_generation.create({
     *   data: {
     *     // ... data to create a Miniapp_generation
     *   }
     * })
     * 
     */
    create<T extends miniapp_generationCreateArgs>(args: SelectSubset<T, miniapp_generationCreateArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Miniapp_generations.
     * @param {miniapp_generationCreateManyArgs} args - Arguments to create many Miniapp_generations.
     * @example
     * // Create many Miniapp_generations
     * const miniapp_generation = await prisma.miniapp_generation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends miniapp_generationCreateManyArgs>(args?: SelectSubset<T, miniapp_generationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Miniapp_generations and returns the data saved in the database.
     * @param {miniapp_generationCreateManyAndReturnArgs} args - Arguments to create many Miniapp_generations.
     * @example
     * // Create many Miniapp_generations
     * const miniapp_generation = await prisma.miniapp_generation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Miniapp_generations and only return the `id`
     * const miniapp_generationWithIdOnly = await prisma.miniapp_generation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends miniapp_generationCreateManyAndReturnArgs>(args?: SelectSubset<T, miniapp_generationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Miniapp_generation.
     * @param {miniapp_generationDeleteArgs} args - Arguments to delete one Miniapp_generation.
     * @example
     * // Delete one Miniapp_generation
     * const Miniapp_generation = await prisma.miniapp_generation.delete({
     *   where: {
     *     // ... filter to delete one Miniapp_generation
     *   }
     * })
     * 
     */
    delete<T extends miniapp_generationDeleteArgs>(args: SelectSubset<T, miniapp_generationDeleteArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Miniapp_generation.
     * @param {miniapp_generationUpdateArgs} args - Arguments to update one Miniapp_generation.
     * @example
     * // Update one Miniapp_generation
     * const miniapp_generation = await prisma.miniapp_generation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends miniapp_generationUpdateArgs>(args: SelectSubset<T, miniapp_generationUpdateArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Miniapp_generations.
     * @param {miniapp_generationDeleteManyArgs} args - Arguments to filter Miniapp_generations to delete.
     * @example
     * // Delete a few Miniapp_generations
     * const { count } = await prisma.miniapp_generation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends miniapp_generationDeleteManyArgs>(args?: SelectSubset<T, miniapp_generationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Miniapp_generations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_generationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Miniapp_generations
     * const miniapp_generation = await prisma.miniapp_generation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends miniapp_generationUpdateManyArgs>(args: SelectSubset<T, miniapp_generationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Miniapp_generation.
     * @param {miniapp_generationUpsertArgs} args - Arguments to update or create a Miniapp_generation.
     * @example
     * // Update or create a Miniapp_generation
     * const miniapp_generation = await prisma.miniapp_generation.upsert({
     *   create: {
     *     // ... data to create a Miniapp_generation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Miniapp_generation we want to update
     *   }
     * })
     */
    upsert<T extends miniapp_generationUpsertArgs>(args: SelectSubset<T, miniapp_generationUpsertArgs<ExtArgs>>): Prisma__miniapp_generationClient<$Result.GetResult<Prisma.$miniapp_generationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Miniapp_generations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_generationCountArgs} args - Arguments to filter Miniapp_generations to count.
     * @example
     * // Count the number of Miniapp_generations
     * const count = await prisma.miniapp_generation.count({
     *   where: {
     *     // ... the filter for the Miniapp_generations we want to count
     *   }
     * })
    **/
    count<T extends miniapp_generationCountArgs>(
      args?: Subset<T, miniapp_generationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Miniapp_generationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Miniapp_generation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Miniapp_generationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Miniapp_generationAggregateArgs>(args: Subset<T, Miniapp_generationAggregateArgs>): Prisma.PrismaPromise<GetMiniapp_generationAggregateType<T>>

    /**
     * Group by Miniapp_generation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miniapp_generationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends miniapp_generationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: miniapp_generationGroupByArgs['orderBy'] }
        : { orderBy?: miniapp_generationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, miniapp_generationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiniapp_generationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the miniapp_generation model
   */
  readonly fields: miniapp_generationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for miniapp_generation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__miniapp_generationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends collectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionDefaultArgs<ExtArgs>>): Prisma__collectionClient<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    miniapp_payment<T extends miniapp_generation$miniapp_paymentArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_generation$miniapp_paymentArgs<ExtArgs>>): Prisma__miniapp_paymentClient<$Result.GetResult<Prisma.$miniapp_paymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    miniapp_user<T extends miniapp_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, miniapp_userDefaultArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the miniapp_generation model
   */ 
  interface miniapp_generationFieldRefs {
    readonly id: FieldRef<"miniapp_generation", 'String'>
    readonly user_id: FieldRef<"miniapp_generation", 'String'>
    readonly collection_id: FieldRef<"miniapp_generation", 'String'>
    readonly payment_id: FieldRef<"miniapp_generation", 'String'>
    readonly input_data: FieldRef<"miniapp_generation", 'Json'>
    readonly output_url: FieldRef<"miniapp_generation", 'String'>
    readonly output_data: FieldRef<"miniapp_generation", 'Json'>
    readonly error_message: FieldRef<"miniapp_generation", 'String'>
    readonly created_at: FieldRef<"miniapp_generation", 'DateTime'>
    readonly updated_at: FieldRef<"miniapp_generation", 'DateTime'>
    readonly job_id: FieldRef<"miniapp_generation", 'String'>
    readonly generated_image: FieldRef<"miniapp_generation", 'String'>
    readonly status: FieldRef<"miniapp_generation", 'GenerationStatus'>
    readonly retry_count: FieldRef<"miniapp_generation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * miniapp_generation findUnique
   */
  export type miniapp_generationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_generation to fetch.
     */
    where: miniapp_generationWhereUniqueInput
  }

  /**
   * miniapp_generation findUniqueOrThrow
   */
  export type miniapp_generationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_generation to fetch.
     */
    where: miniapp_generationWhereUniqueInput
  }

  /**
   * miniapp_generation findFirst
   */
  export type miniapp_generationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_generation to fetch.
     */
    where?: miniapp_generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_generations to fetch.
     */
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_generations.
     */
    cursor?: miniapp_generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_generations.
     */
    distinct?: Miniapp_generationScalarFieldEnum | Miniapp_generationScalarFieldEnum[]
  }

  /**
   * miniapp_generation findFirstOrThrow
   */
  export type miniapp_generationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_generation to fetch.
     */
    where?: miniapp_generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_generations to fetch.
     */
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miniapp_generations.
     */
    cursor?: miniapp_generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miniapp_generations.
     */
    distinct?: Miniapp_generationScalarFieldEnum | Miniapp_generationScalarFieldEnum[]
  }

  /**
   * miniapp_generation findMany
   */
  export type miniapp_generationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * Filter, which miniapp_generations to fetch.
     */
    where?: miniapp_generationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miniapp_generations to fetch.
     */
    orderBy?: miniapp_generationOrderByWithRelationInput | miniapp_generationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing miniapp_generations.
     */
    cursor?: miniapp_generationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miniapp_generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miniapp_generations.
     */
    skip?: number
    distinct?: Miniapp_generationScalarFieldEnum | Miniapp_generationScalarFieldEnum[]
  }

  /**
   * miniapp_generation create
   */
  export type miniapp_generationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * The data needed to create a miniapp_generation.
     */
    data: XOR<miniapp_generationCreateInput, miniapp_generationUncheckedCreateInput>
  }

  /**
   * miniapp_generation createMany
   */
  export type miniapp_generationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many miniapp_generations.
     */
    data: miniapp_generationCreateManyInput | miniapp_generationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * miniapp_generation createManyAndReturn
   */
  export type miniapp_generationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many miniapp_generations.
     */
    data: miniapp_generationCreateManyInput | miniapp_generationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * miniapp_generation update
   */
  export type miniapp_generationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * The data needed to update a miniapp_generation.
     */
    data: XOR<miniapp_generationUpdateInput, miniapp_generationUncheckedUpdateInput>
    /**
     * Choose, which miniapp_generation to update.
     */
    where: miniapp_generationWhereUniqueInput
  }

  /**
   * miniapp_generation updateMany
   */
  export type miniapp_generationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update miniapp_generations.
     */
    data: XOR<miniapp_generationUpdateManyMutationInput, miniapp_generationUncheckedUpdateManyInput>
    /**
     * Filter which miniapp_generations to update
     */
    where?: miniapp_generationWhereInput
  }

  /**
   * miniapp_generation upsert
   */
  export type miniapp_generationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * The filter to search for the miniapp_generation to update in case it exists.
     */
    where: miniapp_generationWhereUniqueInput
    /**
     * In case the miniapp_generation found by the `where` argument doesn't exist, create a new miniapp_generation with this data.
     */
    create: XOR<miniapp_generationCreateInput, miniapp_generationUncheckedCreateInput>
    /**
     * In case the miniapp_generation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<miniapp_generationUpdateInput, miniapp_generationUncheckedUpdateInput>
  }

  /**
   * miniapp_generation delete
   */
  export type miniapp_generationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
    /**
     * Filter which miniapp_generation to delete.
     */
    where: miniapp_generationWhereUniqueInput
  }

  /**
   * miniapp_generation deleteMany
   */
  export type miniapp_generationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which miniapp_generations to delete
     */
    where?: miniapp_generationWhereInput
  }

  /**
   * miniapp_generation.miniapp_payment
   */
  export type miniapp_generation$miniapp_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_payment
     */
    select?: miniapp_paymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_paymentInclude<ExtArgs> | null
    where?: miniapp_paymentWhereInput
  }

  /**
   * miniapp_generation without action
   */
  export type miniapp_generationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_generation
     */
    select?: miniapp_generationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_generationInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    downloadUrl: string | null
    saveTo: string | null
    description: string | null
    fileSize: string | null
    hash: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authEnvVar: string | null
    isAuthReq: boolean | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    downloadUrl: string | null
    saveTo: string | null
    description: string | null
    fileSize: string | null
    hash: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authEnvVar: string | null
    isAuthReq: boolean | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    name: number
    downloadUrl: number
    saveTo: number
    description: number
    fileSize: number
    hash: number
    status: number
    createdAt: number
    updatedAt: number
    authEnvVar: number
    isAuthReq: number
    _all: number
  }


  export type ModelMinAggregateInputType = {
    id?: true
    name?: true
    downloadUrl?: true
    saveTo?: true
    description?: true
    fileSize?: true
    hash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    authEnvVar?: true
    isAuthReq?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    name?: true
    downloadUrl?: true
    saveTo?: true
    description?: true
    fileSize?: true
    hash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    authEnvVar?: true
    isAuthReq?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    name?: true
    downloadUrl?: true
    saveTo?: true
    description?: true
    fileSize?: true
    hash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    authEnvVar?: true
    isAuthReq?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: string
    name: string
    downloadUrl: string
    saveTo: string
    description: string | null
    fileSize: string | null
    hash: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    authEnvVar: string | null
    isAuthReq: boolean
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    downloadUrl?: boolean
    saveTo?: boolean
    description?: boolean
    fileSize?: boolean
    hash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authEnvVar?: boolean
    isAuthReq?: boolean
    workflowModels?: boolean | Model$workflowModelsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    downloadUrl?: boolean
    saveTo?: boolean
    description?: boolean
    fileSize?: boolean
    hash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authEnvVar?: boolean
    isAuthReq?: boolean
  }, ExtArgs["result"]["model"]>

  export type ModelSelectScalar = {
    id?: boolean
    name?: boolean
    downloadUrl?: boolean
    saveTo?: boolean
    description?: boolean
    fileSize?: boolean
    hash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authEnvVar?: boolean
    isAuthReq?: boolean
  }

  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowModels?: boolean | Model$workflowModelsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      workflowModels: Prisma.$WorkflowModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      downloadUrl: string
      saveTo: string
      description: string | null
      fileSize: string | null
      hash: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      authEnvVar: string | null
      isAuthReq: boolean
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Models and returns the data saved in the database.
     * @param {ModelCreateManyAndReturnArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflowModels<T extends Model$workflowModelsArgs<ExtArgs> = {}>(args?: Subset<T, Model$workflowModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */ 
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'String'>
    readonly name: FieldRef<"Model", 'String'>
    readonly downloadUrl: FieldRef<"Model", 'String'>
    readonly saveTo: FieldRef<"Model", 'String'>
    readonly description: FieldRef<"Model", 'String'>
    readonly fileSize: FieldRef<"Model", 'String'>
    readonly hash: FieldRef<"Model", 'String'>
    readonly status: FieldRef<"Model", 'String'>
    readonly createdAt: FieldRef<"Model", 'DateTime'>
    readonly updatedAt: FieldRef<"Model", 'DateTime'>
    readonly authEnvVar: FieldRef<"Model", 'String'>
    readonly isAuthReq: FieldRef<"Model", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model createManyAndReturn
   */
  export type ModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
  }

  /**
   * Model.workflowModels
   */
  export type Model$workflowModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    where?: WorkflowModelWhereInput
    orderBy?: WorkflowModelOrderByWithRelationInput | WorkflowModelOrderByWithRelationInput[]
    cursor?: WorkflowModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowModelScalarFieldEnum | WorkflowModelScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowModel
   */

  export type AggregateWorkflowModel = {
    _count: WorkflowModelCountAggregateOutputType | null
    _min: WorkflowModelMinAggregateOutputType | null
    _max: WorkflowModelMaxAggregateOutputType | null
  }

  export type WorkflowModelMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    modelId: string | null
    isRequired: boolean | null
    createdAt: Date | null
  }

  export type WorkflowModelMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    modelId: string | null
    isRequired: boolean | null
    createdAt: Date | null
  }

  export type WorkflowModelCountAggregateOutputType = {
    id: number
    workflowId: number
    modelId: number
    isRequired: number
    createdAt: number
    _all: number
  }


  export type WorkflowModelMinAggregateInputType = {
    id?: true
    workflowId?: true
    modelId?: true
    isRequired?: true
    createdAt?: true
  }

  export type WorkflowModelMaxAggregateInputType = {
    id?: true
    workflowId?: true
    modelId?: true
    isRequired?: true
    createdAt?: true
  }

  export type WorkflowModelCountAggregateInputType = {
    id?: true
    workflowId?: true
    modelId?: true
    isRequired?: true
    createdAt?: true
    _all?: true
  }

  export type WorkflowModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowModel to aggregate.
     */
    where?: WorkflowModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowModels to fetch.
     */
    orderBy?: WorkflowModelOrderByWithRelationInput | WorkflowModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowModels
    **/
    _count?: true | WorkflowModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowModelMaxAggregateInputType
  }

  export type GetWorkflowModelAggregateType<T extends WorkflowModelAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowModel[P]>
      : GetScalarType<T[P], AggregateWorkflowModel[P]>
  }




  export type WorkflowModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowModelWhereInput
    orderBy?: WorkflowModelOrderByWithAggregationInput | WorkflowModelOrderByWithAggregationInput[]
    by: WorkflowModelScalarFieldEnum[] | WorkflowModelScalarFieldEnum
    having?: WorkflowModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowModelCountAggregateInputType | true
    _min?: WorkflowModelMinAggregateInputType
    _max?: WorkflowModelMaxAggregateInputType
  }

  export type WorkflowModelGroupByOutputType = {
    id: string
    workflowId: string
    modelId: string
    isRequired: boolean
    createdAt: Date
    _count: WorkflowModelCountAggregateOutputType | null
    _min: WorkflowModelMinAggregateOutputType | null
    _max: WorkflowModelMaxAggregateOutputType | null
  }

  type GetWorkflowModelGroupByPayload<T extends WorkflowModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowModelGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowModelGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    modelId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowModel"]>

  export type WorkflowModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    modelId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowModel"]>

  export type WorkflowModelSelectScalar = {
    id?: boolean
    workflowId?: boolean
    modelId?: boolean
    isRequired?: boolean
    createdAt?: boolean
  }

  export type WorkflowModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }
  export type WorkflowModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }

  export type $WorkflowModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowModel"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      workflow: Prisma.$workflowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      modelId: string
      isRequired: boolean
      createdAt: Date
    }, ExtArgs["result"]["workflowModel"]>
    composites: {}
  }

  type WorkflowModelGetPayload<S extends boolean | null | undefined | WorkflowModelDefaultArgs> = $Result.GetResult<Prisma.$WorkflowModelPayload, S>

  type WorkflowModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowModelCountAggregateInputType | true
    }

  export interface WorkflowModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowModel'], meta: { name: 'WorkflowModel' } }
    /**
     * Find zero or one WorkflowModel that matches the filter.
     * @param {WorkflowModelFindUniqueArgs} args - Arguments to find a WorkflowModel
     * @example
     * // Get one WorkflowModel
     * const workflowModel = await prisma.workflowModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowModelFindUniqueArgs>(args: SelectSubset<T, WorkflowModelFindUniqueArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowModelFindUniqueOrThrowArgs} args - Arguments to find a WorkflowModel
     * @example
     * // Get one WorkflowModel
     * const workflowModel = await prisma.workflowModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowModelFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelFindFirstArgs} args - Arguments to find a WorkflowModel
     * @example
     * // Get one WorkflowModel
     * const workflowModel = await prisma.workflowModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowModelFindFirstArgs>(args?: SelectSubset<T, WorkflowModelFindFirstArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelFindFirstOrThrowArgs} args - Arguments to find a WorkflowModel
     * @example
     * // Get one WorkflowModel
     * const workflowModel = await prisma.workflowModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowModelFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowModels
     * const workflowModels = await prisma.workflowModel.findMany()
     * 
     * // Get first 10 WorkflowModels
     * const workflowModels = await prisma.workflowModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowModelWithIdOnly = await prisma.workflowModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowModelFindManyArgs>(args?: SelectSubset<T, WorkflowModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowModel.
     * @param {WorkflowModelCreateArgs} args - Arguments to create a WorkflowModel.
     * @example
     * // Create one WorkflowModel
     * const WorkflowModel = await prisma.workflowModel.create({
     *   data: {
     *     // ... data to create a WorkflowModel
     *   }
     * })
     * 
     */
    create<T extends WorkflowModelCreateArgs>(args: SelectSubset<T, WorkflowModelCreateArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowModels.
     * @param {WorkflowModelCreateManyArgs} args - Arguments to create many WorkflowModels.
     * @example
     * // Create many WorkflowModels
     * const workflowModel = await prisma.workflowModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowModelCreateManyArgs>(args?: SelectSubset<T, WorkflowModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowModels and returns the data saved in the database.
     * @param {WorkflowModelCreateManyAndReturnArgs} args - Arguments to create many WorkflowModels.
     * @example
     * // Create many WorkflowModels
     * const workflowModel = await prisma.workflowModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowModels and only return the `id`
     * const workflowModelWithIdOnly = await prisma.workflowModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowModelCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowModel.
     * @param {WorkflowModelDeleteArgs} args - Arguments to delete one WorkflowModel.
     * @example
     * // Delete one WorkflowModel
     * const WorkflowModel = await prisma.workflowModel.delete({
     *   where: {
     *     // ... filter to delete one WorkflowModel
     *   }
     * })
     * 
     */
    delete<T extends WorkflowModelDeleteArgs>(args: SelectSubset<T, WorkflowModelDeleteArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowModel.
     * @param {WorkflowModelUpdateArgs} args - Arguments to update one WorkflowModel.
     * @example
     * // Update one WorkflowModel
     * const workflowModel = await prisma.workflowModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowModelUpdateArgs>(args: SelectSubset<T, WorkflowModelUpdateArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowModels.
     * @param {WorkflowModelDeleteManyArgs} args - Arguments to filter WorkflowModels to delete.
     * @example
     * // Delete a few WorkflowModels
     * const { count } = await prisma.workflowModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowModelDeleteManyArgs>(args?: SelectSubset<T, WorkflowModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowModels
     * const workflowModel = await prisma.workflowModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowModelUpdateManyArgs>(args: SelectSubset<T, WorkflowModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowModel.
     * @param {WorkflowModelUpsertArgs} args - Arguments to update or create a WorkflowModel.
     * @example
     * // Update or create a WorkflowModel
     * const workflowModel = await prisma.workflowModel.upsert({
     *   create: {
     *     // ... data to create a WorkflowModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowModel we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowModelUpsertArgs>(args: SelectSubset<T, WorkflowModelUpsertArgs<ExtArgs>>): Prisma__WorkflowModelClient<$Result.GetResult<Prisma.$WorkflowModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelCountArgs} args - Arguments to filter WorkflowModels to count.
     * @example
     * // Count the number of WorkflowModels
     * const count = await prisma.workflowModel.count({
     *   where: {
     *     // ... the filter for the WorkflowModels we want to count
     *   }
     * })
    **/
    count<T extends WorkflowModelCountArgs>(
      args?: Subset<T, WorkflowModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowModelAggregateArgs>(args: Subset<T, WorkflowModelAggregateArgs>): Prisma.PrismaPromise<GetWorkflowModelAggregateType<T>>

    /**
     * Group by WorkflowModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowModelGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowModel model
   */
  readonly fields: WorkflowModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workflow<T extends workflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, workflowDefaultArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowModel model
   */ 
  interface WorkflowModelFieldRefs {
    readonly id: FieldRef<"WorkflowModel", 'String'>
    readonly workflowId: FieldRef<"WorkflowModel", 'String'>
    readonly modelId: FieldRef<"WorkflowModel", 'String'>
    readonly isRequired: FieldRef<"WorkflowModel", 'Boolean'>
    readonly createdAt: FieldRef<"WorkflowModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowModel findUnique
   */
  export type WorkflowModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowModel to fetch.
     */
    where: WorkflowModelWhereUniqueInput
  }

  /**
   * WorkflowModel findUniqueOrThrow
   */
  export type WorkflowModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowModel to fetch.
     */
    where: WorkflowModelWhereUniqueInput
  }

  /**
   * WorkflowModel findFirst
   */
  export type WorkflowModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowModel to fetch.
     */
    where?: WorkflowModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowModels to fetch.
     */
    orderBy?: WorkflowModelOrderByWithRelationInput | WorkflowModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowModels.
     */
    cursor?: WorkflowModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowModels.
     */
    distinct?: WorkflowModelScalarFieldEnum | WorkflowModelScalarFieldEnum[]
  }

  /**
   * WorkflowModel findFirstOrThrow
   */
  export type WorkflowModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowModel to fetch.
     */
    where?: WorkflowModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowModels to fetch.
     */
    orderBy?: WorkflowModelOrderByWithRelationInput | WorkflowModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowModels.
     */
    cursor?: WorkflowModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowModels.
     */
    distinct?: WorkflowModelScalarFieldEnum | WorkflowModelScalarFieldEnum[]
  }

  /**
   * WorkflowModel findMany
   */
  export type WorkflowModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowModels to fetch.
     */
    where?: WorkflowModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowModels to fetch.
     */
    orderBy?: WorkflowModelOrderByWithRelationInput | WorkflowModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowModels.
     */
    cursor?: WorkflowModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowModels.
     */
    skip?: number
    distinct?: WorkflowModelScalarFieldEnum | WorkflowModelScalarFieldEnum[]
  }

  /**
   * WorkflowModel create
   */
  export type WorkflowModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowModel.
     */
    data: XOR<WorkflowModelCreateInput, WorkflowModelUncheckedCreateInput>
  }

  /**
   * WorkflowModel createMany
   */
  export type WorkflowModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowModels.
     */
    data: WorkflowModelCreateManyInput | WorkflowModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowModel createManyAndReturn
   */
  export type WorkflowModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowModels.
     */
    data: WorkflowModelCreateManyInput | WorkflowModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowModel update
   */
  export type WorkflowModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowModel.
     */
    data: XOR<WorkflowModelUpdateInput, WorkflowModelUncheckedUpdateInput>
    /**
     * Choose, which WorkflowModel to update.
     */
    where: WorkflowModelWhereUniqueInput
  }

  /**
   * WorkflowModel updateMany
   */
  export type WorkflowModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowModels.
     */
    data: XOR<WorkflowModelUpdateManyMutationInput, WorkflowModelUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowModels to update
     */
    where?: WorkflowModelWhereInput
  }

  /**
   * WorkflowModel upsert
   */
  export type WorkflowModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowModel to update in case it exists.
     */
    where: WorkflowModelWhereUniqueInput
    /**
     * In case the WorkflowModel found by the `where` argument doesn't exist, create a new WorkflowModel with this data.
     */
    create: XOR<WorkflowModelCreateInput, WorkflowModelUncheckedCreateInput>
    /**
     * In case the WorkflowModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowModelUpdateInput, WorkflowModelUncheckedUpdateInput>
  }

  /**
   * WorkflowModel delete
   */
  export type WorkflowModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
    /**
     * Filter which WorkflowModel to delete.
     */
    where: WorkflowModelWhereUniqueInput
  }

  /**
   * WorkflowModel deleteMany
   */
  export type WorkflowModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowModels to delete
     */
    where?: WorkflowModelWhereInput
  }

  /**
   * WorkflowModel without action
   */
  export type WorkflowModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowModel
     */
    select?: WorkflowModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowModelInclude<ExtArgs> | null
  }


  /**
   * Model component_flat_file_recover
   */

  export type AggregateComponent_flat_file_recover = {
    _count: Component_flat_file_recoverCountAggregateOutputType | null
    _avg: Component_flat_file_recoverAvgAggregateOutputType | null
    _sum: Component_flat_file_recoverSumAggregateOutputType | null
    _min: Component_flat_file_recoverMinAggregateOutputType | null
    _max: Component_flat_file_recoverMaxAggregateOutputType | null
  }

  export type Component_flat_file_recoverAvgAggregateOutputType = {
    id: number | null
    component_id: number | null
    flat_file_id: number | null
  }

  export type Component_flat_file_recoverSumAggregateOutputType = {
    id: bigint | null
    component_id: bigint | null
    flat_file_id: bigint | null
  }

  export type Component_flat_file_recoverMinAggregateOutputType = {
    id: bigint | null
    component_id: bigint | null
    flat_file_id: bigint | null
    recovered_at: Date | null
    issue_type: string | null
  }

  export type Component_flat_file_recoverMaxAggregateOutputType = {
    id: bigint | null
    component_id: bigint | null
    flat_file_id: bigint | null
    recovered_at: Date | null
    issue_type: string | null
  }

  export type Component_flat_file_recoverCountAggregateOutputType = {
    id: number
    component_id: number
    flat_file_id: number
    recovered_at: number
    issue_type: number
    _all: number
  }


  export type Component_flat_file_recoverAvgAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
  }

  export type Component_flat_file_recoverSumAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
  }

  export type Component_flat_file_recoverMinAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
    recovered_at?: true
    issue_type?: true
  }

  export type Component_flat_file_recoverMaxAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
    recovered_at?: true
    issue_type?: true
  }

  export type Component_flat_file_recoverCountAggregateInputType = {
    id?: true
    component_id?: true
    flat_file_id?: true
    recovered_at?: true
    issue_type?: true
    _all?: true
  }

  export type Component_flat_file_recoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which component_flat_file_recover to aggregate.
     */
    where?: component_flat_file_recoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_file_recovers to fetch.
     */
    orderBy?: component_flat_file_recoverOrderByWithRelationInput | component_flat_file_recoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: component_flat_file_recoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_file_recovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_file_recovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned component_flat_file_recovers
    **/
    _count?: true | Component_flat_file_recoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Component_flat_file_recoverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Component_flat_file_recoverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Component_flat_file_recoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Component_flat_file_recoverMaxAggregateInputType
  }

  export type GetComponent_flat_file_recoverAggregateType<T extends Component_flat_file_recoverAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent_flat_file_recover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent_flat_file_recover[P]>
      : GetScalarType<T[P], AggregateComponent_flat_file_recover[P]>
  }




  export type component_flat_file_recoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: component_flat_file_recoverWhereInput
    orderBy?: component_flat_file_recoverOrderByWithAggregationInput | component_flat_file_recoverOrderByWithAggregationInput[]
    by: Component_flat_file_recoverScalarFieldEnum[] | Component_flat_file_recoverScalarFieldEnum
    having?: component_flat_file_recoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Component_flat_file_recoverCountAggregateInputType | true
    _avg?: Component_flat_file_recoverAvgAggregateInputType
    _sum?: Component_flat_file_recoverSumAggregateInputType
    _min?: Component_flat_file_recoverMinAggregateInputType
    _max?: Component_flat_file_recoverMaxAggregateInputType
  }

  export type Component_flat_file_recoverGroupByOutputType = {
    id: bigint
    component_id: bigint
    flat_file_id: bigint
    recovered_at: Date
    issue_type: string
    _count: Component_flat_file_recoverCountAggregateOutputType | null
    _avg: Component_flat_file_recoverAvgAggregateOutputType | null
    _sum: Component_flat_file_recoverSumAggregateOutputType | null
    _min: Component_flat_file_recoverMinAggregateOutputType | null
    _max: Component_flat_file_recoverMaxAggregateOutputType | null
  }

  type GetComponent_flat_file_recoverGroupByPayload<T extends component_flat_file_recoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Component_flat_file_recoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Component_flat_file_recoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Component_flat_file_recoverGroupByOutputType[P]>
            : GetScalarType<T[P], Component_flat_file_recoverGroupByOutputType[P]>
        }
      >
    >


  export type component_flat_file_recoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component_id?: boolean
    flat_file_id?: boolean
    recovered_at?: boolean
    issue_type?: boolean
  }, ExtArgs["result"]["component_flat_file_recover"]>

  export type component_flat_file_recoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    component_id?: boolean
    flat_file_id?: boolean
    recovered_at?: boolean
    issue_type?: boolean
  }, ExtArgs["result"]["component_flat_file_recover"]>

  export type component_flat_file_recoverSelectScalar = {
    id?: boolean
    component_id?: boolean
    flat_file_id?: boolean
    recovered_at?: boolean
    issue_type?: boolean
  }


  export type $component_flat_file_recoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "component_flat_file_recover"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      component_id: bigint
      flat_file_id: bigint
      recovered_at: Date
      issue_type: string
    }, ExtArgs["result"]["component_flat_file_recover"]>
    composites: {}
  }

  type component_flat_file_recoverGetPayload<S extends boolean | null | undefined | component_flat_file_recoverDefaultArgs> = $Result.GetResult<Prisma.$component_flat_file_recoverPayload, S>

  type component_flat_file_recoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<component_flat_file_recoverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Component_flat_file_recoverCountAggregateInputType | true
    }

  export interface component_flat_file_recoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['component_flat_file_recover'], meta: { name: 'component_flat_file_recover' } }
    /**
     * Find zero or one Component_flat_file_recover that matches the filter.
     * @param {component_flat_file_recoverFindUniqueArgs} args - Arguments to find a Component_flat_file_recover
     * @example
     * // Get one Component_flat_file_recover
     * const component_flat_file_recover = await prisma.component_flat_file_recover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends component_flat_file_recoverFindUniqueArgs>(args: SelectSubset<T, component_flat_file_recoverFindUniqueArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Component_flat_file_recover that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {component_flat_file_recoverFindUniqueOrThrowArgs} args - Arguments to find a Component_flat_file_recover
     * @example
     * // Get one Component_flat_file_recover
     * const component_flat_file_recover = await prisma.component_flat_file_recover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends component_flat_file_recoverFindUniqueOrThrowArgs>(args: SelectSubset<T, component_flat_file_recoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Component_flat_file_recover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_file_recoverFindFirstArgs} args - Arguments to find a Component_flat_file_recover
     * @example
     * // Get one Component_flat_file_recover
     * const component_flat_file_recover = await prisma.component_flat_file_recover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends component_flat_file_recoverFindFirstArgs>(args?: SelectSubset<T, component_flat_file_recoverFindFirstArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Component_flat_file_recover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_file_recoverFindFirstOrThrowArgs} args - Arguments to find a Component_flat_file_recover
     * @example
     * // Get one Component_flat_file_recover
     * const component_flat_file_recover = await prisma.component_flat_file_recover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends component_flat_file_recoverFindFirstOrThrowArgs>(args?: SelectSubset<T, component_flat_file_recoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Component_flat_file_recovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_file_recoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Component_flat_file_recovers
     * const component_flat_file_recovers = await prisma.component_flat_file_recover.findMany()
     * 
     * // Get first 10 Component_flat_file_recovers
     * const component_flat_file_recovers = await prisma.component_flat_file_recover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const component_flat_file_recoverWithIdOnly = await prisma.component_flat_file_recover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends component_flat_file_recoverFindManyArgs>(args?: SelectSubset<T, component_flat_file_recoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Component_flat_file_recover.
     * @param {component_flat_file_recoverCreateArgs} args - Arguments to create a Component_flat_file_recover.
     * @example
     * // Create one Component_flat_file_recover
     * const Component_flat_file_recover = await prisma.component_flat_file_recover.create({
     *   data: {
     *     // ... data to create a Component_flat_file_recover
     *   }
     * })
     * 
     */
    create<T extends component_flat_file_recoverCreateArgs>(args: SelectSubset<T, component_flat_file_recoverCreateArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Component_flat_file_recovers.
     * @param {component_flat_file_recoverCreateManyArgs} args - Arguments to create many Component_flat_file_recovers.
     * @example
     * // Create many Component_flat_file_recovers
     * const component_flat_file_recover = await prisma.component_flat_file_recover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends component_flat_file_recoverCreateManyArgs>(args?: SelectSubset<T, component_flat_file_recoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Component_flat_file_recovers and returns the data saved in the database.
     * @param {component_flat_file_recoverCreateManyAndReturnArgs} args - Arguments to create many Component_flat_file_recovers.
     * @example
     * // Create many Component_flat_file_recovers
     * const component_flat_file_recover = await prisma.component_flat_file_recover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Component_flat_file_recovers and only return the `id`
     * const component_flat_file_recoverWithIdOnly = await prisma.component_flat_file_recover.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends component_flat_file_recoverCreateManyAndReturnArgs>(args?: SelectSubset<T, component_flat_file_recoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Component_flat_file_recover.
     * @param {component_flat_file_recoverDeleteArgs} args - Arguments to delete one Component_flat_file_recover.
     * @example
     * // Delete one Component_flat_file_recover
     * const Component_flat_file_recover = await prisma.component_flat_file_recover.delete({
     *   where: {
     *     // ... filter to delete one Component_flat_file_recover
     *   }
     * })
     * 
     */
    delete<T extends component_flat_file_recoverDeleteArgs>(args: SelectSubset<T, component_flat_file_recoverDeleteArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Component_flat_file_recover.
     * @param {component_flat_file_recoverUpdateArgs} args - Arguments to update one Component_flat_file_recover.
     * @example
     * // Update one Component_flat_file_recover
     * const component_flat_file_recover = await prisma.component_flat_file_recover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends component_flat_file_recoverUpdateArgs>(args: SelectSubset<T, component_flat_file_recoverUpdateArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Component_flat_file_recovers.
     * @param {component_flat_file_recoverDeleteManyArgs} args - Arguments to filter Component_flat_file_recovers to delete.
     * @example
     * // Delete a few Component_flat_file_recovers
     * const { count } = await prisma.component_flat_file_recover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends component_flat_file_recoverDeleteManyArgs>(args?: SelectSubset<T, component_flat_file_recoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Component_flat_file_recovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_file_recoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Component_flat_file_recovers
     * const component_flat_file_recover = await prisma.component_flat_file_recover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends component_flat_file_recoverUpdateManyArgs>(args: SelectSubset<T, component_flat_file_recoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component_flat_file_recover.
     * @param {component_flat_file_recoverUpsertArgs} args - Arguments to update or create a Component_flat_file_recover.
     * @example
     * // Update or create a Component_flat_file_recover
     * const component_flat_file_recover = await prisma.component_flat_file_recover.upsert({
     *   create: {
     *     // ... data to create a Component_flat_file_recover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component_flat_file_recover we want to update
     *   }
     * })
     */
    upsert<T extends component_flat_file_recoverUpsertArgs>(args: SelectSubset<T, component_flat_file_recoverUpsertArgs<ExtArgs>>): Prisma__component_flat_file_recoverClient<$Result.GetResult<Prisma.$component_flat_file_recoverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Component_flat_file_recovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_file_recoverCountArgs} args - Arguments to filter Component_flat_file_recovers to count.
     * @example
     * // Count the number of Component_flat_file_recovers
     * const count = await prisma.component_flat_file_recover.count({
     *   where: {
     *     // ... the filter for the Component_flat_file_recovers we want to count
     *   }
     * })
    **/
    count<T extends component_flat_file_recoverCountArgs>(
      args?: Subset<T, component_flat_file_recoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Component_flat_file_recoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component_flat_file_recover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Component_flat_file_recoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Component_flat_file_recoverAggregateArgs>(args: Subset<T, Component_flat_file_recoverAggregateArgs>): Prisma.PrismaPromise<GetComponent_flat_file_recoverAggregateType<T>>

    /**
     * Group by Component_flat_file_recover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {component_flat_file_recoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends component_flat_file_recoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: component_flat_file_recoverGroupByArgs['orderBy'] }
        : { orderBy?: component_flat_file_recoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, component_flat_file_recoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponent_flat_file_recoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the component_flat_file_recover model
   */
  readonly fields: component_flat_file_recoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for component_flat_file_recover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__component_flat_file_recoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the component_flat_file_recover model
   */ 
  interface component_flat_file_recoverFieldRefs {
    readonly id: FieldRef<"component_flat_file_recover", 'BigInt'>
    readonly component_id: FieldRef<"component_flat_file_recover", 'BigInt'>
    readonly flat_file_id: FieldRef<"component_flat_file_recover", 'BigInt'>
    readonly recovered_at: FieldRef<"component_flat_file_recover", 'DateTime'>
    readonly issue_type: FieldRef<"component_flat_file_recover", 'String'>
  }
    

  // Custom InputTypes
  /**
   * component_flat_file_recover findUnique
   */
  export type component_flat_file_recoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * Filter, which component_flat_file_recover to fetch.
     */
    where: component_flat_file_recoverWhereUniqueInput
  }

  /**
   * component_flat_file_recover findUniqueOrThrow
   */
  export type component_flat_file_recoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * Filter, which component_flat_file_recover to fetch.
     */
    where: component_flat_file_recoverWhereUniqueInput
  }

  /**
   * component_flat_file_recover findFirst
   */
  export type component_flat_file_recoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * Filter, which component_flat_file_recover to fetch.
     */
    where?: component_flat_file_recoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_file_recovers to fetch.
     */
    orderBy?: component_flat_file_recoverOrderByWithRelationInput | component_flat_file_recoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for component_flat_file_recovers.
     */
    cursor?: component_flat_file_recoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_file_recovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_file_recovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of component_flat_file_recovers.
     */
    distinct?: Component_flat_file_recoverScalarFieldEnum | Component_flat_file_recoverScalarFieldEnum[]
  }

  /**
   * component_flat_file_recover findFirstOrThrow
   */
  export type component_flat_file_recoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * Filter, which component_flat_file_recover to fetch.
     */
    where?: component_flat_file_recoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_file_recovers to fetch.
     */
    orderBy?: component_flat_file_recoverOrderByWithRelationInput | component_flat_file_recoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for component_flat_file_recovers.
     */
    cursor?: component_flat_file_recoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_file_recovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_file_recovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of component_flat_file_recovers.
     */
    distinct?: Component_flat_file_recoverScalarFieldEnum | Component_flat_file_recoverScalarFieldEnum[]
  }

  /**
   * component_flat_file_recover findMany
   */
  export type component_flat_file_recoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * Filter, which component_flat_file_recovers to fetch.
     */
    where?: component_flat_file_recoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of component_flat_file_recovers to fetch.
     */
    orderBy?: component_flat_file_recoverOrderByWithRelationInput | component_flat_file_recoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing component_flat_file_recovers.
     */
    cursor?: component_flat_file_recoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` component_flat_file_recovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` component_flat_file_recovers.
     */
    skip?: number
    distinct?: Component_flat_file_recoverScalarFieldEnum | Component_flat_file_recoverScalarFieldEnum[]
  }

  /**
   * component_flat_file_recover create
   */
  export type component_flat_file_recoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * The data needed to create a component_flat_file_recover.
     */
    data: XOR<component_flat_file_recoverCreateInput, component_flat_file_recoverUncheckedCreateInput>
  }

  /**
   * component_flat_file_recover createMany
   */
  export type component_flat_file_recoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many component_flat_file_recovers.
     */
    data: component_flat_file_recoverCreateManyInput | component_flat_file_recoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * component_flat_file_recover createManyAndReturn
   */
  export type component_flat_file_recoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many component_flat_file_recovers.
     */
    data: component_flat_file_recoverCreateManyInput | component_flat_file_recoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * component_flat_file_recover update
   */
  export type component_flat_file_recoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * The data needed to update a component_flat_file_recover.
     */
    data: XOR<component_flat_file_recoverUpdateInput, component_flat_file_recoverUncheckedUpdateInput>
    /**
     * Choose, which component_flat_file_recover to update.
     */
    where: component_flat_file_recoverWhereUniqueInput
  }

  /**
   * component_flat_file_recover updateMany
   */
  export type component_flat_file_recoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update component_flat_file_recovers.
     */
    data: XOR<component_flat_file_recoverUpdateManyMutationInput, component_flat_file_recoverUncheckedUpdateManyInput>
    /**
     * Filter which component_flat_file_recovers to update
     */
    where?: component_flat_file_recoverWhereInput
  }

  /**
   * component_flat_file_recover upsert
   */
  export type component_flat_file_recoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * The filter to search for the component_flat_file_recover to update in case it exists.
     */
    where: component_flat_file_recoverWhereUniqueInput
    /**
     * In case the component_flat_file_recover found by the `where` argument doesn't exist, create a new component_flat_file_recover with this data.
     */
    create: XOR<component_flat_file_recoverCreateInput, component_flat_file_recoverUncheckedCreateInput>
    /**
     * In case the component_flat_file_recover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<component_flat_file_recoverUpdateInput, component_flat_file_recoverUncheckedUpdateInput>
  }

  /**
   * component_flat_file_recover delete
   */
  export type component_flat_file_recoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
    /**
     * Filter which component_flat_file_recover to delete.
     */
    where: component_flat_file_recoverWhereUniqueInput
  }

  /**
   * component_flat_file_recover deleteMany
   */
  export type component_flat_file_recoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which component_flat_file_recovers to delete
     */
    where?: component_flat_file_recoverWhereInput
  }

  /**
   * component_flat_file_recover without action
   */
  export type component_flat_file_recoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the component_flat_file_recover
     */
    select?: component_flat_file_recoverSelect<ExtArgs> | null
  }


  /**
   * Model social_link
   */

  export type AggregateSocial_link = {
    _count: Social_linkCountAggregateOutputType | null
    _min: Social_linkMinAggregateOutputType | null
    _max: Social_linkMaxAggregateOutputType | null
  }

  export type Social_linkMinAggregateOutputType = {
    id: string | null
    social_org: $Enums.social_org_enum | null
    identifier: string | null
    created_at: Date | null
    updated_at: Date | null
    miniapp_user_id: string | null
  }

  export type Social_linkMaxAggregateOutputType = {
    id: string | null
    social_org: $Enums.social_org_enum | null
    identifier: string | null
    created_at: Date | null
    updated_at: Date | null
    miniapp_user_id: string | null
  }

  export type Social_linkCountAggregateOutputType = {
    id: number
    social_org: number
    identifier: number
    created_at: number
    updated_at: number
    miniapp_user_id: number
    _all: number
  }


  export type Social_linkMinAggregateInputType = {
    id?: true
    social_org?: true
    identifier?: true
    created_at?: true
    updated_at?: true
    miniapp_user_id?: true
  }

  export type Social_linkMaxAggregateInputType = {
    id?: true
    social_org?: true
    identifier?: true
    created_at?: true
    updated_at?: true
    miniapp_user_id?: true
  }

  export type Social_linkCountAggregateInputType = {
    id?: true
    social_org?: true
    identifier?: true
    created_at?: true
    updated_at?: true
    miniapp_user_id?: true
    _all?: true
  }

  export type Social_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_link to aggregate.
     */
    where?: social_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_links to fetch.
     */
    orderBy?: social_linkOrderByWithRelationInput | social_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: social_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned social_links
    **/
    _count?: true | Social_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Social_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Social_linkMaxAggregateInputType
  }

  export type GetSocial_linkAggregateType<T extends Social_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocial_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocial_link[P]>
      : GetScalarType<T[P], AggregateSocial_link[P]>
  }




  export type social_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: social_linkWhereInput
    orderBy?: social_linkOrderByWithAggregationInput | social_linkOrderByWithAggregationInput[]
    by: Social_linkScalarFieldEnum[] | Social_linkScalarFieldEnum
    having?: social_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Social_linkCountAggregateInputType | true
    _min?: Social_linkMinAggregateInputType
    _max?: Social_linkMaxAggregateInputType
  }

  export type Social_linkGroupByOutputType = {
    id: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at: Date
    updated_at: Date
    miniapp_user_id: string | null
    _count: Social_linkCountAggregateOutputType | null
    _min: Social_linkMinAggregateOutputType | null
    _max: Social_linkMaxAggregateOutputType | null
  }

  type GetSocial_linkGroupByPayload<T extends social_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Social_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Social_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Social_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Social_linkGroupByOutputType[P]>
        }
      >
    >


  export type social_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    social_org?: boolean
    identifier?: boolean
    created_at?: boolean
    updated_at?: boolean
    miniapp_user_id?: boolean
    custodial_collections?: boolean | social_link$custodial_collectionsArgs<ExtArgs>
    miniapp_user?: boolean | social_link$miniapp_userArgs<ExtArgs>
    _count?: boolean | Social_linkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social_link"]>

  export type social_linkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    social_org?: boolean
    identifier?: boolean
    created_at?: boolean
    updated_at?: boolean
    miniapp_user_id?: boolean
    miniapp_user?: boolean | social_link$miniapp_userArgs<ExtArgs>
  }, ExtArgs["result"]["social_link"]>

  export type social_linkSelectScalar = {
    id?: boolean
    social_org?: boolean
    identifier?: boolean
    created_at?: boolean
    updated_at?: boolean
    miniapp_user_id?: boolean
  }

  export type social_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    custodial_collections?: boolean | social_link$custodial_collectionsArgs<ExtArgs>
    miniapp_user?: boolean | social_link$miniapp_userArgs<ExtArgs>
    _count?: boolean | Social_linkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type social_linkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniapp_user?: boolean | social_link$miniapp_userArgs<ExtArgs>
  }

  export type $social_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "social_link"
    objects: {
      custodial_collections: Prisma.$collectionPayload<ExtArgs>[]
      miniapp_user: Prisma.$miniapp_userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      social_org: $Enums.social_org_enum
      identifier: string
      created_at: Date
      updated_at: Date
      miniapp_user_id: string | null
    }, ExtArgs["result"]["social_link"]>
    composites: {}
  }

  type social_linkGetPayload<S extends boolean | null | undefined | social_linkDefaultArgs> = $Result.GetResult<Prisma.$social_linkPayload, S>

  type social_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<social_linkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Social_linkCountAggregateInputType | true
    }

  export interface social_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['social_link'], meta: { name: 'social_link' } }
    /**
     * Find zero or one Social_link that matches the filter.
     * @param {social_linkFindUniqueArgs} args - Arguments to find a Social_link
     * @example
     * // Get one Social_link
     * const social_link = await prisma.social_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends social_linkFindUniqueArgs>(args: SelectSubset<T, social_linkFindUniqueArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Social_link that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {social_linkFindUniqueOrThrowArgs} args - Arguments to find a Social_link
     * @example
     * // Get one Social_link
     * const social_link = await prisma.social_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends social_linkFindUniqueOrThrowArgs>(args: SelectSubset<T, social_linkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Social_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_linkFindFirstArgs} args - Arguments to find a Social_link
     * @example
     * // Get one Social_link
     * const social_link = await prisma.social_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends social_linkFindFirstArgs>(args?: SelectSubset<T, social_linkFindFirstArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Social_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_linkFindFirstOrThrowArgs} args - Arguments to find a Social_link
     * @example
     * // Get one Social_link
     * const social_link = await prisma.social_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends social_linkFindFirstOrThrowArgs>(args?: SelectSubset<T, social_linkFindFirstOrThrowArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Social_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_linkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Social_links
     * const social_links = await prisma.social_link.findMany()
     * 
     * // Get first 10 Social_links
     * const social_links = await prisma.social_link.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const social_linkWithIdOnly = await prisma.social_link.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends social_linkFindManyArgs>(args?: SelectSubset<T, social_linkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Social_link.
     * @param {social_linkCreateArgs} args - Arguments to create a Social_link.
     * @example
     * // Create one Social_link
     * const Social_link = await prisma.social_link.create({
     *   data: {
     *     // ... data to create a Social_link
     *   }
     * })
     * 
     */
    create<T extends social_linkCreateArgs>(args: SelectSubset<T, social_linkCreateArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Social_links.
     * @param {social_linkCreateManyArgs} args - Arguments to create many Social_links.
     * @example
     * // Create many Social_links
     * const social_link = await prisma.social_link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends social_linkCreateManyArgs>(args?: SelectSubset<T, social_linkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Social_links and returns the data saved in the database.
     * @param {social_linkCreateManyAndReturnArgs} args - Arguments to create many Social_links.
     * @example
     * // Create many Social_links
     * const social_link = await prisma.social_link.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Social_links and only return the `id`
     * const social_linkWithIdOnly = await prisma.social_link.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends social_linkCreateManyAndReturnArgs>(args?: SelectSubset<T, social_linkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Social_link.
     * @param {social_linkDeleteArgs} args - Arguments to delete one Social_link.
     * @example
     * // Delete one Social_link
     * const Social_link = await prisma.social_link.delete({
     *   where: {
     *     // ... filter to delete one Social_link
     *   }
     * })
     * 
     */
    delete<T extends social_linkDeleteArgs>(args: SelectSubset<T, social_linkDeleteArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Social_link.
     * @param {social_linkUpdateArgs} args - Arguments to update one Social_link.
     * @example
     * // Update one Social_link
     * const social_link = await prisma.social_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends social_linkUpdateArgs>(args: SelectSubset<T, social_linkUpdateArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Social_links.
     * @param {social_linkDeleteManyArgs} args - Arguments to filter Social_links to delete.
     * @example
     * // Delete a few Social_links
     * const { count } = await prisma.social_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends social_linkDeleteManyArgs>(args?: SelectSubset<T, social_linkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Social_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Social_links
     * const social_link = await prisma.social_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends social_linkUpdateManyArgs>(args: SelectSubset<T, social_linkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Social_link.
     * @param {social_linkUpsertArgs} args - Arguments to update or create a Social_link.
     * @example
     * // Update or create a Social_link
     * const social_link = await prisma.social_link.upsert({
     *   create: {
     *     // ... data to create a Social_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Social_link we want to update
     *   }
     * })
     */
    upsert<T extends social_linkUpsertArgs>(args: SelectSubset<T, social_linkUpsertArgs<ExtArgs>>): Prisma__social_linkClient<$Result.GetResult<Prisma.$social_linkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Social_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_linkCountArgs} args - Arguments to filter Social_links to count.
     * @example
     * // Count the number of Social_links
     * const count = await prisma.social_link.count({
     *   where: {
     *     // ... the filter for the Social_links we want to count
     *   }
     * })
    **/
    count<T extends social_linkCountArgs>(
      args?: Subset<T, social_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Social_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Social_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Social_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Social_linkAggregateArgs>(args: Subset<T, Social_linkAggregateArgs>): Prisma.PrismaPromise<GetSocial_linkAggregateType<T>>

    /**
     * Group by Social_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {social_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends social_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: social_linkGroupByArgs['orderBy'] }
        : { orderBy?: social_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, social_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocial_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the social_link model
   */
  readonly fields: social_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for social_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__social_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    custodial_collections<T extends social_link$custodial_collectionsArgs<ExtArgs> = {}>(args?: Subset<T, social_link$custodial_collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionPayload<ExtArgs>, T, "findMany"> | Null>
    miniapp_user<T extends social_link$miniapp_userArgs<ExtArgs> = {}>(args?: Subset<T, social_link$miniapp_userArgs<ExtArgs>>): Prisma__miniapp_userClient<$Result.GetResult<Prisma.$miniapp_userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the social_link model
   */ 
  interface social_linkFieldRefs {
    readonly id: FieldRef<"social_link", 'String'>
    readonly social_org: FieldRef<"social_link", 'social_org_enum'>
    readonly identifier: FieldRef<"social_link", 'String'>
    readonly created_at: FieldRef<"social_link", 'DateTime'>
    readonly updated_at: FieldRef<"social_link", 'DateTime'>
    readonly miniapp_user_id: FieldRef<"social_link", 'String'>
  }
    

  // Custom InputTypes
  /**
   * social_link findUnique
   */
  export type social_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * Filter, which social_link to fetch.
     */
    where: social_linkWhereUniqueInput
  }

  /**
   * social_link findUniqueOrThrow
   */
  export type social_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * Filter, which social_link to fetch.
     */
    where: social_linkWhereUniqueInput
  }

  /**
   * social_link findFirst
   */
  export type social_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * Filter, which social_link to fetch.
     */
    where?: social_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_links to fetch.
     */
    orderBy?: social_linkOrderByWithRelationInput | social_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_links.
     */
    cursor?: social_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_links.
     */
    distinct?: Social_linkScalarFieldEnum | Social_linkScalarFieldEnum[]
  }

  /**
   * social_link findFirstOrThrow
   */
  export type social_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * Filter, which social_link to fetch.
     */
    where?: social_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_links to fetch.
     */
    orderBy?: social_linkOrderByWithRelationInput | social_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for social_links.
     */
    cursor?: social_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of social_links.
     */
    distinct?: Social_linkScalarFieldEnum | Social_linkScalarFieldEnum[]
  }

  /**
   * social_link findMany
   */
  export type social_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * Filter, which social_links to fetch.
     */
    where?: social_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of social_links to fetch.
     */
    orderBy?: social_linkOrderByWithRelationInput | social_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing social_links.
     */
    cursor?: social_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` social_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` social_links.
     */
    skip?: number
    distinct?: Social_linkScalarFieldEnum | Social_linkScalarFieldEnum[]
  }

  /**
   * social_link create
   */
  export type social_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a social_link.
     */
    data: XOR<social_linkCreateInput, social_linkUncheckedCreateInput>
  }

  /**
   * social_link createMany
   */
  export type social_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many social_links.
     */
    data: social_linkCreateManyInput | social_linkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * social_link createManyAndReturn
   */
  export type social_linkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many social_links.
     */
    data: social_linkCreateManyInput | social_linkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * social_link update
   */
  export type social_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a social_link.
     */
    data: XOR<social_linkUpdateInput, social_linkUncheckedUpdateInput>
    /**
     * Choose, which social_link to update.
     */
    where: social_linkWhereUniqueInput
  }

  /**
   * social_link updateMany
   */
  export type social_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update social_links.
     */
    data: XOR<social_linkUpdateManyMutationInput, social_linkUncheckedUpdateManyInput>
    /**
     * Filter which social_links to update
     */
    where?: social_linkWhereInput
  }

  /**
   * social_link upsert
   */
  export type social_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the social_link to update in case it exists.
     */
    where: social_linkWhereUniqueInput
    /**
     * In case the social_link found by the `where` argument doesn't exist, create a new social_link with this data.
     */
    create: XOR<social_linkCreateInput, social_linkUncheckedCreateInput>
    /**
     * In case the social_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<social_linkUpdateInput, social_linkUncheckedUpdateInput>
  }

  /**
   * social_link delete
   */
  export type social_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
    /**
     * Filter which social_link to delete.
     */
    where: social_linkWhereUniqueInput
  }

  /**
   * social_link deleteMany
   */
  export type social_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which social_links to delete
     */
    where?: social_linkWhereInput
  }

  /**
   * social_link.custodial_collections
   */
  export type social_link$custodial_collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionInclude<ExtArgs> | null
    where?: collectionWhereInput
    orderBy?: collectionOrderByWithRelationInput | collectionOrderByWithRelationInput[]
    cursor?: collectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * social_link.miniapp_user
   */
  export type social_link$miniapp_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the miniapp_user
     */
    select?: miniapp_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: miniapp_userInclude<ExtArgs> | null
    where?: miniapp_userWhereInput
  }

  /**
   * social_link without action
   */
  export type social_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the social_link
     */
    select?: social_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: social_linkInclude<ExtArgs> | null
  }


  /**
   * Model custom_nodes
   */

  export type AggregateCustom_nodes = {
    _count: Custom_nodesCountAggregateOutputType | null
    _avg: Custom_nodesAvgAggregateOutputType | null
    _sum: Custom_nodesSumAggregateOutputType | null
    _min: Custom_nodesMinAggregateOutputType | null
    _max: Custom_nodesMaxAggregateOutputType | null
  }

  export type Custom_nodesAvgAggregateOutputType = {
    install_order: number | null
  }

  export type Custom_nodesSumAggregateOutputType = {
    install_order: number | null
  }

  export type Custom_nodesMinAggregateOutputType = {
    id: string | null
    name: string | null
    download_url: string | null
    description: string | null
    is_env_required: boolean | null
    hash: string | null
    created_at: Date | null
    updated_at: Date | null
    is_default: boolean | null
    install_order: number | null
  }

  export type Custom_nodesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    download_url: string | null
    description: string | null
    is_env_required: boolean | null
    hash: string | null
    created_at: Date | null
    updated_at: Date | null
    is_default: boolean | null
    install_order: number | null
  }

  export type Custom_nodesCountAggregateOutputType = {
    id: number
    name: number
    download_url: number
    description: number
    is_env_required: number
    env_conf: number
    hash: number
    created_at: number
    updated_at: number
    install_settings: number
    is_default: number
    install_order: number
    _all: number
  }


  export type Custom_nodesAvgAggregateInputType = {
    install_order?: true
  }

  export type Custom_nodesSumAggregateInputType = {
    install_order?: true
  }

  export type Custom_nodesMinAggregateInputType = {
    id?: true
    name?: true
    download_url?: true
    description?: true
    is_env_required?: true
    hash?: true
    created_at?: true
    updated_at?: true
    is_default?: true
    install_order?: true
  }

  export type Custom_nodesMaxAggregateInputType = {
    id?: true
    name?: true
    download_url?: true
    description?: true
    is_env_required?: true
    hash?: true
    created_at?: true
    updated_at?: true
    is_default?: true
    install_order?: true
  }

  export type Custom_nodesCountAggregateInputType = {
    id?: true
    name?: true
    download_url?: true
    description?: true
    is_env_required?: true
    env_conf?: true
    hash?: true
    created_at?: true
    updated_at?: true
    install_settings?: true
    is_default?: true
    install_order?: true
    _all?: true
  }

  export type Custom_nodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which custom_nodes to aggregate.
     */
    where?: custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custom_nodes to fetch.
     */
    orderBy?: custom_nodesOrderByWithRelationInput | custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custom_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned custom_nodes
    **/
    _count?: true | Custom_nodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Custom_nodesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Custom_nodesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Custom_nodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Custom_nodesMaxAggregateInputType
  }

  export type GetCustom_nodesAggregateType<T extends Custom_nodesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustom_nodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustom_nodes[P]>
      : GetScalarType<T[P], AggregateCustom_nodes[P]>
  }




  export type custom_nodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: custom_nodesWhereInput
    orderBy?: custom_nodesOrderByWithAggregationInput | custom_nodesOrderByWithAggregationInput[]
    by: Custom_nodesScalarFieldEnum[] | Custom_nodesScalarFieldEnum
    having?: custom_nodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Custom_nodesCountAggregateInputType | true
    _avg?: Custom_nodesAvgAggregateInputType
    _sum?: Custom_nodesSumAggregateInputType
    _min?: Custom_nodesMinAggregateInputType
    _max?: Custom_nodesMaxAggregateInputType
  }

  export type Custom_nodesGroupByOutputType = {
    id: string
    name: string
    download_url: string
    description: string | null
    is_env_required: boolean
    env_conf: JsonValue | null
    hash: string | null
    created_at: Date
    updated_at: Date
    install_settings: JsonValue | null
    is_default: boolean
    install_order: number | null
    _count: Custom_nodesCountAggregateOutputType | null
    _avg: Custom_nodesAvgAggregateOutputType | null
    _sum: Custom_nodesSumAggregateOutputType | null
    _min: Custom_nodesMinAggregateOutputType | null
    _max: Custom_nodesMaxAggregateOutputType | null
  }

  type GetCustom_nodesGroupByPayload<T extends custom_nodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Custom_nodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Custom_nodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Custom_nodesGroupByOutputType[P]>
            : GetScalarType<T[P], Custom_nodesGroupByOutputType[P]>
        }
      >
    >


  export type custom_nodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    download_url?: boolean
    description?: boolean
    is_env_required?: boolean
    env_conf?: boolean
    hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    install_settings?: boolean
    is_default?: boolean
    install_order?: boolean
    workflow_custom_nodes?: boolean | custom_nodes$workflow_custom_nodesArgs<ExtArgs>
    _count?: boolean | Custom_nodesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["custom_nodes"]>

  export type custom_nodesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    download_url?: boolean
    description?: boolean
    is_env_required?: boolean
    env_conf?: boolean
    hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    install_settings?: boolean
    is_default?: boolean
    install_order?: boolean
  }, ExtArgs["result"]["custom_nodes"]>

  export type custom_nodesSelectScalar = {
    id?: boolean
    name?: boolean
    download_url?: boolean
    description?: boolean
    is_env_required?: boolean
    env_conf?: boolean
    hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    install_settings?: boolean
    is_default?: boolean
    install_order?: boolean
  }

  export type custom_nodesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow_custom_nodes?: boolean | custom_nodes$workflow_custom_nodesArgs<ExtArgs>
    _count?: boolean | Custom_nodesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type custom_nodesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $custom_nodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "custom_nodes"
    objects: {
      workflow_custom_nodes: Prisma.$workflow_custom_nodesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      download_url: string
      description: string | null
      is_env_required: boolean
      env_conf: Prisma.JsonValue | null
      hash: string | null
      created_at: Date
      updated_at: Date
      install_settings: Prisma.JsonValue | null
      is_default: boolean
      install_order: number | null
    }, ExtArgs["result"]["custom_nodes"]>
    composites: {}
  }

  type custom_nodesGetPayload<S extends boolean | null | undefined | custom_nodesDefaultArgs> = $Result.GetResult<Prisma.$custom_nodesPayload, S>

  type custom_nodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<custom_nodesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Custom_nodesCountAggregateInputType | true
    }

  export interface custom_nodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['custom_nodes'], meta: { name: 'custom_nodes' } }
    /**
     * Find zero or one Custom_nodes that matches the filter.
     * @param {custom_nodesFindUniqueArgs} args - Arguments to find a Custom_nodes
     * @example
     * // Get one Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends custom_nodesFindUniqueArgs>(args: SelectSubset<T, custom_nodesFindUniqueArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Custom_nodes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {custom_nodesFindUniqueOrThrowArgs} args - Arguments to find a Custom_nodes
     * @example
     * // Get one Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends custom_nodesFindUniqueOrThrowArgs>(args: SelectSubset<T, custom_nodesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Custom_nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custom_nodesFindFirstArgs} args - Arguments to find a Custom_nodes
     * @example
     * // Get one Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends custom_nodesFindFirstArgs>(args?: SelectSubset<T, custom_nodesFindFirstArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Custom_nodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custom_nodesFindFirstOrThrowArgs} args - Arguments to find a Custom_nodes
     * @example
     * // Get one Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends custom_nodesFindFirstOrThrowArgs>(args?: SelectSubset<T, custom_nodesFindFirstOrThrowArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Custom_nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custom_nodesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.findMany()
     * 
     * // Get first 10 Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const custom_nodesWithIdOnly = await prisma.custom_nodes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends custom_nodesFindManyArgs>(args?: SelectSubset<T, custom_nodesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Custom_nodes.
     * @param {custom_nodesCreateArgs} args - Arguments to create a Custom_nodes.
     * @example
     * // Create one Custom_nodes
     * const Custom_nodes = await prisma.custom_nodes.create({
     *   data: {
     *     // ... data to create a Custom_nodes
     *   }
     * })
     * 
     */
    create<T extends custom_nodesCreateArgs>(args: SelectSubset<T, custom_nodesCreateArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Custom_nodes.
     * @param {custom_nodesCreateManyArgs} args - Arguments to create many Custom_nodes.
     * @example
     * // Create many Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends custom_nodesCreateManyArgs>(args?: SelectSubset<T, custom_nodesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Custom_nodes and returns the data saved in the database.
     * @param {custom_nodesCreateManyAndReturnArgs} args - Arguments to create many Custom_nodes.
     * @example
     * // Create many Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Custom_nodes and only return the `id`
     * const custom_nodesWithIdOnly = await prisma.custom_nodes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends custom_nodesCreateManyAndReturnArgs>(args?: SelectSubset<T, custom_nodesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Custom_nodes.
     * @param {custom_nodesDeleteArgs} args - Arguments to delete one Custom_nodes.
     * @example
     * // Delete one Custom_nodes
     * const Custom_nodes = await prisma.custom_nodes.delete({
     *   where: {
     *     // ... filter to delete one Custom_nodes
     *   }
     * })
     * 
     */
    delete<T extends custom_nodesDeleteArgs>(args: SelectSubset<T, custom_nodesDeleteArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Custom_nodes.
     * @param {custom_nodesUpdateArgs} args - Arguments to update one Custom_nodes.
     * @example
     * // Update one Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends custom_nodesUpdateArgs>(args: SelectSubset<T, custom_nodesUpdateArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Custom_nodes.
     * @param {custom_nodesDeleteManyArgs} args - Arguments to filter Custom_nodes to delete.
     * @example
     * // Delete a few Custom_nodes
     * const { count } = await prisma.custom_nodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends custom_nodesDeleteManyArgs>(args?: SelectSubset<T, custom_nodesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custom_nodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends custom_nodesUpdateManyArgs>(args: SelectSubset<T, custom_nodesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Custom_nodes.
     * @param {custom_nodesUpsertArgs} args - Arguments to update or create a Custom_nodes.
     * @example
     * // Update or create a Custom_nodes
     * const custom_nodes = await prisma.custom_nodes.upsert({
     *   create: {
     *     // ... data to create a Custom_nodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Custom_nodes we want to update
     *   }
     * })
     */
    upsert<T extends custom_nodesUpsertArgs>(args: SelectSubset<T, custom_nodesUpsertArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custom_nodesCountArgs} args - Arguments to filter Custom_nodes to count.
     * @example
     * // Count the number of Custom_nodes
     * const count = await prisma.custom_nodes.count({
     *   where: {
     *     // ... the filter for the Custom_nodes we want to count
     *   }
     * })
    **/
    count<T extends custom_nodesCountArgs>(
      args?: Subset<T, custom_nodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Custom_nodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Custom_nodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Custom_nodesAggregateArgs>(args: Subset<T, Custom_nodesAggregateArgs>): Prisma.PrismaPromise<GetCustom_nodesAggregateType<T>>

    /**
     * Group by Custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custom_nodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends custom_nodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: custom_nodesGroupByArgs['orderBy'] }
        : { orderBy?: custom_nodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, custom_nodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustom_nodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the custom_nodes model
   */
  readonly fields: custom_nodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for custom_nodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__custom_nodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow_custom_nodes<T extends custom_nodes$workflow_custom_nodesArgs<ExtArgs> = {}>(args?: Subset<T, custom_nodes$workflow_custom_nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the custom_nodes model
   */ 
  interface custom_nodesFieldRefs {
    readonly id: FieldRef<"custom_nodes", 'String'>
    readonly name: FieldRef<"custom_nodes", 'String'>
    readonly download_url: FieldRef<"custom_nodes", 'String'>
    readonly description: FieldRef<"custom_nodes", 'String'>
    readonly is_env_required: FieldRef<"custom_nodes", 'Boolean'>
    readonly env_conf: FieldRef<"custom_nodes", 'Json'>
    readonly hash: FieldRef<"custom_nodes", 'String'>
    readonly created_at: FieldRef<"custom_nodes", 'DateTime'>
    readonly updated_at: FieldRef<"custom_nodes", 'DateTime'>
    readonly install_settings: FieldRef<"custom_nodes", 'Json'>
    readonly is_default: FieldRef<"custom_nodes", 'Boolean'>
    readonly install_order: FieldRef<"custom_nodes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * custom_nodes findUnique
   */
  export type custom_nodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which custom_nodes to fetch.
     */
    where: custom_nodesWhereUniqueInput
  }

  /**
   * custom_nodes findUniqueOrThrow
   */
  export type custom_nodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which custom_nodes to fetch.
     */
    where: custom_nodesWhereUniqueInput
  }

  /**
   * custom_nodes findFirst
   */
  export type custom_nodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which custom_nodes to fetch.
     */
    where?: custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custom_nodes to fetch.
     */
    orderBy?: custom_nodesOrderByWithRelationInput | custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custom_nodes.
     */
    cursor?: custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custom_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custom_nodes.
     */
    distinct?: Custom_nodesScalarFieldEnum | Custom_nodesScalarFieldEnum[]
  }

  /**
   * custom_nodes findFirstOrThrow
   */
  export type custom_nodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which custom_nodes to fetch.
     */
    where?: custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custom_nodes to fetch.
     */
    orderBy?: custom_nodesOrderByWithRelationInput | custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custom_nodes.
     */
    cursor?: custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custom_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custom_nodes.
     */
    distinct?: Custom_nodesScalarFieldEnum | Custom_nodesScalarFieldEnum[]
  }

  /**
   * custom_nodes findMany
   */
  export type custom_nodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which custom_nodes to fetch.
     */
    where?: custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custom_nodes to fetch.
     */
    orderBy?: custom_nodesOrderByWithRelationInput | custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing custom_nodes.
     */
    cursor?: custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custom_nodes.
     */
    skip?: number
    distinct?: Custom_nodesScalarFieldEnum | Custom_nodesScalarFieldEnum[]
  }

  /**
   * custom_nodes create
   */
  export type custom_nodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * The data needed to create a custom_nodes.
     */
    data: XOR<custom_nodesCreateInput, custom_nodesUncheckedCreateInput>
  }

  /**
   * custom_nodes createMany
   */
  export type custom_nodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many custom_nodes.
     */
    data: custom_nodesCreateManyInput | custom_nodesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * custom_nodes createManyAndReturn
   */
  export type custom_nodesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many custom_nodes.
     */
    data: custom_nodesCreateManyInput | custom_nodesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * custom_nodes update
   */
  export type custom_nodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * The data needed to update a custom_nodes.
     */
    data: XOR<custom_nodesUpdateInput, custom_nodesUncheckedUpdateInput>
    /**
     * Choose, which custom_nodes to update.
     */
    where: custom_nodesWhereUniqueInput
  }

  /**
   * custom_nodes updateMany
   */
  export type custom_nodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update custom_nodes.
     */
    data: XOR<custom_nodesUpdateManyMutationInput, custom_nodesUncheckedUpdateManyInput>
    /**
     * Filter which custom_nodes to update
     */
    where?: custom_nodesWhereInput
  }

  /**
   * custom_nodes upsert
   */
  export type custom_nodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * The filter to search for the custom_nodes to update in case it exists.
     */
    where: custom_nodesWhereUniqueInput
    /**
     * In case the custom_nodes found by the `where` argument doesn't exist, create a new custom_nodes with this data.
     */
    create: XOR<custom_nodesCreateInput, custom_nodesUncheckedCreateInput>
    /**
     * In case the custom_nodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<custom_nodesUpdateInput, custom_nodesUncheckedUpdateInput>
  }

  /**
   * custom_nodes delete
   */
  export type custom_nodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
    /**
     * Filter which custom_nodes to delete.
     */
    where: custom_nodesWhereUniqueInput
  }

  /**
   * custom_nodes deleteMany
   */
  export type custom_nodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which custom_nodes to delete
     */
    where?: custom_nodesWhereInput
  }

  /**
   * custom_nodes.workflow_custom_nodes
   */
  export type custom_nodes$workflow_custom_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    where?: workflow_custom_nodesWhereInput
    orderBy?: workflow_custom_nodesOrderByWithRelationInput | workflow_custom_nodesOrderByWithRelationInput[]
    cursor?: workflow_custom_nodesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Workflow_custom_nodesScalarFieldEnum | Workflow_custom_nodesScalarFieldEnum[]
  }

  /**
   * custom_nodes without action
   */
  export type custom_nodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the custom_nodes
     */
    select?: custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: custom_nodesInclude<ExtArgs> | null
  }


  /**
   * Model workflow_custom_nodes
   */

  export type AggregateWorkflow_custom_nodes = {
    _count: Workflow_custom_nodesCountAggregateOutputType | null
    _avg: Workflow_custom_nodesAvgAggregateOutputType | null
    _sum: Workflow_custom_nodesSumAggregateOutputType | null
    _min: Workflow_custom_nodesMinAggregateOutputType | null
    _max: Workflow_custom_nodesMaxAggregateOutputType | null
  }

  export type Workflow_custom_nodesAvgAggregateOutputType = {
    id: number | null
  }

  export type Workflow_custom_nodesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Workflow_custom_nodesMinAggregateOutputType = {
    id: bigint | null
    workflow_id: string | null
    custom_node_id: string | null
    created_at: Date | null
  }

  export type Workflow_custom_nodesMaxAggregateOutputType = {
    id: bigint | null
    workflow_id: string | null
    custom_node_id: string | null
    created_at: Date | null
  }

  export type Workflow_custom_nodesCountAggregateOutputType = {
    id: number
    workflow_id: number
    custom_node_id: number
    created_at: number
    _all: number
  }


  export type Workflow_custom_nodesAvgAggregateInputType = {
    id?: true
  }

  export type Workflow_custom_nodesSumAggregateInputType = {
    id?: true
  }

  export type Workflow_custom_nodesMinAggregateInputType = {
    id?: true
    workflow_id?: true
    custom_node_id?: true
    created_at?: true
  }

  export type Workflow_custom_nodesMaxAggregateInputType = {
    id?: true
    workflow_id?: true
    custom_node_id?: true
    created_at?: true
  }

  export type Workflow_custom_nodesCountAggregateInputType = {
    id?: true
    workflow_id?: true
    custom_node_id?: true
    created_at?: true
    _all?: true
  }

  export type Workflow_custom_nodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workflow_custom_nodes to aggregate.
     */
    where?: workflow_custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflow_custom_nodes to fetch.
     */
    orderBy?: workflow_custom_nodesOrderByWithRelationInput | workflow_custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: workflow_custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflow_custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflow_custom_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workflow_custom_nodes
    **/
    _count?: true | Workflow_custom_nodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Workflow_custom_nodesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Workflow_custom_nodesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Workflow_custom_nodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Workflow_custom_nodesMaxAggregateInputType
  }

  export type GetWorkflow_custom_nodesAggregateType<T extends Workflow_custom_nodesAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow_custom_nodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow_custom_nodes[P]>
      : GetScalarType<T[P], AggregateWorkflow_custom_nodes[P]>
  }




  export type workflow_custom_nodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workflow_custom_nodesWhereInput
    orderBy?: workflow_custom_nodesOrderByWithAggregationInput | workflow_custom_nodesOrderByWithAggregationInput[]
    by: Workflow_custom_nodesScalarFieldEnum[] | Workflow_custom_nodesScalarFieldEnum
    having?: workflow_custom_nodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Workflow_custom_nodesCountAggregateInputType | true
    _avg?: Workflow_custom_nodesAvgAggregateInputType
    _sum?: Workflow_custom_nodesSumAggregateInputType
    _min?: Workflow_custom_nodesMinAggregateInputType
    _max?: Workflow_custom_nodesMaxAggregateInputType
  }

  export type Workflow_custom_nodesGroupByOutputType = {
    id: bigint
    workflow_id: string
    custom_node_id: string
    created_at: Date
    _count: Workflow_custom_nodesCountAggregateOutputType | null
    _avg: Workflow_custom_nodesAvgAggregateOutputType | null
    _sum: Workflow_custom_nodesSumAggregateOutputType | null
    _min: Workflow_custom_nodesMinAggregateOutputType | null
    _max: Workflow_custom_nodesMaxAggregateOutputType | null
  }

  type GetWorkflow_custom_nodesGroupByPayload<T extends workflow_custom_nodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Workflow_custom_nodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Workflow_custom_nodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Workflow_custom_nodesGroupByOutputType[P]>
            : GetScalarType<T[P], Workflow_custom_nodesGroupByOutputType[P]>
        }
      >
    >


  export type workflow_custom_nodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflow_id?: boolean
    custom_node_id?: boolean
    created_at?: boolean
    custom_nodes?: boolean | custom_nodesDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow_custom_nodes"]>

  export type workflow_custom_nodesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflow_id?: boolean
    custom_node_id?: boolean
    created_at?: boolean
    custom_nodes?: boolean | custom_nodesDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow_custom_nodes"]>

  export type workflow_custom_nodesSelectScalar = {
    id?: boolean
    workflow_id?: boolean
    custom_node_id?: boolean
    created_at?: boolean
  }

  export type workflow_custom_nodesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    custom_nodes?: boolean | custom_nodesDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }
  export type workflow_custom_nodesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    custom_nodes?: boolean | custom_nodesDefaultArgs<ExtArgs>
    workflow?: boolean | workflowDefaultArgs<ExtArgs>
  }

  export type $workflow_custom_nodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "workflow_custom_nodes"
    objects: {
      custom_nodes: Prisma.$custom_nodesPayload<ExtArgs>
      workflow: Prisma.$workflowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      workflow_id: string
      custom_node_id: string
      created_at: Date
    }, ExtArgs["result"]["workflow_custom_nodes"]>
    composites: {}
  }

  type workflow_custom_nodesGetPayload<S extends boolean | null | undefined | workflow_custom_nodesDefaultArgs> = $Result.GetResult<Prisma.$workflow_custom_nodesPayload, S>

  type workflow_custom_nodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<workflow_custom_nodesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Workflow_custom_nodesCountAggregateInputType | true
    }

  export interface workflow_custom_nodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['workflow_custom_nodes'], meta: { name: 'workflow_custom_nodes' } }
    /**
     * Find zero or one Workflow_custom_nodes that matches the filter.
     * @param {workflow_custom_nodesFindUniqueArgs} args - Arguments to find a Workflow_custom_nodes
     * @example
     * // Get one Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends workflow_custom_nodesFindUniqueArgs>(args: SelectSubset<T, workflow_custom_nodesFindUniqueArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workflow_custom_nodes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {workflow_custom_nodesFindUniqueOrThrowArgs} args - Arguments to find a Workflow_custom_nodes
     * @example
     * // Get one Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends workflow_custom_nodesFindUniqueOrThrowArgs>(args: SelectSubset<T, workflow_custom_nodesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workflow_custom_nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflow_custom_nodesFindFirstArgs} args - Arguments to find a Workflow_custom_nodes
     * @example
     * // Get one Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends workflow_custom_nodesFindFirstArgs>(args?: SelectSubset<T, workflow_custom_nodesFindFirstArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workflow_custom_nodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflow_custom_nodesFindFirstOrThrowArgs} args - Arguments to find a Workflow_custom_nodes
     * @example
     * // Get one Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends workflow_custom_nodesFindFirstOrThrowArgs>(args?: SelectSubset<T, workflow_custom_nodesFindFirstOrThrowArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workflow_custom_nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflow_custom_nodesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findMany()
     * 
     * // Get first 10 Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflow_custom_nodesWithIdOnly = await prisma.workflow_custom_nodes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends workflow_custom_nodesFindManyArgs>(args?: SelectSubset<T, workflow_custom_nodesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workflow_custom_nodes.
     * @param {workflow_custom_nodesCreateArgs} args - Arguments to create a Workflow_custom_nodes.
     * @example
     * // Create one Workflow_custom_nodes
     * const Workflow_custom_nodes = await prisma.workflow_custom_nodes.create({
     *   data: {
     *     // ... data to create a Workflow_custom_nodes
     *   }
     * })
     * 
     */
    create<T extends workflow_custom_nodesCreateArgs>(args: SelectSubset<T, workflow_custom_nodesCreateArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workflow_custom_nodes.
     * @param {workflow_custom_nodesCreateManyArgs} args - Arguments to create many Workflow_custom_nodes.
     * @example
     * // Create many Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends workflow_custom_nodesCreateManyArgs>(args?: SelectSubset<T, workflow_custom_nodesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflow_custom_nodes and returns the data saved in the database.
     * @param {workflow_custom_nodesCreateManyAndReturnArgs} args - Arguments to create many Workflow_custom_nodes.
     * @example
     * // Create many Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflow_custom_nodes and only return the `id`
     * const workflow_custom_nodesWithIdOnly = await prisma.workflow_custom_nodes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends workflow_custom_nodesCreateManyAndReturnArgs>(args?: SelectSubset<T, workflow_custom_nodesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workflow_custom_nodes.
     * @param {workflow_custom_nodesDeleteArgs} args - Arguments to delete one Workflow_custom_nodes.
     * @example
     * // Delete one Workflow_custom_nodes
     * const Workflow_custom_nodes = await prisma.workflow_custom_nodes.delete({
     *   where: {
     *     // ... filter to delete one Workflow_custom_nodes
     *   }
     * })
     * 
     */
    delete<T extends workflow_custom_nodesDeleteArgs>(args: SelectSubset<T, workflow_custom_nodesDeleteArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workflow_custom_nodes.
     * @param {workflow_custom_nodesUpdateArgs} args - Arguments to update one Workflow_custom_nodes.
     * @example
     * // Update one Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends workflow_custom_nodesUpdateArgs>(args: SelectSubset<T, workflow_custom_nodesUpdateArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workflow_custom_nodes.
     * @param {workflow_custom_nodesDeleteManyArgs} args - Arguments to filter Workflow_custom_nodes to delete.
     * @example
     * // Delete a few Workflow_custom_nodes
     * const { count } = await prisma.workflow_custom_nodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends workflow_custom_nodesDeleteManyArgs>(args?: SelectSubset<T, workflow_custom_nodesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflow_custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflow_custom_nodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends workflow_custom_nodesUpdateManyArgs>(args: SelectSubset<T, workflow_custom_nodesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow_custom_nodes.
     * @param {workflow_custom_nodesUpsertArgs} args - Arguments to update or create a Workflow_custom_nodes.
     * @example
     * // Update or create a Workflow_custom_nodes
     * const workflow_custom_nodes = await prisma.workflow_custom_nodes.upsert({
     *   create: {
     *     // ... data to create a Workflow_custom_nodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow_custom_nodes we want to update
     *   }
     * })
     */
    upsert<T extends workflow_custom_nodesUpsertArgs>(args: SelectSubset<T, workflow_custom_nodesUpsertArgs<ExtArgs>>): Prisma__workflow_custom_nodesClient<$Result.GetResult<Prisma.$workflow_custom_nodesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workflow_custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflow_custom_nodesCountArgs} args - Arguments to filter Workflow_custom_nodes to count.
     * @example
     * // Count the number of Workflow_custom_nodes
     * const count = await prisma.workflow_custom_nodes.count({
     *   where: {
     *     // ... the filter for the Workflow_custom_nodes we want to count
     *   }
     * })
    **/
    count<T extends workflow_custom_nodesCountArgs>(
      args?: Subset<T, workflow_custom_nodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Workflow_custom_nodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow_custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Workflow_custom_nodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Workflow_custom_nodesAggregateArgs>(args: Subset<T, Workflow_custom_nodesAggregateArgs>): Prisma.PrismaPromise<GetWorkflow_custom_nodesAggregateType<T>>

    /**
     * Group by Workflow_custom_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workflow_custom_nodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends workflow_custom_nodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: workflow_custom_nodesGroupByArgs['orderBy'] }
        : { orderBy?: workflow_custom_nodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, workflow_custom_nodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflow_custom_nodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the workflow_custom_nodes model
   */
  readonly fields: workflow_custom_nodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for workflow_custom_nodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__workflow_custom_nodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    custom_nodes<T extends custom_nodesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, custom_nodesDefaultArgs<ExtArgs>>): Prisma__custom_nodesClient<$Result.GetResult<Prisma.$custom_nodesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workflow<T extends workflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, workflowDefaultArgs<ExtArgs>>): Prisma__workflowClient<$Result.GetResult<Prisma.$workflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the workflow_custom_nodes model
   */ 
  interface workflow_custom_nodesFieldRefs {
    readonly id: FieldRef<"workflow_custom_nodes", 'BigInt'>
    readonly workflow_id: FieldRef<"workflow_custom_nodes", 'String'>
    readonly custom_node_id: FieldRef<"workflow_custom_nodes", 'String'>
    readonly created_at: FieldRef<"workflow_custom_nodes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * workflow_custom_nodes findUnique
   */
  export type workflow_custom_nodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which workflow_custom_nodes to fetch.
     */
    where: workflow_custom_nodesWhereUniqueInput
  }

  /**
   * workflow_custom_nodes findUniqueOrThrow
   */
  export type workflow_custom_nodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which workflow_custom_nodes to fetch.
     */
    where: workflow_custom_nodesWhereUniqueInput
  }

  /**
   * workflow_custom_nodes findFirst
   */
  export type workflow_custom_nodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which workflow_custom_nodes to fetch.
     */
    where?: workflow_custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflow_custom_nodes to fetch.
     */
    orderBy?: workflow_custom_nodesOrderByWithRelationInput | workflow_custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workflow_custom_nodes.
     */
    cursor?: workflow_custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflow_custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflow_custom_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workflow_custom_nodes.
     */
    distinct?: Workflow_custom_nodesScalarFieldEnum | Workflow_custom_nodesScalarFieldEnum[]
  }

  /**
   * workflow_custom_nodes findFirstOrThrow
   */
  export type workflow_custom_nodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which workflow_custom_nodes to fetch.
     */
    where?: workflow_custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflow_custom_nodes to fetch.
     */
    orderBy?: workflow_custom_nodesOrderByWithRelationInput | workflow_custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workflow_custom_nodes.
     */
    cursor?: workflow_custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflow_custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflow_custom_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workflow_custom_nodes.
     */
    distinct?: Workflow_custom_nodesScalarFieldEnum | Workflow_custom_nodesScalarFieldEnum[]
  }

  /**
   * workflow_custom_nodes findMany
   */
  export type workflow_custom_nodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * Filter, which workflow_custom_nodes to fetch.
     */
    where?: workflow_custom_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workflow_custom_nodes to fetch.
     */
    orderBy?: workflow_custom_nodesOrderByWithRelationInput | workflow_custom_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workflow_custom_nodes.
     */
    cursor?: workflow_custom_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workflow_custom_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workflow_custom_nodes.
     */
    skip?: number
    distinct?: Workflow_custom_nodesScalarFieldEnum | Workflow_custom_nodesScalarFieldEnum[]
  }

  /**
   * workflow_custom_nodes create
   */
  export type workflow_custom_nodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * The data needed to create a workflow_custom_nodes.
     */
    data: XOR<workflow_custom_nodesCreateInput, workflow_custom_nodesUncheckedCreateInput>
  }

  /**
   * workflow_custom_nodes createMany
   */
  export type workflow_custom_nodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many workflow_custom_nodes.
     */
    data: workflow_custom_nodesCreateManyInput | workflow_custom_nodesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * workflow_custom_nodes createManyAndReturn
   */
  export type workflow_custom_nodesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many workflow_custom_nodes.
     */
    data: workflow_custom_nodesCreateManyInput | workflow_custom_nodesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * workflow_custom_nodes update
   */
  export type workflow_custom_nodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * The data needed to update a workflow_custom_nodes.
     */
    data: XOR<workflow_custom_nodesUpdateInput, workflow_custom_nodesUncheckedUpdateInput>
    /**
     * Choose, which workflow_custom_nodes to update.
     */
    where: workflow_custom_nodesWhereUniqueInput
  }

  /**
   * workflow_custom_nodes updateMany
   */
  export type workflow_custom_nodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update workflow_custom_nodes.
     */
    data: XOR<workflow_custom_nodesUpdateManyMutationInput, workflow_custom_nodesUncheckedUpdateManyInput>
    /**
     * Filter which workflow_custom_nodes to update
     */
    where?: workflow_custom_nodesWhereInput
  }

  /**
   * workflow_custom_nodes upsert
   */
  export type workflow_custom_nodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * The filter to search for the workflow_custom_nodes to update in case it exists.
     */
    where: workflow_custom_nodesWhereUniqueInput
    /**
     * In case the workflow_custom_nodes found by the `where` argument doesn't exist, create a new workflow_custom_nodes with this data.
     */
    create: XOR<workflow_custom_nodesCreateInput, workflow_custom_nodesUncheckedCreateInput>
    /**
     * In case the workflow_custom_nodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<workflow_custom_nodesUpdateInput, workflow_custom_nodesUncheckedUpdateInput>
  }

  /**
   * workflow_custom_nodes delete
   */
  export type workflow_custom_nodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
    /**
     * Filter which workflow_custom_nodes to delete.
     */
    where: workflow_custom_nodesWhereUniqueInput
  }

  /**
   * workflow_custom_nodes deleteMany
   */
  export type workflow_custom_nodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workflow_custom_nodes to delete
     */
    where?: workflow_custom_nodesWhereInput
  }

  /**
   * workflow_custom_nodes without action
   */
  export type workflow_custom_nodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workflow_custom_nodes
     */
    select?: workflow_custom_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workflow_custom_nodesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    address: 'address',
    token_id: 'token_id',
    created_at: 'created_at'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const CollectionScalarFieldEnum: {
    id: 'id',
    archived: 'archived',
    batch_max_tokens: 'batch_max_tokens',
    batch_mint_enabled: 'batch_mint_enabled',
    blockchain: 'blockchain',
    cover_image_url: 'cover_image_url',
    data: 'data',
    description: 'description',
    editions: 'editions',
    encryption_enabled: 'encryption_enabled',
    images: 'images',
    is_current: 'is_current',
    price: 'price',
    project_id: 'project_id',
    publish_date: 'publish_date',
    status: 'status',
    title: 'title',
    updated_at: 'updated_at',
    created_at: 'created_at',
    is_custodial: 'is_custodial',
    custodied_for: 'custodied_for',
    miniapp_cover_image: 'miniapp_cover_image'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export const Collection_remixScalarFieldEnum: {
    id: 'id',
    source_collection_id: 'source_collection_id',
    target_collection_id: 'target_collection_id',
    created_at: 'created_at',
    collection_preview_version_id: 'collection_preview_version_id'
  };

  export type Collection_remixScalarFieldEnum = (typeof Collection_remixScalarFieldEnum)[keyof typeof Collection_remixScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    event_name: 'event_name',
    property_name: 'property_name',
    property_value: 'property_value',
    created_at: 'created_at',
    user_id: 'user_id',
    event_id: 'event_id',
    event_type: 'event_type'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const Flat_fileScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    url: 'url',
    hidden: 'hidden',
    user_id: 'user_id',
    name: 'name',
    gen_in_data: 'gen_in_data',
    gen_out_data: 'gen_out_data',
    mime_type: 'mime_type',
    rel_id: 'rel_id',
    rel_type: 'rel_type',
    tags: 'tags'
  };

  export type Flat_fileScalarFieldEnum = (typeof Flat_fileScalarFieldEnum)[keyof typeof Flat_fileScalarFieldEnum]


  export const Component_flat_fileScalarFieldEnum: {
    id: 'id',
    component_id: 'component_id',
    flat_file_id: 'flat_file_id'
  };

  export type Component_flat_fileScalarFieldEnum = (typeof Component_flat_fileScalarFieldEnum)[keyof typeof Component_flat_fileScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    name: 'name',
    user_id: 'user_id',
    data: 'data',
    current_project_history_id: 'current_project_history_id',
    version: 'version',
    archived: 'archived',
    is_default: 'is_default'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const Project_historyScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    data: 'data',
    user_id: 'user_id',
    project_id: 'project_id',
    name: 'name',
    images: 'images'
  };

  export type Project_historyScalarFieldEnum = (typeof Project_historyScalarFieldEnum)[keyof typeof Project_historyScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    created_at: 'created_at',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    address: 'address',
    user_id: 'user_id'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const Credits_historyScalarFieldEnum: {
    id: 'id',
    flow: 'flow',
    amount: 'amount',
    credit_type: 'credit_type',
    created_at: 'created_at',
    user_id: 'user_id',
    comment: 'comment'
  };

  export type Credits_historyScalarFieldEnum = (typeof Credits_historyScalarFieldEnum)[keyof typeof Credits_historyScalarFieldEnum]


  export const Credits_balanceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    balance: 'balance',
    credit_type: 'credit_type'
  };

  export type Credits_balanceScalarFieldEnum = (typeof Credits_balanceScalarFieldEnum)[keyof typeof Credits_balanceScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    stripe_subscription_id: 'stripe_subscription_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    status: 'status',
    stripe_product_id: 'stripe_product_id',
    subscription_key: 'subscription_key',
    cancel_at_period_end: 'cancel_at_period_end',
    current_period_end: 'current_period_end',
    current_period_start: 'current_period_start'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    stripe_customer_id: 'stripe_customer_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    prefinery_referral_code: 'prefinery_referral_code',
    has_migrated: 'has_migrated'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    stripe_price_id: 'stripe_price_id',
    stripe_product_id: 'stripe_product_id',
    price: 'price',
    credits_quantity: 'credits_quantity',
    credits_type: 'credits_type',
    active: 'active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    lookup_key: 'lookup_key',
    rank: 'rank',
    features: 'features'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Project_templateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at',
    current_project_history_id: 'current_project_history_id'
  };

  export type Project_templateScalarFieldEnum = (typeof Project_templateScalarFieldEnum)[keyof typeof Project_templateScalarFieldEnum]


  export const Project_template_saveScalarFieldEnum: {
    id: 'id',
    name: 'name',
    data: 'data',
    images: 'images',
    created_at: 'created_at',
    updated_at: 'updated_at',
    project_template_id: 'project_template_id',
    project_history_id: 'project_history_id'
  };

  export type Project_template_saveScalarFieldEnum = (typeof Project_template_saveScalarFieldEnum)[keyof typeof Project_template_saveScalarFieldEnum]


  export const Collection_rewardScalarFieldEnum: {
    id: 'id',
    collection_id: 'collection_id',
    tag: 'tag',
    credits: 'credits',
    enabled: 'enabled',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Collection_rewardScalarFieldEnum = (typeof Collection_rewardScalarFieldEnum)[keyof typeof Collection_rewardScalarFieldEnum]


  export const Collection_reward_redemptionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    wallet_address: 'wallet_address',
    token_id: 'token_id',
    collection_reward_id: 'collection_reward_id',
    created_at: 'created_at'
  };

  export type Collection_reward_redemptionScalarFieldEnum = (typeof Collection_reward_redemptionScalarFieldEnum)[keyof typeof Collection_reward_redemptionScalarFieldEnum]


  export const Collection_sales_receiversScalarFieldEnum: {
    id: 'id',
    collection_id: 'collection_id',
    address: 'address',
    value: 'value',
    type: 'type'
  };

  export type Collection_sales_receiversScalarFieldEnum = (typeof Collection_sales_receiversScalarFieldEnum)[keyof typeof Collection_sales_receiversScalarFieldEnum]


  export const Collection_historyScalarFieldEnum: {
    id: 'id',
    event: 'event',
    current_value: 'current_value',
    new_value: 'new_value',
    created_at: 'created_at',
    collection_id: 'collection_id'
  };

  export type Collection_historyScalarFieldEnum = (typeof Collection_historyScalarFieldEnum)[keyof typeof Collection_historyScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    profile_image: 'profile_image',
    profile_preference: 'profile_preference',
    created_at: 'created_at',
    updated_at: 'updated_at',
    profile_username: 'profile_username'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const Collection_previewScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    max_generations: 'max_generations',
    total_generations: 'total_generations',
    collection_id: 'collection_id',
    access_level: 'access_level',
    is_remixable: 'is_remixable',
    farcaster_collection: 'farcaster_collection'
  };

  export type Collection_previewScalarFieldEnum = (typeof Collection_previewScalarFieldEnum)[keyof typeof Collection_previewScalarFieldEnum]


  export const Collection_preview_versionScalarFieldEnum: {
    id: 'id',
    version: 'version',
    collection_preview_id: 'collection_preview_id',
    data: 'data',
    is_latest: 'is_latest',
    created_at: 'created_at'
  };

  export type Collection_preview_versionScalarFieldEnum = (typeof Collection_preview_versionScalarFieldEnum)[keyof typeof Collection_preview_versionScalarFieldEnum]


  export const Collection_sample_imagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    collection_id: 'collection_id'
  };

  export type Collection_sample_imagesScalarFieldEnum = (typeof Collection_sample_imagesScalarFieldEnum)[keyof typeof Collection_sample_imagesScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    entity_type: 'entity_type',
    entity_id: 'entity_id'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const Chat_messageScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    content: 'content',
    chat_id: 'chat_id',
    flat_file_id: 'flat_file_id'
  };

  export type Chat_messageScalarFieldEnum = (typeof Chat_messageScalarFieldEnum)[keyof typeof Chat_messageScalarFieldEnum]


  export const Socket_io_attachmentsScalarFieldEnum: {
    id: 'id',
    payload: 'payload',
    created_at: 'created_at'
  };

  export type Socket_io_attachmentsScalarFieldEnum = (typeof Socket_io_attachmentsScalarFieldEnum)[keyof typeof Socket_io_attachmentsScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    id: 'id',
    collection_id: 'collection_id',
    created_at: 'created_at'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    data: 'data',
    created_at: 'created_at',
    server_id: 'server_id',
    output_mime_type: 'output_mime_type',
    display: 'display',
    label: 'label',
    order: 'order',
    type: 'type',
    est_gen_time: 'est_gen_time',
    machine_type: 'machine_type',
    min_vram: 'min_vram'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const ServerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServerScalarFieldEnum = (typeof ServerScalarFieldEnum)[keyof typeof ServerScalarFieldEnum]


  export const Form_configScalarFieldEnum: {
    id: 'id',
    name: 'name',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Form_configScalarFieldEnum = (typeof Form_configScalarFieldEnum)[keyof typeof Form_configScalarFieldEnum]


  export const Api_keyScalarFieldEnum: {
    id: 'id',
    alias: 'alias',
    key: 'key',
    workflow_name: 'workflow_name',
    user_id: 'user_id',
    created_at: 'created_at'
  };

  export type Api_keyScalarFieldEnum = (typeof Api_keyScalarFieldEnum)[keyof typeof Api_keyScalarFieldEnum]


  export const User_api_keysScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    key_hash: 'key_hash',
    name: 'name',
    expires_at: 'expires_at',
    created_at: 'created_at',
    is_active: 'is_active'
  };

  export type User_api_keysScalarFieldEnum = (typeof User_api_keysScalarFieldEnum)[keyof typeof User_api_keysScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    data: 'data',
    progress: 'progress',
    error_message: 'error_message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    started_at: 'started_at',
    completed_at: 'completed_at',
    user_id: 'user_id',
    job_type: 'job_type',
    priority: 'priority'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const Job_historyScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    status: 'status',
    data: 'data',
    created_at: 'created_at',
    message: 'message'
  };

  export type Job_historyScalarFieldEnum = (typeof Job_historyScalarFieldEnum)[keyof typeof Job_historyScalarFieldEnum]


  export const Miniapp_userScalarFieldEnum: {
    id: 'id',
    farcaster_id: 'farcaster_id',
    farcaster_username: 'farcaster_username',
    farcaster_pfp: 'farcaster_pfp',
    wallet_address: 'wallet_address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    notification_token: 'notification_token'
  };

  export type Miniapp_userScalarFieldEnum = (typeof Miniapp_userScalarFieldEnum)[keyof typeof Miniapp_userScalarFieldEnum]


  export const Miniapp_collection_configScalarFieldEnum: {
    id: 'id',
    collection_id: 'collection_id',
    price: 'price',
    generations_per_payment: 'generations_per_payment',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    max_retries: 'max_retries'
  };

  export type Miniapp_collection_configScalarFieldEnum = (typeof Miniapp_collection_configScalarFieldEnum)[keyof typeof Miniapp_collection_configScalarFieldEnum]


  export const Miniapp_paymentScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    collection_id: 'collection_id',
    amount: 'amount',
    transaction_hash: 'transaction_hash',
    payment_status: 'payment_status',
    generations_allowed: 'generations_allowed',
    generations_used: 'generations_used',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Miniapp_paymentScalarFieldEnum = (typeof Miniapp_paymentScalarFieldEnum)[keyof typeof Miniapp_paymentScalarFieldEnum]


  export const Miniapp_generationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    collection_id: 'collection_id',
    payment_id: 'payment_id',
    input_data: 'input_data',
    output_url: 'output_url',
    output_data: 'output_data',
    error_message: 'error_message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    job_id: 'job_id',
    generated_image: 'generated_image',
    status: 'status',
    retry_count: 'retry_count'
  };

  export type Miniapp_generationScalarFieldEnum = (typeof Miniapp_generationScalarFieldEnum)[keyof typeof Miniapp_generationScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    downloadUrl: 'downloadUrl',
    saveTo: 'saveTo',
    description: 'description',
    fileSize: 'fileSize',
    hash: 'hash',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authEnvVar: 'authEnvVar',
    isAuthReq: 'isAuthReq'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const WorkflowModelScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    modelId: 'modelId',
    isRequired: 'isRequired',
    createdAt: 'createdAt'
  };

  export type WorkflowModelScalarFieldEnum = (typeof WorkflowModelScalarFieldEnum)[keyof typeof WorkflowModelScalarFieldEnum]


  export const Component_flat_file_recoverScalarFieldEnum: {
    id: 'id',
    component_id: 'component_id',
    flat_file_id: 'flat_file_id',
    recovered_at: 'recovered_at',
    issue_type: 'issue_type'
  };

  export type Component_flat_file_recoverScalarFieldEnum = (typeof Component_flat_file_recoverScalarFieldEnum)[keyof typeof Component_flat_file_recoverScalarFieldEnum]


  export const Social_linkScalarFieldEnum: {
    id: 'id',
    social_org: 'social_org',
    identifier: 'identifier',
    created_at: 'created_at',
    updated_at: 'updated_at',
    miniapp_user_id: 'miniapp_user_id'
  };

  export type Social_linkScalarFieldEnum = (typeof Social_linkScalarFieldEnum)[keyof typeof Social_linkScalarFieldEnum]


  export const Custom_nodesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    download_url: 'download_url',
    description: 'description',
    is_env_required: 'is_env_required',
    env_conf: 'env_conf',
    hash: 'hash',
    created_at: 'created_at',
    updated_at: 'updated_at',
    install_settings: 'install_settings',
    is_default: 'is_default',
    install_order: 'install_order'
  };

  export type Custom_nodesScalarFieldEnum = (typeof Custom_nodesScalarFieldEnum)[keyof typeof Custom_nodesScalarFieldEnum]


  export const Workflow_custom_nodesScalarFieldEnum: {
    id: 'id',
    workflow_id: 'workflow_id',
    custom_node_id: 'custom_node_id',
    created_at: 'created_at'
  };

  export type Workflow_custom_nodesScalarFieldEnum = (typeof Workflow_custom_nodesScalarFieldEnum)[keyof typeof Workflow_custom_nodesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'GenerationStatus'
   */
  export type EnumGenerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenerationStatus'>
    


  /**
   * Reference to a field of type 'GenerationStatus[]'
   */
  export type ListEnumGenerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenerationStatus[]'>
    


  /**
   * Reference to a field of type 'social_org_enum'
   */
  export type Enumsocial_org_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'social_org_enum'>
    


  /**
   * Reference to a field of type 'social_org_enum[]'
   */
  export type ListEnumsocial_org_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'social_org_enum[]'>
    
  /**
   * Deep Input Types
   */


  export type assignmentWhereInput = {
    AND?: assignmentWhereInput | assignmentWhereInput[]
    OR?: assignmentWhereInput[]
    NOT?: assignmentWhereInput | assignmentWhereInput[]
    id?: BigIntFilter<"assignment"> | bigint | number
    user_id?: UuidNullableFilter<"assignment"> | string | null
    address?: StringNullableFilter<"assignment"> | string | null
    token_id?: StringNullableFilter<"assignment"> | string | null
    created_at?: DateTimeFilter<"assignment"> | Date | string
  }

  export type assignmentOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    token_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
  }

  export type assignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: assignmentWhereInput | assignmentWhereInput[]
    OR?: assignmentWhereInput[]
    NOT?: assignmentWhereInput | assignmentWhereInput[]
    user_id?: UuidNullableFilter<"assignment"> | string | null
    address?: StringNullableFilter<"assignment"> | string | null
    token_id?: StringNullableFilter<"assignment"> | string | null
    created_at?: DateTimeFilter<"assignment"> | Date | string
  }, "id">

  export type assignmentOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    token_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: assignmentCountOrderByAggregateInput
    _avg?: assignmentAvgOrderByAggregateInput
    _max?: assignmentMaxOrderByAggregateInput
    _min?: assignmentMinOrderByAggregateInput
    _sum?: assignmentSumOrderByAggregateInput
  }

  export type assignmentScalarWhereWithAggregatesInput = {
    AND?: assignmentScalarWhereWithAggregatesInput | assignmentScalarWhereWithAggregatesInput[]
    OR?: assignmentScalarWhereWithAggregatesInput[]
    NOT?: assignmentScalarWhereWithAggregatesInput | assignmentScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"assignment"> | bigint | number
    user_id?: UuidNullableWithAggregatesFilter<"assignment"> | string | null
    address?: StringNullableWithAggregatesFilter<"assignment"> | string | null
    token_id?: StringNullableWithAggregatesFilter<"assignment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"assignment"> | Date | string
  }

  export type collectionWhereInput = {
    AND?: collectionWhereInput | collectionWhereInput[]
    OR?: collectionWhereInput[]
    NOT?: collectionWhereInput | collectionWhereInput[]
    id?: UuidFilter<"collection"> | string
    archived?: BoolFilter<"collection"> | boolean
    batch_max_tokens?: IntNullableFilter<"collection"> | number | null
    batch_mint_enabled?: BoolFilter<"collection"> | boolean
    blockchain?: StringNullableFilter<"collection"> | string | null
    cover_image_url?: StringNullableFilter<"collection"> | string | null
    data?: JsonNullableFilter<"collection">
    description?: StringNullableFilter<"collection"> | string | null
    editions?: IntNullableFilter<"collection"> | number | null
    encryption_enabled?: BoolNullableFilter<"collection"> | boolean | null
    images?: JsonNullableFilter<"collection">
    is_current?: BoolFilter<"collection"> | boolean
    price?: FloatNullableFilter<"collection"> | number | null
    project_id?: UuidFilter<"collection"> | string
    publish_date?: DateTimeNullableFilter<"collection"> | Date | string | null
    status?: StringFilter<"collection"> | string
    title?: StringNullableFilter<"collection"> | string | null
    updated_at?: DateTimeFilter<"collection"> | Date | string
    created_at?: DateTimeFilter<"collection"> | Date | string
    is_custodial?: BoolFilter<"collection"> | boolean
    custodied_for?: UuidNullableFilter<"collection"> | string | null
    miniapp_cover_image?: StringNullableFilter<"collection"> | string | null
    social_link?: XOR<Social_linkNullableRelationFilter, social_linkWhereInput> | null
    project?: XOR<ProjectRelationFilter, projectWhereInput>
    collection_history?: Collection_historyListRelationFilter
    collection_preview?: XOR<Collection_previewNullableRelationFilter, collection_previewWhereInput> | null
    source_remix?: Collection_remixListRelationFilter
    target_remix?: Collection_remixListRelationFilter
    collection_sales_receivers?: Collection_sales_receiversListRelationFilter
    collection_sample_images?: Collection_sample_imagesListRelationFilter
    collection_node?: ComponentListRelationFilter
    miniapp_collection_config?: XOR<Miniapp_collection_configNullableRelationFilter, miniapp_collection_configWhereInput> | null
    miniapp_generation?: Miniapp_generationListRelationFilter
    miniapp_payment?: Miniapp_paymentListRelationFilter
  }

  export type collectionOrderByWithRelationInput = {
    id?: SortOrder
    archived?: SortOrder
    batch_max_tokens?: SortOrderInput | SortOrder
    batch_mint_enabled?: SortOrder
    blockchain?: SortOrderInput | SortOrder
    cover_image_url?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    editions?: SortOrderInput | SortOrder
    encryption_enabled?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    is_current?: SortOrder
    price?: SortOrderInput | SortOrder
    project_id?: SortOrder
    publish_date?: SortOrderInput | SortOrder
    status?: SortOrder
    title?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    is_custodial?: SortOrder
    custodied_for?: SortOrderInput | SortOrder
    miniapp_cover_image?: SortOrderInput | SortOrder
    social_link?: social_linkOrderByWithRelationInput
    project?: projectOrderByWithRelationInput
    collection_history?: collection_historyOrderByRelationAggregateInput
    collection_preview?: collection_previewOrderByWithRelationInput
    source_remix?: collection_remixOrderByRelationAggregateInput
    target_remix?: collection_remixOrderByRelationAggregateInput
    collection_sales_receivers?: collection_sales_receiversOrderByRelationAggregateInput
    collection_sample_images?: collection_sample_imagesOrderByRelationAggregateInput
    collection_node?: componentOrderByRelationAggregateInput
    miniapp_collection_config?: miniapp_collection_configOrderByWithRelationInput
    miniapp_generation?: miniapp_generationOrderByRelationAggregateInput
    miniapp_payment?: miniapp_paymentOrderByRelationAggregateInput
  }

  export type collectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: collectionWhereInput | collectionWhereInput[]
    OR?: collectionWhereInput[]
    NOT?: collectionWhereInput | collectionWhereInput[]
    archived?: BoolFilter<"collection"> | boolean
    batch_max_tokens?: IntNullableFilter<"collection"> | number | null
    batch_mint_enabled?: BoolFilter<"collection"> | boolean
    blockchain?: StringNullableFilter<"collection"> | string | null
    cover_image_url?: StringNullableFilter<"collection"> | string | null
    data?: JsonNullableFilter<"collection">
    description?: StringNullableFilter<"collection"> | string | null
    editions?: IntNullableFilter<"collection"> | number | null
    encryption_enabled?: BoolNullableFilter<"collection"> | boolean | null
    images?: JsonNullableFilter<"collection">
    is_current?: BoolFilter<"collection"> | boolean
    price?: FloatNullableFilter<"collection"> | number | null
    project_id?: UuidFilter<"collection"> | string
    publish_date?: DateTimeNullableFilter<"collection"> | Date | string | null
    status?: StringFilter<"collection"> | string
    title?: StringNullableFilter<"collection"> | string | null
    updated_at?: DateTimeFilter<"collection"> | Date | string
    created_at?: DateTimeFilter<"collection"> | Date | string
    is_custodial?: BoolFilter<"collection"> | boolean
    custodied_for?: UuidNullableFilter<"collection"> | string | null
    miniapp_cover_image?: StringNullableFilter<"collection"> | string | null
    social_link?: XOR<Social_linkNullableRelationFilter, social_linkWhereInput> | null
    project?: XOR<ProjectRelationFilter, projectWhereInput>
    collection_history?: Collection_historyListRelationFilter
    collection_preview?: XOR<Collection_previewNullableRelationFilter, collection_previewWhereInput> | null
    source_remix?: Collection_remixListRelationFilter
    target_remix?: Collection_remixListRelationFilter
    collection_sales_receivers?: Collection_sales_receiversListRelationFilter
    collection_sample_images?: Collection_sample_imagesListRelationFilter
    collection_node?: ComponentListRelationFilter
    miniapp_collection_config?: XOR<Miniapp_collection_configNullableRelationFilter, miniapp_collection_configWhereInput> | null
    miniapp_generation?: Miniapp_generationListRelationFilter
    miniapp_payment?: Miniapp_paymentListRelationFilter
  }, "id">

  export type collectionOrderByWithAggregationInput = {
    id?: SortOrder
    archived?: SortOrder
    batch_max_tokens?: SortOrderInput | SortOrder
    batch_mint_enabled?: SortOrder
    blockchain?: SortOrderInput | SortOrder
    cover_image_url?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    editions?: SortOrderInput | SortOrder
    encryption_enabled?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    is_current?: SortOrder
    price?: SortOrderInput | SortOrder
    project_id?: SortOrder
    publish_date?: SortOrderInput | SortOrder
    status?: SortOrder
    title?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    is_custodial?: SortOrder
    custodied_for?: SortOrderInput | SortOrder
    miniapp_cover_image?: SortOrderInput | SortOrder
    _count?: collectionCountOrderByAggregateInput
    _avg?: collectionAvgOrderByAggregateInput
    _max?: collectionMaxOrderByAggregateInput
    _min?: collectionMinOrderByAggregateInput
    _sum?: collectionSumOrderByAggregateInput
  }

  export type collectionScalarWhereWithAggregatesInput = {
    AND?: collectionScalarWhereWithAggregatesInput | collectionScalarWhereWithAggregatesInput[]
    OR?: collectionScalarWhereWithAggregatesInput[]
    NOT?: collectionScalarWhereWithAggregatesInput | collectionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"collection"> | string
    archived?: BoolWithAggregatesFilter<"collection"> | boolean
    batch_max_tokens?: IntNullableWithAggregatesFilter<"collection"> | number | null
    batch_mint_enabled?: BoolWithAggregatesFilter<"collection"> | boolean
    blockchain?: StringNullableWithAggregatesFilter<"collection"> | string | null
    cover_image_url?: StringNullableWithAggregatesFilter<"collection"> | string | null
    data?: JsonNullableWithAggregatesFilter<"collection">
    description?: StringNullableWithAggregatesFilter<"collection"> | string | null
    editions?: IntNullableWithAggregatesFilter<"collection"> | number | null
    encryption_enabled?: BoolNullableWithAggregatesFilter<"collection"> | boolean | null
    images?: JsonNullableWithAggregatesFilter<"collection">
    is_current?: BoolWithAggregatesFilter<"collection"> | boolean
    price?: FloatNullableWithAggregatesFilter<"collection"> | number | null
    project_id?: UuidWithAggregatesFilter<"collection"> | string
    publish_date?: DateTimeNullableWithAggregatesFilter<"collection"> | Date | string | null
    status?: StringWithAggregatesFilter<"collection"> | string
    title?: StringNullableWithAggregatesFilter<"collection"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"collection"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"collection"> | Date | string
    is_custodial?: BoolWithAggregatesFilter<"collection"> | boolean
    custodied_for?: UuidNullableWithAggregatesFilter<"collection"> | string | null
    miniapp_cover_image?: StringNullableWithAggregatesFilter<"collection"> | string | null
  }

  export type collection_remixWhereInput = {
    AND?: collection_remixWhereInput | collection_remixWhereInput[]
    OR?: collection_remixWhereInput[]
    NOT?: collection_remixWhereInput | collection_remixWhereInput[]
    id?: BigIntFilter<"collection_remix"> | bigint | number
    source_collection_id?: UuidFilter<"collection_remix"> | string
    target_collection_id?: UuidFilter<"collection_remix"> | string
    created_at?: DateTimeNullableFilter<"collection_remix"> | Date | string | null
    collection_preview_version_id?: BigIntNullableFilter<"collection_remix"> | bigint | number | null
    collection_preview_version?: XOR<Collection_preview_versionNullableRelationFilter, collection_preview_versionWhereInput> | null
    source_collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    target_collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }

  export type collection_remixOrderByWithRelationInput = {
    id?: SortOrder
    source_collection_id?: SortOrder
    target_collection_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    collection_preview_version_id?: SortOrderInput | SortOrder
    collection_preview_version?: collection_preview_versionOrderByWithRelationInput
    source_collection?: collectionOrderByWithRelationInput
    target_collection?: collectionOrderByWithRelationInput
  }

  export type collection_remixWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: collection_remixWhereInput | collection_remixWhereInput[]
    OR?: collection_remixWhereInput[]
    NOT?: collection_remixWhereInput | collection_remixWhereInput[]
    source_collection_id?: UuidFilter<"collection_remix"> | string
    target_collection_id?: UuidFilter<"collection_remix"> | string
    created_at?: DateTimeNullableFilter<"collection_remix"> | Date | string | null
    collection_preview_version_id?: BigIntNullableFilter<"collection_remix"> | bigint | number | null
    collection_preview_version?: XOR<Collection_preview_versionNullableRelationFilter, collection_preview_versionWhereInput> | null
    source_collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    target_collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }, "id">

  export type collection_remixOrderByWithAggregationInput = {
    id?: SortOrder
    source_collection_id?: SortOrder
    target_collection_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    collection_preview_version_id?: SortOrderInput | SortOrder
    _count?: collection_remixCountOrderByAggregateInput
    _avg?: collection_remixAvgOrderByAggregateInput
    _max?: collection_remixMaxOrderByAggregateInput
    _min?: collection_remixMinOrderByAggregateInput
    _sum?: collection_remixSumOrderByAggregateInput
  }

  export type collection_remixScalarWhereWithAggregatesInput = {
    AND?: collection_remixScalarWhereWithAggregatesInput | collection_remixScalarWhereWithAggregatesInput[]
    OR?: collection_remixScalarWhereWithAggregatesInput[]
    NOT?: collection_remixScalarWhereWithAggregatesInput | collection_remixScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"collection_remix"> | bigint | number
    source_collection_id?: UuidWithAggregatesFilter<"collection_remix"> | string
    target_collection_id?: UuidWithAggregatesFilter<"collection_remix"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"collection_remix"> | Date | string | null
    collection_preview_version_id?: BigIntNullableWithAggregatesFilter<"collection_remix"> | bigint | number | null
  }

  export type eventWhereInput = {
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    id?: UuidFilter<"event"> | string
    event_name?: StringFilter<"event"> | string
    property_name?: StringFilter<"event"> | string
    property_value?: StringNullableFilter<"event"> | string | null
    created_at?: DateTimeFilter<"event"> | Date | string
    user_id?: UuidFilter<"event"> | string
    event_id?: UuidFilter<"event"> | string
    event_type?: StringFilter<"event"> | string
  }

  export type eventOrderByWithRelationInput = {
    id?: SortOrder
    event_name?: SortOrder
    property_name?: SortOrder
    property_value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_type?: SortOrder
  }

  export type eventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    event_name?: StringFilter<"event"> | string
    property_name?: StringFilter<"event"> | string
    property_value?: StringNullableFilter<"event"> | string | null
    created_at?: DateTimeFilter<"event"> | Date | string
    user_id?: UuidFilter<"event"> | string
    event_id?: UuidFilter<"event"> | string
    event_type?: StringFilter<"event"> | string
  }, "id">

  export type eventOrderByWithAggregationInput = {
    id?: SortOrder
    event_name?: SortOrder
    property_name?: SortOrder
    property_value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_type?: SortOrder
    _count?: eventCountOrderByAggregateInput
    _max?: eventMaxOrderByAggregateInput
    _min?: eventMinOrderByAggregateInput
  }

  export type eventScalarWhereWithAggregatesInput = {
    AND?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    OR?: eventScalarWhereWithAggregatesInput[]
    NOT?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"event"> | string
    event_name?: StringWithAggregatesFilter<"event"> | string
    property_name?: StringWithAggregatesFilter<"event"> | string
    property_value?: StringNullableWithAggregatesFilter<"event"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"event"> | Date | string
    user_id?: UuidWithAggregatesFilter<"event"> | string
    event_id?: UuidWithAggregatesFilter<"event"> | string
    event_type?: StringWithAggregatesFilter<"event"> | string
  }

  export type flat_fileWhereInput = {
    AND?: flat_fileWhereInput | flat_fileWhereInput[]
    OR?: flat_fileWhereInput[]
    NOT?: flat_fileWhereInput | flat_fileWhereInput[]
    id?: BigIntFilter<"flat_file"> | bigint | number
    created_at?: DateTimeNullableFilter<"flat_file"> | Date | string | null
    url?: StringNullableFilter<"flat_file"> | string | null
    hidden?: BoolNullableFilter<"flat_file"> | boolean | null
    user_id?: UuidFilter<"flat_file"> | string
    name?: StringFilter<"flat_file"> | string
    gen_in_data?: JsonNullableFilter<"flat_file">
    gen_out_data?: JsonNullableFilter<"flat_file">
    mime_type?: StringNullableFilter<"flat_file"> | string | null
    rel_id?: StringNullableFilter<"flat_file"> | string | null
    rel_type?: StringNullableFilter<"flat_file"> | string | null
    tags?: StringNullableListFilter<"flat_file">
    chat_message?: Chat_messageListRelationFilter
    component_flat_files?: Component_flat_fileListRelationFilter
  }

  export type flat_fileOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    hidden?: SortOrderInput | SortOrder
    user_id?: SortOrder
    name?: SortOrder
    gen_in_data?: SortOrderInput | SortOrder
    gen_out_data?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    rel_id?: SortOrderInput | SortOrder
    rel_type?: SortOrderInput | SortOrder
    tags?: SortOrder
    chat_message?: chat_messageOrderByRelationAggregateInput
    component_flat_files?: component_flat_fileOrderByRelationAggregateInput
  }

  export type flat_fileWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: flat_fileWhereInput | flat_fileWhereInput[]
    OR?: flat_fileWhereInput[]
    NOT?: flat_fileWhereInput | flat_fileWhereInput[]
    created_at?: DateTimeNullableFilter<"flat_file"> | Date | string | null
    url?: StringNullableFilter<"flat_file"> | string | null
    hidden?: BoolNullableFilter<"flat_file"> | boolean | null
    user_id?: UuidFilter<"flat_file"> | string
    name?: StringFilter<"flat_file"> | string
    gen_in_data?: JsonNullableFilter<"flat_file">
    gen_out_data?: JsonNullableFilter<"flat_file">
    mime_type?: StringNullableFilter<"flat_file"> | string | null
    rel_id?: StringNullableFilter<"flat_file"> | string | null
    rel_type?: StringNullableFilter<"flat_file"> | string | null
    tags?: StringNullableListFilter<"flat_file">
    chat_message?: Chat_messageListRelationFilter
    component_flat_files?: Component_flat_fileListRelationFilter
  }, "id">

  export type flat_fileOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    hidden?: SortOrderInput | SortOrder
    user_id?: SortOrder
    name?: SortOrder
    gen_in_data?: SortOrderInput | SortOrder
    gen_out_data?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    rel_id?: SortOrderInput | SortOrder
    rel_type?: SortOrderInput | SortOrder
    tags?: SortOrder
    _count?: flat_fileCountOrderByAggregateInput
    _avg?: flat_fileAvgOrderByAggregateInput
    _max?: flat_fileMaxOrderByAggregateInput
    _min?: flat_fileMinOrderByAggregateInput
    _sum?: flat_fileSumOrderByAggregateInput
  }

  export type flat_fileScalarWhereWithAggregatesInput = {
    AND?: flat_fileScalarWhereWithAggregatesInput | flat_fileScalarWhereWithAggregatesInput[]
    OR?: flat_fileScalarWhereWithAggregatesInput[]
    NOT?: flat_fileScalarWhereWithAggregatesInput | flat_fileScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"flat_file"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"flat_file"> | Date | string | null
    url?: StringNullableWithAggregatesFilter<"flat_file"> | string | null
    hidden?: BoolNullableWithAggregatesFilter<"flat_file"> | boolean | null
    user_id?: UuidWithAggregatesFilter<"flat_file"> | string
    name?: StringWithAggregatesFilter<"flat_file"> | string
    gen_in_data?: JsonNullableWithAggregatesFilter<"flat_file">
    gen_out_data?: JsonNullableWithAggregatesFilter<"flat_file">
    mime_type?: StringNullableWithAggregatesFilter<"flat_file"> | string | null
    rel_id?: StringNullableWithAggregatesFilter<"flat_file"> | string | null
    rel_type?: StringNullableWithAggregatesFilter<"flat_file"> | string | null
    tags?: StringNullableListFilter<"flat_file">
  }

  export type component_flat_fileWhereInput = {
    AND?: component_flat_fileWhereInput | component_flat_fileWhereInput[]
    OR?: component_flat_fileWhereInput[]
    NOT?: component_flat_fileWhereInput | component_flat_fileWhereInput[]
    id?: BigIntFilter<"component_flat_file"> | bigint | number
    component_id?: BigIntFilter<"component_flat_file"> | bigint | number
    flat_file_id?: BigIntFilter<"component_flat_file"> | bigint | number
    component?: XOR<ComponentRelationFilter, componentWhereInput>
    flat_file?: XOR<Flat_fileRelationFilter, flat_fileWhereInput>
  }

  export type component_flat_fileOrderByWithRelationInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    component?: componentOrderByWithRelationInput
    flat_file?: flat_fileOrderByWithRelationInput
  }

  export type component_flat_fileWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    component_id_flat_file_id?: component_flat_fileComponent_idFlat_file_idCompoundUniqueInput
    AND?: component_flat_fileWhereInput | component_flat_fileWhereInput[]
    OR?: component_flat_fileWhereInput[]
    NOT?: component_flat_fileWhereInput | component_flat_fileWhereInput[]
    component_id?: BigIntFilter<"component_flat_file"> | bigint | number
    flat_file_id?: BigIntFilter<"component_flat_file"> | bigint | number
    component?: XOR<ComponentRelationFilter, componentWhereInput>
    flat_file?: XOR<Flat_fileRelationFilter, flat_fileWhereInput>
  }, "id" | "component_id_flat_file_id">

  export type component_flat_fileOrderByWithAggregationInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    _count?: component_flat_fileCountOrderByAggregateInput
    _avg?: component_flat_fileAvgOrderByAggregateInput
    _max?: component_flat_fileMaxOrderByAggregateInput
    _min?: component_flat_fileMinOrderByAggregateInput
    _sum?: component_flat_fileSumOrderByAggregateInput
  }

  export type component_flat_fileScalarWhereWithAggregatesInput = {
    AND?: component_flat_fileScalarWhereWithAggregatesInput | component_flat_fileScalarWhereWithAggregatesInput[]
    OR?: component_flat_fileScalarWhereWithAggregatesInput[]
    NOT?: component_flat_fileScalarWhereWithAggregatesInput | component_flat_fileScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"component_flat_file"> | bigint | number
    component_id?: BigIntWithAggregatesFilter<"component_flat_file"> | bigint | number
    flat_file_id?: BigIntWithAggregatesFilter<"component_flat_file"> | bigint | number
  }

  export type projectWhereInput = {
    AND?: projectWhereInput | projectWhereInput[]
    OR?: projectWhereInput[]
    NOT?: projectWhereInput | projectWhereInput[]
    id?: UuidFilter<"project"> | string
    created_at?: DateTimeFilter<"project"> | Date | string
    name?: StringFilter<"project"> | string
    user_id?: UuidFilter<"project"> | string
    data?: JsonNullableFilter<"project">
    current_project_history_id?: UuidNullableFilter<"project"> | string | null
    version?: StringNullableFilter<"project"> | string | null
    archived?: BoolFilter<"project"> | boolean
    is_default?: BoolFilter<"project"> | boolean
    collection?: CollectionListRelationFilter
  }

  export type projectOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    data?: SortOrderInput | SortOrder
    current_project_history_id?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    archived?: SortOrder
    is_default?: SortOrder
    collection?: collectionOrderByRelationAggregateInput
  }

  export type projectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: projectWhereInput | projectWhereInput[]
    OR?: projectWhereInput[]
    NOT?: projectWhereInput | projectWhereInput[]
    created_at?: DateTimeFilter<"project"> | Date | string
    name?: StringFilter<"project"> | string
    user_id?: UuidFilter<"project"> | string
    data?: JsonNullableFilter<"project">
    current_project_history_id?: UuidNullableFilter<"project"> | string | null
    version?: StringNullableFilter<"project"> | string | null
    archived?: BoolFilter<"project"> | boolean
    is_default?: BoolFilter<"project"> | boolean
    collection?: CollectionListRelationFilter
  }, "id">

  export type projectOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    data?: SortOrderInput | SortOrder
    current_project_history_id?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    archived?: SortOrder
    is_default?: SortOrder
    _count?: projectCountOrderByAggregateInput
    _max?: projectMaxOrderByAggregateInput
    _min?: projectMinOrderByAggregateInput
  }

  export type projectScalarWhereWithAggregatesInput = {
    AND?: projectScalarWhereWithAggregatesInput | projectScalarWhereWithAggregatesInput[]
    OR?: projectScalarWhereWithAggregatesInput[]
    NOT?: projectScalarWhereWithAggregatesInput | projectScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"project"> | string
    created_at?: DateTimeWithAggregatesFilter<"project"> | Date | string
    name?: StringWithAggregatesFilter<"project"> | string
    user_id?: UuidWithAggregatesFilter<"project"> | string
    data?: JsonNullableWithAggregatesFilter<"project">
    current_project_history_id?: UuidNullableWithAggregatesFilter<"project"> | string | null
    version?: StringNullableWithAggregatesFilter<"project"> | string | null
    archived?: BoolWithAggregatesFilter<"project"> | boolean
    is_default?: BoolWithAggregatesFilter<"project"> | boolean
  }

  export type project_historyWhereInput = {
    AND?: project_historyWhereInput | project_historyWhereInput[]
    OR?: project_historyWhereInput[]
    NOT?: project_historyWhereInput | project_historyWhereInput[]
    id?: UuidFilter<"project_history"> | string
    created_at?: DateTimeFilter<"project_history"> | Date | string
    data?: JsonFilter<"project_history">
    user_id?: UuidFilter<"project_history"> | string
    project_id?: UuidFilter<"project_history"> | string
    name?: StringFilter<"project_history"> | string
    images?: JsonNullableFilter<"project_history">
  }

  export type project_historyOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    data?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    images?: SortOrderInput | SortOrder
  }

  export type project_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: project_historyWhereInput | project_historyWhereInput[]
    OR?: project_historyWhereInput[]
    NOT?: project_historyWhereInput | project_historyWhereInput[]
    created_at?: DateTimeFilter<"project_history"> | Date | string
    data?: JsonFilter<"project_history">
    user_id?: UuidFilter<"project_history"> | string
    project_id?: UuidFilter<"project_history"> | string
    name?: StringFilter<"project_history"> | string
    images?: JsonNullableFilter<"project_history">
  }, "id">

  export type project_historyOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    data?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    images?: SortOrderInput | SortOrder
    _count?: project_historyCountOrderByAggregateInput
    _max?: project_historyMaxOrderByAggregateInput
    _min?: project_historyMinOrderByAggregateInput
  }

  export type project_historyScalarWhereWithAggregatesInput = {
    AND?: project_historyScalarWhereWithAggregatesInput | project_historyScalarWhereWithAggregatesInput[]
    OR?: project_historyScalarWhereWithAggregatesInput[]
    NOT?: project_historyScalarWhereWithAggregatesInput | project_historyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"project_history"> | string
    created_at?: DateTimeWithAggregatesFilter<"project_history"> | Date | string
    data?: JsonWithAggregatesFilter<"project_history">
    user_id?: UuidWithAggregatesFilter<"project_history"> | string
    project_id?: UuidWithAggregatesFilter<"project_history"> | string
    name?: StringWithAggregatesFilter<"project_history"> | string
    images?: JsonNullableWithAggregatesFilter<"project_history">
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: UuidFilter<"role"> | string
    user_id?: UuidFilter<"role"> | string
    created_at?: DateTimeFilter<"role"> | Date | string
    name?: StringFilter<"role"> | string
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    user_id?: UuidFilter<"role"> | string
    created_at?: DateTimeFilter<"role"> | Date | string
    name?: StringFilter<"role"> | string
  }, "id">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"role"> | string
    user_id?: UuidWithAggregatesFilter<"role"> | string
    created_at?: DateTimeWithAggregatesFilter<"role"> | Date | string
    name?: StringWithAggregatesFilter<"role"> | string
  }

  export type walletWhereInput = {
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    id?: BigIntFilter<"wallet"> | bigint | number
    created_at?: DateTimeNullableFilter<"wallet"> | Date | string | null
    address?: StringFilter<"wallet"> | string
    user_id?: UuidNullableFilter<"wallet"> | string | null
  }

  export type walletOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    address?: SortOrder
    user_id?: SortOrderInput | SortOrder
  }

  export type walletWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    address?: string
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    created_at?: DateTimeNullableFilter<"wallet"> | Date | string | null
    user_id?: UuidNullableFilter<"wallet"> | string | null
  }, "id" | "address">

  export type walletOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    address?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: walletCountOrderByAggregateInput
    _avg?: walletAvgOrderByAggregateInput
    _max?: walletMaxOrderByAggregateInput
    _min?: walletMinOrderByAggregateInput
    _sum?: walletSumOrderByAggregateInput
  }

  export type walletScalarWhereWithAggregatesInput = {
    AND?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    OR?: walletScalarWhereWithAggregatesInput[]
    NOT?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"wallet"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"wallet"> | Date | string | null
    address?: StringWithAggregatesFilter<"wallet"> | string
    user_id?: UuidNullableWithAggregatesFilter<"wallet"> | string | null
  }

  export type credits_historyWhereInput = {
    AND?: credits_historyWhereInput | credits_historyWhereInput[]
    OR?: credits_historyWhereInput[]
    NOT?: credits_historyWhereInput | credits_historyWhereInput[]
    id?: IntFilter<"credits_history"> | number
    flow?: StringFilter<"credits_history"> | string
    amount?: DecimalFilter<"credits_history"> | Decimal | DecimalJsLike | number | string
    credit_type?: StringFilter<"credits_history"> | string
    created_at?: DateTimeNullableFilter<"credits_history"> | Date | string | null
    user_id?: UuidFilter<"credits_history"> | string
    comment?: StringNullableFilter<"credits_history"> | string | null
  }

  export type credits_historyOrderByWithRelationInput = {
    id?: SortOrder
    flow?: SortOrder
    amount?: SortOrder
    credit_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    comment?: SortOrderInput | SortOrder
  }

  export type credits_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: credits_historyWhereInput | credits_historyWhereInput[]
    OR?: credits_historyWhereInput[]
    NOT?: credits_historyWhereInput | credits_historyWhereInput[]
    flow?: StringFilter<"credits_history"> | string
    amount?: DecimalFilter<"credits_history"> | Decimal | DecimalJsLike | number | string
    credit_type?: StringFilter<"credits_history"> | string
    created_at?: DateTimeNullableFilter<"credits_history"> | Date | string | null
    user_id?: UuidFilter<"credits_history"> | string
    comment?: StringNullableFilter<"credits_history"> | string | null
  }, "id">

  export type credits_historyOrderByWithAggregationInput = {
    id?: SortOrder
    flow?: SortOrder
    amount?: SortOrder
    credit_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: credits_historyCountOrderByAggregateInput
    _avg?: credits_historyAvgOrderByAggregateInput
    _max?: credits_historyMaxOrderByAggregateInput
    _min?: credits_historyMinOrderByAggregateInput
    _sum?: credits_historySumOrderByAggregateInput
  }

  export type credits_historyScalarWhereWithAggregatesInput = {
    AND?: credits_historyScalarWhereWithAggregatesInput | credits_historyScalarWhereWithAggregatesInput[]
    OR?: credits_historyScalarWhereWithAggregatesInput[]
    NOT?: credits_historyScalarWhereWithAggregatesInput | credits_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"credits_history"> | number
    flow?: StringWithAggregatesFilter<"credits_history"> | string
    amount?: DecimalWithAggregatesFilter<"credits_history"> | Decimal | DecimalJsLike | number | string
    credit_type?: StringWithAggregatesFilter<"credits_history"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"credits_history"> | Date | string | null
    user_id?: UuidWithAggregatesFilter<"credits_history"> | string
    comment?: StringNullableWithAggregatesFilter<"credits_history"> | string | null
  }

  export type credits_balanceWhereInput = {
    AND?: credits_balanceWhereInput | credits_balanceWhereInput[]
    OR?: credits_balanceWhereInput[]
    NOT?: credits_balanceWhereInput | credits_balanceWhereInput[]
    id?: IntFilter<"credits_balance"> | number
    user_id?: UuidFilter<"credits_balance"> | string
    created_at?: DateTimeNullableFilter<"credits_balance"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"credits_balance"> | Date | string | null
    balance?: DecimalFilter<"credits_balance"> | Decimal | DecimalJsLike | number | string
    credit_type?: StringFilter<"credits_balance"> | string
  }

  export type credits_balanceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    balance?: SortOrder
    credit_type?: SortOrder
  }

  export type credits_balanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: credits_balanceWhereInput | credits_balanceWhereInput[]
    OR?: credits_balanceWhereInput[]
    NOT?: credits_balanceWhereInput | credits_balanceWhereInput[]
    user_id?: UuidFilter<"credits_balance"> | string
    created_at?: DateTimeNullableFilter<"credits_balance"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"credits_balance"> | Date | string | null
    balance?: DecimalFilter<"credits_balance"> | Decimal | DecimalJsLike | number | string
    credit_type?: StringFilter<"credits_balance"> | string
  }, "id">

  export type credits_balanceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    balance?: SortOrder
    credit_type?: SortOrder
    _count?: credits_balanceCountOrderByAggregateInput
    _avg?: credits_balanceAvgOrderByAggregateInput
    _max?: credits_balanceMaxOrderByAggregateInput
    _min?: credits_balanceMinOrderByAggregateInput
    _sum?: credits_balanceSumOrderByAggregateInput
  }

  export type credits_balanceScalarWhereWithAggregatesInput = {
    AND?: credits_balanceScalarWhereWithAggregatesInput | credits_balanceScalarWhereWithAggregatesInput[]
    OR?: credits_balanceScalarWhereWithAggregatesInput[]
    NOT?: credits_balanceScalarWhereWithAggregatesInput | credits_balanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"credits_balance"> | number
    user_id?: UuidWithAggregatesFilter<"credits_balance"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"credits_balance"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"credits_balance"> | Date | string | null
    balance?: DecimalWithAggregatesFilter<"credits_balance"> | Decimal | DecimalJsLike | number | string
    credit_type?: StringWithAggregatesFilter<"credits_balance"> | string
  }

  export type subscriptionWhereInput = {
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    id?: UuidFilter<"subscription"> | string
    stripe_subscription_id?: StringFilter<"subscription"> | string
    created_at?: DateTimeNullableFilter<"subscription"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"subscription"> | Date | string | null
    user_id?: UuidNullableFilter<"subscription"> | string | null
    status?: StringFilter<"subscription"> | string
    stripe_product_id?: StringFilter<"subscription"> | string
    subscription_key?: StringFilter<"subscription"> | string
    cancel_at_period_end?: BoolFilter<"subscription"> | boolean
    current_period_end?: DateTimeFilter<"subscription"> | Date | string
    current_period_start?: DateTimeFilter<"subscription"> | Date | string
  }

  export type subscriptionOrderByWithRelationInput = {
    id?: SortOrder
    stripe_subscription_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrder
    stripe_product_id?: SortOrder
    subscription_key?: SortOrder
    cancel_at_period_end?: SortOrder
    current_period_end?: SortOrder
    current_period_start?: SortOrder
  }

  export type subscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripe_subscription_id?: string
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    created_at?: DateTimeNullableFilter<"subscription"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"subscription"> | Date | string | null
    user_id?: UuidNullableFilter<"subscription"> | string | null
    status?: StringFilter<"subscription"> | string
    stripe_product_id?: StringFilter<"subscription"> | string
    subscription_key?: StringFilter<"subscription"> | string
    cancel_at_period_end?: BoolFilter<"subscription"> | boolean
    current_period_end?: DateTimeFilter<"subscription"> | Date | string
    current_period_start?: DateTimeFilter<"subscription"> | Date | string
  }, "id" | "stripe_subscription_id">

  export type subscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    stripe_subscription_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrder
    stripe_product_id?: SortOrder
    subscription_key?: SortOrder
    cancel_at_period_end?: SortOrder
    current_period_end?: SortOrder
    current_period_start?: SortOrder
    _count?: subscriptionCountOrderByAggregateInput
    _max?: subscriptionMaxOrderByAggregateInput
    _min?: subscriptionMinOrderByAggregateInput
  }

  export type subscriptionScalarWhereWithAggregatesInput = {
    AND?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    OR?: subscriptionScalarWhereWithAggregatesInput[]
    NOT?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"subscription"> | string
    stripe_subscription_id?: StringWithAggregatesFilter<"subscription"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"subscription"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"subscription"> | Date | string | null
    user_id?: UuidNullableWithAggregatesFilter<"subscription"> | string | null
    status?: StringWithAggregatesFilter<"subscription"> | string
    stripe_product_id?: StringWithAggregatesFilter<"subscription"> | string
    subscription_key?: StringWithAggregatesFilter<"subscription"> | string
    cancel_at_period_end?: BoolWithAggregatesFilter<"subscription"> | boolean
    current_period_end?: DateTimeWithAggregatesFilter<"subscription"> | Date | string
    current_period_start?: DateTimeWithAggregatesFilter<"subscription"> | Date | string
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    id?: UuidFilter<"customer"> | string
    stripe_customer_id?: StringNullableFilter<"customer"> | string | null
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    prefinery_referral_code?: StringNullableFilter<"customer"> | string | null
    has_migrated?: BoolFilter<"customer"> | boolean
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    prefinery_referral_code?: SortOrderInput | SortOrder
    has_migrated?: SortOrder
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripe_customer_id?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    prefinery_referral_code?: StringNullableFilter<"customer"> | string | null
    has_migrated?: BoolFilter<"customer"> | boolean
  }, "id" | "stripe_customer_id">

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    prefinery_referral_code?: SortOrderInput | SortOrder
    has_migrated?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"customer"> | string
    stripe_customer_id?: StringNullableWithAggregatesFilter<"customer"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
    prefinery_referral_code?: StringNullableWithAggregatesFilter<"customer"> | string | null
    has_migrated?: BoolWithAggregatesFilter<"customer"> | boolean
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    type?: StringFilter<"product"> | string
    stripe_price_id?: StringFilter<"product"> | string
    stripe_product_id?: StringFilter<"product"> | string
    price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    credits_quantity?: IntNullableFilter<"product"> | number | null
    credits_type?: StringNullableFilter<"product"> | string | null
    active?: BoolFilter<"product"> | boolean
    created_at?: DateTimeNullableFilter<"product"> | Date | string | null
    updated_at?: DateTimeFilter<"product"> | Date | string
    lookup_key?: StringFilter<"product"> | string
    rank?: IntFilter<"product"> | number
    features?: StringNullableFilter<"product"> | string | null
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    stripe_price_id?: SortOrder
    stripe_product_id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrderInput | SortOrder
    credits_type?: SortOrderInput | SortOrder
    active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    lookup_key?: SortOrder
    rank?: SortOrder
    features?: SortOrderInput | SortOrder
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripe_price_id?: string
    lookup_key?: string
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    name?: StringFilter<"product"> | string
    type?: StringFilter<"product"> | string
    stripe_product_id?: StringFilter<"product"> | string
    price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    credits_quantity?: IntNullableFilter<"product"> | number | null
    credits_type?: StringNullableFilter<"product"> | string | null
    active?: BoolFilter<"product"> | boolean
    created_at?: DateTimeNullableFilter<"product"> | Date | string | null
    updated_at?: DateTimeFilter<"product"> | Date | string
    rank?: IntFilter<"product"> | number
    features?: StringNullableFilter<"product"> | string | null
  }, "id" | "stripe_price_id" | "lookup_key">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    stripe_price_id?: SortOrder
    stripe_product_id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrderInput | SortOrder
    credits_type?: SortOrderInput | SortOrder
    active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    lookup_key?: SortOrder
    rank?: SortOrder
    features?: SortOrderInput | SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product"> | number
    name?: StringWithAggregatesFilter<"product"> | string
    type?: StringWithAggregatesFilter<"product"> | string
    stripe_price_id?: StringWithAggregatesFilter<"product"> | string
    stripe_product_id?: StringWithAggregatesFilter<"product"> | string
    price?: DecimalWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string
    credits_quantity?: IntNullableWithAggregatesFilter<"product"> | number | null
    credits_type?: StringNullableWithAggregatesFilter<"product"> | string | null
    active?: BoolWithAggregatesFilter<"product"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"product"> | Date | string | null
    updated_at?: DateTimeWithAggregatesFilter<"product"> | Date | string
    lookup_key?: StringWithAggregatesFilter<"product"> | string
    rank?: IntWithAggregatesFilter<"product"> | number
    features?: StringNullableWithAggregatesFilter<"product"> | string | null
  }

  export type project_templateWhereInput = {
    AND?: project_templateWhereInput | project_templateWhereInput[]
    OR?: project_templateWhereInput[]
    NOT?: project_templateWhereInput | project_templateWhereInput[]
    id?: BigIntFilter<"project_template"> | bigint | number
    name?: StringFilter<"project_template"> | string
    data?: JsonFilter<"project_template">
    created_at?: DateTimeFilter<"project_template"> | Date | string
    updated_at?: DateTimeNullableFilter<"project_template"> | Date | string | null
    current_project_history_id?: UuidNullableFilter<"project_template"> | string | null
    project_template_save?: Project_template_saveListRelationFilter
  }

  export type project_templateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    current_project_history_id?: SortOrderInput | SortOrder
    project_template_save?: project_template_saveOrderByRelationAggregateInput
  }

  export type project_templateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: project_templateWhereInput | project_templateWhereInput[]
    OR?: project_templateWhereInput[]
    NOT?: project_templateWhereInput | project_templateWhereInput[]
    name?: StringFilter<"project_template"> | string
    data?: JsonFilter<"project_template">
    created_at?: DateTimeFilter<"project_template"> | Date | string
    updated_at?: DateTimeNullableFilter<"project_template"> | Date | string | null
    current_project_history_id?: UuidNullableFilter<"project_template"> | string | null
    project_template_save?: Project_template_saveListRelationFilter
  }, "id">

  export type project_templateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    current_project_history_id?: SortOrderInput | SortOrder
    _count?: project_templateCountOrderByAggregateInput
    _avg?: project_templateAvgOrderByAggregateInput
    _max?: project_templateMaxOrderByAggregateInput
    _min?: project_templateMinOrderByAggregateInput
    _sum?: project_templateSumOrderByAggregateInput
  }

  export type project_templateScalarWhereWithAggregatesInput = {
    AND?: project_templateScalarWhereWithAggregatesInput | project_templateScalarWhereWithAggregatesInput[]
    OR?: project_templateScalarWhereWithAggregatesInput[]
    NOT?: project_templateScalarWhereWithAggregatesInput | project_templateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"project_template"> | bigint | number
    name?: StringWithAggregatesFilter<"project_template"> | string
    data?: JsonWithAggregatesFilter<"project_template">
    created_at?: DateTimeWithAggregatesFilter<"project_template"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"project_template"> | Date | string | null
    current_project_history_id?: UuidNullableWithAggregatesFilter<"project_template"> | string | null
  }

  export type project_template_saveWhereInput = {
    AND?: project_template_saveWhereInput | project_template_saveWhereInput[]
    OR?: project_template_saveWhereInput[]
    NOT?: project_template_saveWhereInput | project_template_saveWhereInput[]
    id?: BigIntFilter<"project_template_save"> | bigint | number
    name?: StringFilter<"project_template_save"> | string
    data?: JsonFilter<"project_template_save">
    images?: JsonNullableFilter<"project_template_save">
    created_at?: DateTimeFilter<"project_template_save"> | Date | string
    updated_at?: DateTimeNullableFilter<"project_template_save"> | Date | string | null
    project_template_id?: BigIntFilter<"project_template_save"> | bigint | number
    project_history_id?: UuidNullableFilter<"project_template_save"> | string | null
    project_template?: XOR<Project_templateRelationFilter, project_templateWhereInput>
  }

  export type project_template_saveOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    images?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    project_template_id?: SortOrder
    project_history_id?: SortOrderInput | SortOrder
    project_template?: project_templateOrderByWithRelationInput
  }

  export type project_template_saveWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: project_template_saveWhereInput | project_template_saveWhereInput[]
    OR?: project_template_saveWhereInput[]
    NOT?: project_template_saveWhereInput | project_template_saveWhereInput[]
    name?: StringFilter<"project_template_save"> | string
    data?: JsonFilter<"project_template_save">
    images?: JsonNullableFilter<"project_template_save">
    created_at?: DateTimeFilter<"project_template_save"> | Date | string
    updated_at?: DateTimeNullableFilter<"project_template_save"> | Date | string | null
    project_template_id?: BigIntFilter<"project_template_save"> | bigint | number
    project_history_id?: UuidNullableFilter<"project_template_save"> | string | null
    project_template?: XOR<Project_templateRelationFilter, project_templateWhereInput>
  }, "id">

  export type project_template_saveOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    images?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    project_template_id?: SortOrder
    project_history_id?: SortOrderInput | SortOrder
    _count?: project_template_saveCountOrderByAggregateInput
    _avg?: project_template_saveAvgOrderByAggregateInput
    _max?: project_template_saveMaxOrderByAggregateInput
    _min?: project_template_saveMinOrderByAggregateInput
    _sum?: project_template_saveSumOrderByAggregateInput
  }

  export type project_template_saveScalarWhereWithAggregatesInput = {
    AND?: project_template_saveScalarWhereWithAggregatesInput | project_template_saveScalarWhereWithAggregatesInput[]
    OR?: project_template_saveScalarWhereWithAggregatesInput[]
    NOT?: project_template_saveScalarWhereWithAggregatesInput | project_template_saveScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"project_template_save"> | bigint | number
    name?: StringWithAggregatesFilter<"project_template_save"> | string
    data?: JsonWithAggregatesFilter<"project_template_save">
    images?: JsonNullableWithAggregatesFilter<"project_template_save">
    created_at?: DateTimeWithAggregatesFilter<"project_template_save"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"project_template_save"> | Date | string | null
    project_template_id?: BigIntWithAggregatesFilter<"project_template_save"> | bigint | number
    project_history_id?: UuidNullableWithAggregatesFilter<"project_template_save"> | string | null
  }

  export type collection_rewardWhereInput = {
    AND?: collection_rewardWhereInput | collection_rewardWhereInput[]
    OR?: collection_rewardWhereInput[]
    NOT?: collection_rewardWhereInput | collection_rewardWhereInput[]
    id?: IntFilter<"collection_reward"> | number
    collection_id?: StringFilter<"collection_reward"> | string
    tag?: StringFilter<"collection_reward"> | string
    credits?: IntFilter<"collection_reward"> | number
    enabled?: BoolNullableFilter<"collection_reward"> | boolean | null
    created_at?: DateTimeFilter<"collection_reward"> | Date | string
    updated_at?: DateTimeNullableFilter<"collection_reward"> | Date | string | null
    collection_reward_redemption?: Collection_reward_redemptionListRelationFilter
  }

  export type collection_rewardOrderByWithRelationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    tag?: SortOrder
    credits?: SortOrder
    enabled?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    collection_reward_redemption?: collection_reward_redemptionOrderByRelationAggregateInput
  }

  export type collection_rewardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: collection_rewardWhereInput | collection_rewardWhereInput[]
    OR?: collection_rewardWhereInput[]
    NOT?: collection_rewardWhereInput | collection_rewardWhereInput[]
    collection_id?: StringFilter<"collection_reward"> | string
    tag?: StringFilter<"collection_reward"> | string
    credits?: IntFilter<"collection_reward"> | number
    enabled?: BoolNullableFilter<"collection_reward"> | boolean | null
    created_at?: DateTimeFilter<"collection_reward"> | Date | string
    updated_at?: DateTimeNullableFilter<"collection_reward"> | Date | string | null
    collection_reward_redemption?: Collection_reward_redemptionListRelationFilter
  }, "id">

  export type collection_rewardOrderByWithAggregationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    tag?: SortOrder
    credits?: SortOrder
    enabled?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: collection_rewardCountOrderByAggregateInput
    _avg?: collection_rewardAvgOrderByAggregateInput
    _max?: collection_rewardMaxOrderByAggregateInput
    _min?: collection_rewardMinOrderByAggregateInput
    _sum?: collection_rewardSumOrderByAggregateInput
  }

  export type collection_rewardScalarWhereWithAggregatesInput = {
    AND?: collection_rewardScalarWhereWithAggregatesInput | collection_rewardScalarWhereWithAggregatesInput[]
    OR?: collection_rewardScalarWhereWithAggregatesInput[]
    NOT?: collection_rewardScalarWhereWithAggregatesInput | collection_rewardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"collection_reward"> | number
    collection_id?: StringWithAggregatesFilter<"collection_reward"> | string
    tag?: StringWithAggregatesFilter<"collection_reward"> | string
    credits?: IntWithAggregatesFilter<"collection_reward"> | number
    enabled?: BoolNullableWithAggregatesFilter<"collection_reward"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"collection_reward"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"collection_reward"> | Date | string | null
  }

  export type collection_reward_redemptionWhereInput = {
    AND?: collection_reward_redemptionWhereInput | collection_reward_redemptionWhereInput[]
    OR?: collection_reward_redemptionWhereInput[]
    NOT?: collection_reward_redemptionWhereInput | collection_reward_redemptionWhereInput[]
    id?: IntFilter<"collection_reward_redemption"> | number
    user_id?: StringFilter<"collection_reward_redemption"> | string
    wallet_address?: StringFilter<"collection_reward_redemption"> | string
    token_id?: StringFilter<"collection_reward_redemption"> | string
    collection_reward_id?: IntFilter<"collection_reward_redemption"> | number
    created_at?: DateTimeFilter<"collection_reward_redemption"> | Date | string
    collection_reward?: XOR<Collection_rewardRelationFilter, collection_rewardWhereInput>
  }

  export type collection_reward_redemptionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    token_id?: SortOrder
    collection_reward_id?: SortOrder
    created_at?: SortOrder
    collection_reward?: collection_rewardOrderByWithRelationInput
  }

  export type collection_reward_redemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: collection_reward_redemptionWhereInput | collection_reward_redemptionWhereInput[]
    OR?: collection_reward_redemptionWhereInput[]
    NOT?: collection_reward_redemptionWhereInput | collection_reward_redemptionWhereInput[]
    user_id?: StringFilter<"collection_reward_redemption"> | string
    wallet_address?: StringFilter<"collection_reward_redemption"> | string
    token_id?: StringFilter<"collection_reward_redemption"> | string
    collection_reward_id?: IntFilter<"collection_reward_redemption"> | number
    created_at?: DateTimeFilter<"collection_reward_redemption"> | Date | string
    collection_reward?: XOR<Collection_rewardRelationFilter, collection_rewardWhereInput>
  }, "id">

  export type collection_reward_redemptionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    token_id?: SortOrder
    collection_reward_id?: SortOrder
    created_at?: SortOrder
    _count?: collection_reward_redemptionCountOrderByAggregateInput
    _avg?: collection_reward_redemptionAvgOrderByAggregateInput
    _max?: collection_reward_redemptionMaxOrderByAggregateInput
    _min?: collection_reward_redemptionMinOrderByAggregateInput
    _sum?: collection_reward_redemptionSumOrderByAggregateInput
  }

  export type collection_reward_redemptionScalarWhereWithAggregatesInput = {
    AND?: collection_reward_redemptionScalarWhereWithAggregatesInput | collection_reward_redemptionScalarWhereWithAggregatesInput[]
    OR?: collection_reward_redemptionScalarWhereWithAggregatesInput[]
    NOT?: collection_reward_redemptionScalarWhereWithAggregatesInput | collection_reward_redemptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"collection_reward_redemption"> | number
    user_id?: StringWithAggregatesFilter<"collection_reward_redemption"> | string
    wallet_address?: StringWithAggregatesFilter<"collection_reward_redemption"> | string
    token_id?: StringWithAggregatesFilter<"collection_reward_redemption"> | string
    collection_reward_id?: IntWithAggregatesFilter<"collection_reward_redemption"> | number
    created_at?: DateTimeWithAggregatesFilter<"collection_reward_redemption"> | Date | string
  }

  export type collection_sales_receiversWhereInput = {
    AND?: collection_sales_receiversWhereInput | collection_sales_receiversWhereInput[]
    OR?: collection_sales_receiversWhereInput[]
    NOT?: collection_sales_receiversWhereInput | collection_sales_receiversWhereInput[]
    id?: IntFilter<"collection_sales_receivers"> | number
    collection_id?: UuidFilter<"collection_sales_receivers"> | string
    address?: StringFilter<"collection_sales_receivers"> | string
    value?: FloatFilter<"collection_sales_receivers"> | number
    type?: StringFilter<"collection_sales_receivers"> | string
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }

  export type collection_sales_receiversOrderByWithRelationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    type?: SortOrder
    collection?: collectionOrderByWithRelationInput
  }

  export type collection_sales_receiversWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: collection_sales_receiversWhereInput | collection_sales_receiversWhereInput[]
    OR?: collection_sales_receiversWhereInput[]
    NOT?: collection_sales_receiversWhereInput | collection_sales_receiversWhereInput[]
    collection_id?: UuidFilter<"collection_sales_receivers"> | string
    address?: StringFilter<"collection_sales_receivers"> | string
    value?: FloatFilter<"collection_sales_receivers"> | number
    type?: StringFilter<"collection_sales_receivers"> | string
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }, "id">

  export type collection_sales_receiversOrderByWithAggregationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    type?: SortOrder
    _count?: collection_sales_receiversCountOrderByAggregateInput
    _avg?: collection_sales_receiversAvgOrderByAggregateInput
    _max?: collection_sales_receiversMaxOrderByAggregateInput
    _min?: collection_sales_receiversMinOrderByAggregateInput
    _sum?: collection_sales_receiversSumOrderByAggregateInput
  }

  export type collection_sales_receiversScalarWhereWithAggregatesInput = {
    AND?: collection_sales_receiversScalarWhereWithAggregatesInput | collection_sales_receiversScalarWhereWithAggregatesInput[]
    OR?: collection_sales_receiversScalarWhereWithAggregatesInput[]
    NOT?: collection_sales_receiversScalarWhereWithAggregatesInput | collection_sales_receiversScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"collection_sales_receivers"> | number
    collection_id?: UuidWithAggregatesFilter<"collection_sales_receivers"> | string
    address?: StringWithAggregatesFilter<"collection_sales_receivers"> | string
    value?: FloatWithAggregatesFilter<"collection_sales_receivers"> | number
    type?: StringWithAggregatesFilter<"collection_sales_receivers"> | string
  }

  export type collection_historyWhereInput = {
    AND?: collection_historyWhereInput | collection_historyWhereInput[]
    OR?: collection_historyWhereInput[]
    NOT?: collection_historyWhereInput | collection_historyWhereInput[]
    id?: IntFilter<"collection_history"> | number
    event?: StringFilter<"collection_history"> | string
    current_value?: StringFilter<"collection_history"> | string
    new_value?: StringFilter<"collection_history"> | string
    created_at?: DateTimeFilter<"collection_history"> | Date | string
    collection_id?: UuidFilter<"collection_history"> | string
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }

  export type collection_historyOrderByWithRelationInput = {
    id?: SortOrder
    event?: SortOrder
    current_value?: SortOrder
    new_value?: SortOrder
    created_at?: SortOrder
    collection_id?: SortOrder
    collection?: collectionOrderByWithRelationInput
  }

  export type collection_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: collection_historyWhereInput | collection_historyWhereInput[]
    OR?: collection_historyWhereInput[]
    NOT?: collection_historyWhereInput | collection_historyWhereInput[]
    event?: StringFilter<"collection_history"> | string
    current_value?: StringFilter<"collection_history"> | string
    new_value?: StringFilter<"collection_history"> | string
    created_at?: DateTimeFilter<"collection_history"> | Date | string
    collection_id?: UuidFilter<"collection_history"> | string
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }, "id">

  export type collection_historyOrderByWithAggregationInput = {
    id?: SortOrder
    event?: SortOrder
    current_value?: SortOrder
    new_value?: SortOrder
    created_at?: SortOrder
    collection_id?: SortOrder
    _count?: collection_historyCountOrderByAggregateInput
    _avg?: collection_historyAvgOrderByAggregateInput
    _max?: collection_historyMaxOrderByAggregateInput
    _min?: collection_historyMinOrderByAggregateInput
    _sum?: collection_historySumOrderByAggregateInput
  }

  export type collection_historyScalarWhereWithAggregatesInput = {
    AND?: collection_historyScalarWhereWithAggregatesInput | collection_historyScalarWhereWithAggregatesInput[]
    OR?: collection_historyScalarWhereWithAggregatesInput[]
    NOT?: collection_historyScalarWhereWithAggregatesInput | collection_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"collection_history"> | number
    event?: StringWithAggregatesFilter<"collection_history"> | string
    current_value?: StringWithAggregatesFilter<"collection_history"> | string
    new_value?: StringWithAggregatesFilter<"collection_history"> | string
    created_at?: DateTimeWithAggregatesFilter<"collection_history"> | Date | string
    collection_id?: UuidWithAggregatesFilter<"collection_history"> | string
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    id?: UuidFilter<"profile"> | string
    profile_image?: StringNullableFilter<"profile"> | string | null
    profile_preference?: StringNullableFilter<"profile"> | string | null
    created_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    profile_username?: StringNullableFilter<"profile"> | string | null
  }

  export type profileOrderByWithRelationInput = {
    id?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    profile_preference?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    profile_username?: SortOrderInput | SortOrder
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    profile_image?: StringNullableFilter<"profile"> | string | null
    profile_preference?: StringNullableFilter<"profile"> | string | null
    created_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    profile_username?: StringNullableFilter<"profile"> | string | null
  }, "id">

  export type profileOrderByWithAggregationInput = {
    id?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    profile_preference?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    profile_username?: SortOrderInput | SortOrder
    _count?: profileCountOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"profile"> | string
    profile_image?: StringNullableWithAggregatesFilter<"profile"> | string | null
    profile_preference?: StringNullableWithAggregatesFilter<"profile"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
    profile_username?: StringNullableWithAggregatesFilter<"profile"> | string | null
  }

  export type collection_previewWhereInput = {
    AND?: collection_previewWhereInput | collection_previewWhereInput[]
    OR?: collection_previewWhereInput[]
    NOT?: collection_previewWhereInput | collection_previewWhereInput[]
    id?: BigIntFilter<"collection_preview"> | bigint | number
    enabled?: BoolFilter<"collection_preview"> | boolean
    max_generations?: IntFilter<"collection_preview"> | number
    total_generations?: IntFilter<"collection_preview"> | number
    collection_id?: UuidFilter<"collection_preview"> | string
    access_level?: StringFilter<"collection_preview"> | string
    is_remixable?: BoolFilter<"collection_preview"> | boolean
    farcaster_collection?: BoolFilter<"collection_preview"> | boolean
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    collection_preview_version?: Collection_preview_versionListRelationFilter
  }

  export type collection_previewOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
    collection_id?: SortOrder
    access_level?: SortOrder
    is_remixable?: SortOrder
    farcaster_collection?: SortOrder
    collection?: collectionOrderByWithRelationInput
    collection_preview_version?: collection_preview_versionOrderByRelationAggregateInput
  }

  export type collection_previewWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    collection_id?: string
    AND?: collection_previewWhereInput | collection_previewWhereInput[]
    OR?: collection_previewWhereInput[]
    NOT?: collection_previewWhereInput | collection_previewWhereInput[]
    enabled?: BoolFilter<"collection_preview"> | boolean
    max_generations?: IntFilter<"collection_preview"> | number
    total_generations?: IntFilter<"collection_preview"> | number
    access_level?: StringFilter<"collection_preview"> | string
    is_remixable?: BoolFilter<"collection_preview"> | boolean
    farcaster_collection?: BoolFilter<"collection_preview"> | boolean
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    collection_preview_version?: Collection_preview_versionListRelationFilter
  }, "id" | "collection_id">

  export type collection_previewOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
    collection_id?: SortOrder
    access_level?: SortOrder
    is_remixable?: SortOrder
    farcaster_collection?: SortOrder
    _count?: collection_previewCountOrderByAggregateInput
    _avg?: collection_previewAvgOrderByAggregateInput
    _max?: collection_previewMaxOrderByAggregateInput
    _min?: collection_previewMinOrderByAggregateInput
    _sum?: collection_previewSumOrderByAggregateInput
  }

  export type collection_previewScalarWhereWithAggregatesInput = {
    AND?: collection_previewScalarWhereWithAggregatesInput | collection_previewScalarWhereWithAggregatesInput[]
    OR?: collection_previewScalarWhereWithAggregatesInput[]
    NOT?: collection_previewScalarWhereWithAggregatesInput | collection_previewScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"collection_preview"> | bigint | number
    enabled?: BoolWithAggregatesFilter<"collection_preview"> | boolean
    max_generations?: IntWithAggregatesFilter<"collection_preview"> | number
    total_generations?: IntWithAggregatesFilter<"collection_preview"> | number
    collection_id?: UuidWithAggregatesFilter<"collection_preview"> | string
    access_level?: StringWithAggregatesFilter<"collection_preview"> | string
    is_remixable?: BoolWithAggregatesFilter<"collection_preview"> | boolean
    farcaster_collection?: BoolWithAggregatesFilter<"collection_preview"> | boolean
  }

  export type collection_preview_versionWhereInput = {
    AND?: collection_preview_versionWhereInput | collection_preview_versionWhereInput[]
    OR?: collection_preview_versionWhereInput[]
    NOT?: collection_preview_versionWhereInput | collection_preview_versionWhereInput[]
    id?: BigIntFilter<"collection_preview_version"> | bigint | number
    version?: IntFilter<"collection_preview_version"> | number
    collection_preview_id?: BigIntFilter<"collection_preview_version"> | bigint | number
    data?: JsonFilter<"collection_preview_version">
    is_latest?: BoolFilter<"collection_preview_version"> | boolean
    created_at?: DateTimeNullableFilter<"collection_preview_version"> | Date | string | null
    collection_preview?: XOR<Collection_previewRelationFilter, collection_previewWhereInput>
    collection_remix?: Collection_remixListRelationFilter
  }

  export type collection_preview_versionOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
    data?: SortOrder
    is_latest?: SortOrder
    created_at?: SortOrderInput | SortOrder
    collection_preview?: collection_previewOrderByWithRelationInput
    collection_remix?: collection_remixOrderByRelationAggregateInput
  }

  export type collection_preview_versionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: collection_preview_versionWhereInput | collection_preview_versionWhereInput[]
    OR?: collection_preview_versionWhereInput[]
    NOT?: collection_preview_versionWhereInput | collection_preview_versionWhereInput[]
    version?: IntFilter<"collection_preview_version"> | number
    collection_preview_id?: BigIntFilter<"collection_preview_version"> | bigint | number
    data?: JsonFilter<"collection_preview_version">
    is_latest?: BoolFilter<"collection_preview_version"> | boolean
    created_at?: DateTimeNullableFilter<"collection_preview_version"> | Date | string | null
    collection_preview?: XOR<Collection_previewRelationFilter, collection_previewWhereInput>
    collection_remix?: Collection_remixListRelationFilter
  }, "id">

  export type collection_preview_versionOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
    data?: SortOrder
    is_latest?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: collection_preview_versionCountOrderByAggregateInput
    _avg?: collection_preview_versionAvgOrderByAggregateInput
    _max?: collection_preview_versionMaxOrderByAggregateInput
    _min?: collection_preview_versionMinOrderByAggregateInput
    _sum?: collection_preview_versionSumOrderByAggregateInput
  }

  export type collection_preview_versionScalarWhereWithAggregatesInput = {
    AND?: collection_preview_versionScalarWhereWithAggregatesInput | collection_preview_versionScalarWhereWithAggregatesInput[]
    OR?: collection_preview_versionScalarWhereWithAggregatesInput[]
    NOT?: collection_preview_versionScalarWhereWithAggregatesInput | collection_preview_versionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"collection_preview_version"> | bigint | number
    version?: IntWithAggregatesFilter<"collection_preview_version"> | number
    collection_preview_id?: BigIntWithAggregatesFilter<"collection_preview_version"> | bigint | number
    data?: JsonWithAggregatesFilter<"collection_preview_version">
    is_latest?: BoolWithAggregatesFilter<"collection_preview_version"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"collection_preview_version"> | Date | string | null
  }

  export type collection_sample_imagesWhereInput = {
    AND?: collection_sample_imagesWhereInput | collection_sample_imagesWhereInput[]
    OR?: collection_sample_imagesWhereInput[]
    NOT?: collection_sample_imagesWhereInput | collection_sample_imagesWhereInput[]
    id?: BigIntFilter<"collection_sample_images"> | bigint | number
    url?: StringFilter<"collection_sample_images"> | string
    collection_id?: UuidFilter<"collection_sample_images"> | string
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }

  export type collection_sample_imagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    collection_id?: SortOrder
    collection?: collectionOrderByWithRelationInput
  }

  export type collection_sample_imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: collection_sample_imagesWhereInput | collection_sample_imagesWhereInput[]
    OR?: collection_sample_imagesWhereInput[]
    NOT?: collection_sample_imagesWhereInput | collection_sample_imagesWhereInput[]
    url?: StringFilter<"collection_sample_images"> | string
    collection_id?: UuidFilter<"collection_sample_images"> | string
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }, "id">

  export type collection_sample_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    collection_id?: SortOrder
    _count?: collection_sample_imagesCountOrderByAggregateInput
    _avg?: collection_sample_imagesAvgOrderByAggregateInput
    _max?: collection_sample_imagesMaxOrderByAggregateInput
    _min?: collection_sample_imagesMinOrderByAggregateInput
    _sum?: collection_sample_imagesSumOrderByAggregateInput
  }

  export type collection_sample_imagesScalarWhereWithAggregatesInput = {
    AND?: collection_sample_imagesScalarWhereWithAggregatesInput | collection_sample_imagesScalarWhereWithAggregatesInput[]
    OR?: collection_sample_imagesScalarWhereWithAggregatesInput[]
    NOT?: collection_sample_imagesScalarWhereWithAggregatesInput | collection_sample_imagesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"collection_sample_images"> | bigint | number
    url?: StringWithAggregatesFilter<"collection_sample_images"> | string
    collection_id?: UuidWithAggregatesFilter<"collection_sample_images"> | string
  }

  export type chatWhereInput = {
    AND?: chatWhereInput | chatWhereInput[]
    OR?: chatWhereInput[]
    NOT?: chatWhereInput | chatWhereInput[]
    id?: UuidFilter<"chat"> | string
    created_at?: DateTimeNullableFilter<"chat"> | Date | string | null
    entity_type?: StringFilter<"chat"> | string
    entity_id?: StringFilter<"chat"> | string
    chat_message?: Chat_messageListRelationFilter
  }

  export type chatOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    chat_message?: chat_messageOrderByRelationAggregateInput
  }

  export type chatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatWhereInput | chatWhereInput[]
    OR?: chatWhereInput[]
    NOT?: chatWhereInput | chatWhereInput[]
    created_at?: DateTimeNullableFilter<"chat"> | Date | string | null
    entity_type?: StringFilter<"chat"> | string
    entity_id?: StringFilter<"chat"> | string
    chat_message?: Chat_messageListRelationFilter
  }, "id">

  export type chatOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    _count?: chatCountOrderByAggregateInput
    _max?: chatMaxOrderByAggregateInput
    _min?: chatMinOrderByAggregateInput
  }

  export type chatScalarWhereWithAggregatesInput = {
    AND?: chatScalarWhereWithAggregatesInput | chatScalarWhereWithAggregatesInput[]
    OR?: chatScalarWhereWithAggregatesInput[]
    NOT?: chatScalarWhereWithAggregatesInput | chatScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"chat"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"chat"> | Date | string | null
    entity_type?: StringWithAggregatesFilter<"chat"> | string
    entity_id?: StringWithAggregatesFilter<"chat"> | string
  }

  export type chat_messageWhereInput = {
    AND?: chat_messageWhereInput | chat_messageWhereInput[]
    OR?: chat_messageWhereInput[]
    NOT?: chat_messageWhereInput | chat_messageWhereInput[]
    id?: UuidFilter<"chat_message"> | string
    created_at?: DateTimeNullableFilter<"chat_message"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_message"> | Date | string | null
    user_id?: UuidFilter<"chat_message"> | string
    content?: StringFilter<"chat_message"> | string
    chat_id?: UuidFilter<"chat_message"> | string
    flat_file_id?: BigIntNullableFilter<"chat_message"> | bigint | number | null
    chat?: XOR<ChatRelationFilter, chatWhereInput>
    flat_file?: XOR<Flat_fileNullableRelationFilter, flat_fileWhereInput> | null
  }

  export type chat_messageOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    content?: SortOrder
    chat_id?: SortOrder
    flat_file_id?: SortOrderInput | SortOrder
    chat?: chatOrderByWithRelationInput
    flat_file?: flat_fileOrderByWithRelationInput
  }

  export type chat_messageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chat_messageWhereInput | chat_messageWhereInput[]
    OR?: chat_messageWhereInput[]
    NOT?: chat_messageWhereInput | chat_messageWhereInput[]
    created_at?: DateTimeNullableFilter<"chat_message"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_message"> | Date | string | null
    user_id?: UuidFilter<"chat_message"> | string
    content?: StringFilter<"chat_message"> | string
    chat_id?: UuidFilter<"chat_message"> | string
    flat_file_id?: BigIntNullableFilter<"chat_message"> | bigint | number | null
    chat?: XOR<ChatRelationFilter, chatWhereInput>
    flat_file?: XOR<Flat_fileNullableRelationFilter, flat_fileWhereInput> | null
  }, "id">

  export type chat_messageOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    content?: SortOrder
    chat_id?: SortOrder
    flat_file_id?: SortOrderInput | SortOrder
    _count?: chat_messageCountOrderByAggregateInput
    _avg?: chat_messageAvgOrderByAggregateInput
    _max?: chat_messageMaxOrderByAggregateInput
    _min?: chat_messageMinOrderByAggregateInput
    _sum?: chat_messageSumOrderByAggregateInput
  }

  export type chat_messageScalarWhereWithAggregatesInput = {
    AND?: chat_messageScalarWhereWithAggregatesInput | chat_messageScalarWhereWithAggregatesInput[]
    OR?: chat_messageScalarWhereWithAggregatesInput[]
    NOT?: chat_messageScalarWhereWithAggregatesInput | chat_messageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"chat_message"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"chat_message"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"chat_message"> | Date | string | null
    user_id?: UuidWithAggregatesFilter<"chat_message"> | string
    content?: StringWithAggregatesFilter<"chat_message"> | string
    chat_id?: UuidWithAggregatesFilter<"chat_message"> | string
    flat_file_id?: BigIntNullableWithAggregatesFilter<"chat_message"> | bigint | number | null
  }

  export type socket_io_attachmentsWhereInput = {
    AND?: socket_io_attachmentsWhereInput | socket_io_attachmentsWhereInput[]
    OR?: socket_io_attachmentsWhereInput[]
    NOT?: socket_io_attachmentsWhereInput | socket_io_attachmentsWhereInput[]
    id?: BigIntFilter<"socket_io_attachments"> | bigint | number
    payload?: BytesFilter<"socket_io_attachments"> | Buffer
    created_at?: DateTimeNullableFilter<"socket_io_attachments"> | Date | string | null
  }

  export type socket_io_attachmentsOrderByWithRelationInput = {
    id?: SortOrder
    payload?: SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type socket_io_attachmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: socket_io_attachmentsWhereInput | socket_io_attachmentsWhereInput[]
    OR?: socket_io_attachmentsWhereInput[]
    NOT?: socket_io_attachmentsWhereInput | socket_io_attachmentsWhereInput[]
    payload?: BytesFilter<"socket_io_attachments"> | Buffer
    created_at?: DateTimeNullableFilter<"socket_io_attachments"> | Date | string | null
  }, "id">

  export type socket_io_attachmentsOrderByWithAggregationInput = {
    id?: SortOrder
    payload?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: socket_io_attachmentsCountOrderByAggregateInput
    _avg?: socket_io_attachmentsAvgOrderByAggregateInput
    _max?: socket_io_attachmentsMaxOrderByAggregateInput
    _min?: socket_io_attachmentsMinOrderByAggregateInput
    _sum?: socket_io_attachmentsSumOrderByAggregateInput
  }

  export type socket_io_attachmentsScalarWhereWithAggregatesInput = {
    AND?: socket_io_attachmentsScalarWhereWithAggregatesInput | socket_io_attachmentsScalarWhereWithAggregatesInput[]
    OR?: socket_io_attachmentsScalarWhereWithAggregatesInput[]
    NOT?: socket_io_attachmentsScalarWhereWithAggregatesInput | socket_io_attachmentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"socket_io_attachments"> | bigint | number
    payload?: BytesWithAggregatesFilter<"socket_io_attachments"> | Buffer
    created_at?: DateTimeNullableWithAggregatesFilter<"socket_io_attachments"> | Date | string | null
  }

  export type componentWhereInput = {
    AND?: componentWhereInput | componentWhereInput[]
    OR?: componentWhereInput[]
    NOT?: componentWhereInput | componentWhereInput[]
    id?: BigIntFilter<"component"> | bigint | number
    collection_id?: UuidFilter<"component"> | string
    created_at?: DateTimeNullableFilter<"component"> | Date | string | null
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    component_flat_files?: Component_flat_fileListRelationFilter
  }

  export type componentOrderByWithRelationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    collection?: collectionOrderByWithRelationInput
    component_flat_files?: component_flat_fileOrderByRelationAggregateInput
  }

  export type componentWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: componentWhereInput | componentWhereInput[]
    OR?: componentWhereInput[]
    NOT?: componentWhereInput | componentWhereInput[]
    collection_id?: UuidFilter<"component"> | string
    created_at?: DateTimeNullableFilter<"component"> | Date | string | null
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    component_flat_files?: Component_flat_fileListRelationFilter
  }, "id">

  export type componentOrderByWithAggregationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: componentCountOrderByAggregateInput
    _avg?: componentAvgOrderByAggregateInput
    _max?: componentMaxOrderByAggregateInput
    _min?: componentMinOrderByAggregateInput
    _sum?: componentSumOrderByAggregateInput
  }

  export type componentScalarWhereWithAggregatesInput = {
    AND?: componentScalarWhereWithAggregatesInput | componentScalarWhereWithAggregatesInput[]
    OR?: componentScalarWhereWithAggregatesInput[]
    NOT?: componentScalarWhereWithAggregatesInput | componentScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"component"> | bigint | number
    collection_id?: UuidWithAggregatesFilter<"component"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"component"> | Date | string | null
  }

  export type workflowWhereInput = {
    AND?: workflowWhereInput | workflowWhereInput[]
    OR?: workflowWhereInput[]
    NOT?: workflowWhereInput | workflowWhereInput[]
    id?: UuidFilter<"workflow"> | string
    name?: StringFilter<"workflow"> | string
    description?: StringNullableFilter<"workflow"> | string | null
    data?: JsonNullableFilter<"workflow">
    created_at?: DateTimeFilter<"workflow"> | Date | string
    server_id?: UuidNullableFilter<"workflow"> | string | null
    output_mime_type?: StringNullableFilter<"workflow"> | string | null
    display?: BoolNullableFilter<"workflow"> | boolean | null
    label?: StringNullableFilter<"workflow"> | string | null
    order?: IntNullableFilter<"workflow"> | number | null
    type?: StringNullableFilter<"workflow"> | string | null
    est_gen_time?: JsonNullableFilter<"workflow">
    machine_type?: StringNullableFilter<"workflow"> | string | null
    min_vram?: IntNullableFilter<"workflow"> | number | null
    server?: XOR<ServerNullableRelationFilter, serverWhereInput> | null
    workflow_custom_nodes?: Workflow_custom_nodesListRelationFilter
    workflow_models?: WorkflowModelListRelationFilter
  }

  export type workflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    server_id?: SortOrderInput | SortOrder
    output_mime_type?: SortOrderInput | SortOrder
    display?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    est_gen_time?: SortOrderInput | SortOrder
    machine_type?: SortOrderInput | SortOrder
    min_vram?: SortOrderInput | SortOrder
    server?: serverOrderByWithRelationInput
    workflow_custom_nodes?: workflow_custom_nodesOrderByRelationAggregateInput
    workflow_models?: WorkflowModelOrderByRelationAggregateInput
  }

  export type workflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: workflowWhereInput | workflowWhereInput[]
    OR?: workflowWhereInput[]
    NOT?: workflowWhereInput | workflowWhereInput[]
    description?: StringNullableFilter<"workflow"> | string | null
    data?: JsonNullableFilter<"workflow">
    created_at?: DateTimeFilter<"workflow"> | Date | string
    server_id?: UuidNullableFilter<"workflow"> | string | null
    output_mime_type?: StringNullableFilter<"workflow"> | string | null
    display?: BoolNullableFilter<"workflow"> | boolean | null
    label?: StringNullableFilter<"workflow"> | string | null
    order?: IntNullableFilter<"workflow"> | number | null
    type?: StringNullableFilter<"workflow"> | string | null
    est_gen_time?: JsonNullableFilter<"workflow">
    machine_type?: StringNullableFilter<"workflow"> | string | null
    min_vram?: IntNullableFilter<"workflow"> | number | null
    server?: XOR<ServerNullableRelationFilter, serverWhereInput> | null
    workflow_custom_nodes?: Workflow_custom_nodesListRelationFilter
    workflow_models?: WorkflowModelListRelationFilter
  }, "id" | "name">

  export type workflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    server_id?: SortOrderInput | SortOrder
    output_mime_type?: SortOrderInput | SortOrder
    display?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    est_gen_time?: SortOrderInput | SortOrder
    machine_type?: SortOrderInput | SortOrder
    min_vram?: SortOrderInput | SortOrder
    _count?: workflowCountOrderByAggregateInput
    _avg?: workflowAvgOrderByAggregateInput
    _max?: workflowMaxOrderByAggregateInput
    _min?: workflowMinOrderByAggregateInput
    _sum?: workflowSumOrderByAggregateInput
  }

  export type workflowScalarWhereWithAggregatesInput = {
    AND?: workflowScalarWhereWithAggregatesInput | workflowScalarWhereWithAggregatesInput[]
    OR?: workflowScalarWhereWithAggregatesInput[]
    NOT?: workflowScalarWhereWithAggregatesInput | workflowScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"workflow"> | string
    name?: StringWithAggregatesFilter<"workflow"> | string
    description?: StringNullableWithAggregatesFilter<"workflow"> | string | null
    data?: JsonNullableWithAggregatesFilter<"workflow">
    created_at?: DateTimeWithAggregatesFilter<"workflow"> | Date | string
    server_id?: UuidNullableWithAggregatesFilter<"workflow"> | string | null
    output_mime_type?: StringNullableWithAggregatesFilter<"workflow"> | string | null
    display?: BoolNullableWithAggregatesFilter<"workflow"> | boolean | null
    label?: StringNullableWithAggregatesFilter<"workflow"> | string | null
    order?: IntNullableWithAggregatesFilter<"workflow"> | number | null
    type?: StringNullableWithAggregatesFilter<"workflow"> | string | null
    est_gen_time?: JsonNullableWithAggregatesFilter<"workflow">
    machine_type?: StringNullableWithAggregatesFilter<"workflow"> | string | null
    min_vram?: IntNullableWithAggregatesFilter<"workflow"> | number | null
  }

  export type serverWhereInput = {
    AND?: serverWhereInput | serverWhereInput[]
    OR?: serverWhereInput[]
    NOT?: serverWhereInput | serverWhereInput[]
    id?: UuidFilter<"server"> | string
    name?: StringFilter<"server"> | string
    url?: StringFilter<"server"> | string
    created_at?: DateTimeFilter<"server"> | Date | string
    updated_at?: DateTimeFilter<"server"> | Date | string
    workflow?: WorkflowListRelationFilter
  }

  export type serverOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    workflow?: workflowOrderByRelationAggregateInput
  }

  export type serverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: serverWhereInput | serverWhereInput[]
    OR?: serverWhereInput[]
    NOT?: serverWhereInput | serverWhereInput[]
    url?: StringFilter<"server"> | string
    created_at?: DateTimeFilter<"server"> | Date | string
    updated_at?: DateTimeFilter<"server"> | Date | string
    workflow?: WorkflowListRelationFilter
  }, "id" | "name">

  export type serverOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: serverCountOrderByAggregateInput
    _max?: serverMaxOrderByAggregateInput
    _min?: serverMinOrderByAggregateInput
  }

  export type serverScalarWhereWithAggregatesInput = {
    AND?: serverScalarWhereWithAggregatesInput | serverScalarWhereWithAggregatesInput[]
    OR?: serverScalarWhereWithAggregatesInput[]
    NOT?: serverScalarWhereWithAggregatesInput | serverScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"server"> | string
    name?: StringWithAggregatesFilter<"server"> | string
    url?: StringWithAggregatesFilter<"server"> | string
    created_at?: DateTimeWithAggregatesFilter<"server"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"server"> | Date | string
  }

  export type form_configWhereInput = {
    AND?: form_configWhereInput | form_configWhereInput[]
    OR?: form_configWhereInput[]
    NOT?: form_configWhereInput | form_configWhereInput[]
    id?: UuidFilter<"form_config"> | string
    name?: StringFilter<"form_config"> | string
    data?: JsonFilter<"form_config">
    created_at?: DateTimeFilter<"form_config"> | Date | string
    updated_at?: DateTimeFilter<"form_config"> | Date | string
  }

  export type form_configOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type form_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: form_configWhereInput | form_configWhereInput[]
    OR?: form_configWhereInput[]
    NOT?: form_configWhereInput | form_configWhereInput[]
    data?: JsonFilter<"form_config">
    created_at?: DateTimeFilter<"form_config"> | Date | string
    updated_at?: DateTimeFilter<"form_config"> | Date | string
  }, "id" | "name">

  export type form_configOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: form_configCountOrderByAggregateInput
    _max?: form_configMaxOrderByAggregateInput
    _min?: form_configMinOrderByAggregateInput
  }

  export type form_configScalarWhereWithAggregatesInput = {
    AND?: form_configScalarWhereWithAggregatesInput | form_configScalarWhereWithAggregatesInput[]
    OR?: form_configScalarWhereWithAggregatesInput[]
    NOT?: form_configScalarWhereWithAggregatesInput | form_configScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"form_config"> | string
    name?: StringWithAggregatesFilter<"form_config"> | string
    data?: JsonWithAggregatesFilter<"form_config">
    created_at?: DateTimeWithAggregatesFilter<"form_config"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"form_config"> | Date | string
  }

  export type api_keyWhereInput = {
    AND?: api_keyWhereInput | api_keyWhereInput[]
    OR?: api_keyWhereInput[]
    NOT?: api_keyWhereInput | api_keyWhereInput[]
    id?: UuidFilter<"api_key"> | string
    alias?: StringFilter<"api_key"> | string
    key?: StringFilter<"api_key"> | string
    workflow_name?: StringFilter<"api_key"> | string
    user_id?: UuidFilter<"api_key"> | string
    created_at?: DateTimeFilter<"api_key"> | Date | string
  }

  export type api_keyOrderByWithRelationInput = {
    id?: SortOrder
    alias?: SortOrder
    key?: SortOrder
    workflow_name?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type api_keyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    alias?: string
    key?: string
    AND?: api_keyWhereInput | api_keyWhereInput[]
    OR?: api_keyWhereInput[]
    NOT?: api_keyWhereInput | api_keyWhereInput[]
    workflow_name?: StringFilter<"api_key"> | string
    user_id?: UuidFilter<"api_key"> | string
    created_at?: DateTimeFilter<"api_key"> | Date | string
  }, "id" | "alias" | "key">

  export type api_keyOrderByWithAggregationInput = {
    id?: SortOrder
    alias?: SortOrder
    key?: SortOrder
    workflow_name?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    _count?: api_keyCountOrderByAggregateInput
    _max?: api_keyMaxOrderByAggregateInput
    _min?: api_keyMinOrderByAggregateInput
  }

  export type api_keyScalarWhereWithAggregatesInput = {
    AND?: api_keyScalarWhereWithAggregatesInput | api_keyScalarWhereWithAggregatesInput[]
    OR?: api_keyScalarWhereWithAggregatesInput[]
    NOT?: api_keyScalarWhereWithAggregatesInput | api_keyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"api_key"> | string
    alias?: StringWithAggregatesFilter<"api_key"> | string
    key?: StringWithAggregatesFilter<"api_key"> | string
    workflow_name?: StringWithAggregatesFilter<"api_key"> | string
    user_id?: UuidWithAggregatesFilter<"api_key"> | string
    created_at?: DateTimeWithAggregatesFilter<"api_key"> | Date | string
  }

  export type user_api_keysWhereInput = {
    AND?: user_api_keysWhereInput | user_api_keysWhereInput[]
    OR?: user_api_keysWhereInput[]
    NOT?: user_api_keysWhereInput | user_api_keysWhereInput[]
    id?: UuidFilter<"user_api_keys"> | string
    user_id?: UuidFilter<"user_api_keys"> | string
    key_hash?: StringFilter<"user_api_keys"> | string
    name?: StringNullableFilter<"user_api_keys"> | string | null
    expires_at?: DateTimeNullableFilter<"user_api_keys"> | Date | string | null
    created_at?: DateTimeFilter<"user_api_keys"> | Date | string
    is_active?: BoolFilter<"user_api_keys"> | boolean
  }

  export type user_api_keysOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    key_hash?: SortOrder
    name?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type user_api_keysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key_hash?: string
    AND?: user_api_keysWhereInput | user_api_keysWhereInput[]
    OR?: user_api_keysWhereInput[]
    NOT?: user_api_keysWhereInput | user_api_keysWhereInput[]
    user_id?: UuidFilter<"user_api_keys"> | string
    name?: StringNullableFilter<"user_api_keys"> | string | null
    expires_at?: DateTimeNullableFilter<"user_api_keys"> | Date | string | null
    created_at?: DateTimeFilter<"user_api_keys"> | Date | string
    is_active?: BoolFilter<"user_api_keys"> | boolean
  }, "id" | "key_hash">

  export type user_api_keysOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    key_hash?: SortOrder
    name?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
    _count?: user_api_keysCountOrderByAggregateInput
    _max?: user_api_keysMaxOrderByAggregateInput
    _min?: user_api_keysMinOrderByAggregateInput
  }

  export type user_api_keysScalarWhereWithAggregatesInput = {
    AND?: user_api_keysScalarWhereWithAggregatesInput | user_api_keysScalarWhereWithAggregatesInput[]
    OR?: user_api_keysScalarWhereWithAggregatesInput[]
    NOT?: user_api_keysScalarWhereWithAggregatesInput | user_api_keysScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user_api_keys"> | string
    user_id?: UuidWithAggregatesFilter<"user_api_keys"> | string
    key_hash?: StringWithAggregatesFilter<"user_api_keys"> | string
    name?: StringNullableWithAggregatesFilter<"user_api_keys"> | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"user_api_keys"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"user_api_keys"> | Date | string
    is_active?: BoolWithAggregatesFilter<"user_api_keys"> | boolean
  }

  export type jobWhereInput = {
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    id?: UuidFilter<"job"> | string
    name?: StringFilter<"job"> | string
    description?: StringNullableFilter<"job"> | string | null
    status?: StringFilter<"job"> | string
    data?: JsonNullableFilter<"job">
    progress?: IntNullableFilter<"job"> | number | null
    error_message?: StringNullableFilter<"job"> | string | null
    created_at?: DateTimeFilter<"job"> | Date | string
    updated_at?: DateTimeFilter<"job"> | Date | string
    started_at?: DateTimeNullableFilter<"job"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"job"> | Date | string | null
    user_id?: UuidFilter<"job"> | string
    job_type?: StringFilter<"job"> | string
    priority?: IntFilter<"job"> | number
    job_history?: Job_historyListRelationFilter
  }

  export type jobOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    job_type?: SortOrder
    priority?: SortOrder
    job_history?: job_historyOrderByRelationAggregateInput
  }

  export type jobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    name?: StringFilter<"job"> | string
    description?: StringNullableFilter<"job"> | string | null
    status?: StringFilter<"job"> | string
    data?: JsonNullableFilter<"job">
    progress?: IntNullableFilter<"job"> | number | null
    error_message?: StringNullableFilter<"job"> | string | null
    created_at?: DateTimeFilter<"job"> | Date | string
    updated_at?: DateTimeFilter<"job"> | Date | string
    started_at?: DateTimeNullableFilter<"job"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"job"> | Date | string | null
    user_id?: UuidFilter<"job"> | string
    job_type?: StringFilter<"job"> | string
    priority?: IntFilter<"job"> | number
    job_history?: Job_historyListRelationFilter
  }, "id">

  export type jobOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    job_type?: SortOrder
    priority?: SortOrder
    _count?: jobCountOrderByAggregateInput
    _avg?: jobAvgOrderByAggregateInput
    _max?: jobMaxOrderByAggregateInput
    _min?: jobMinOrderByAggregateInput
    _sum?: jobSumOrderByAggregateInput
  }

  export type jobScalarWhereWithAggregatesInput = {
    AND?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    OR?: jobScalarWhereWithAggregatesInput[]
    NOT?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"job"> | string
    name?: StringWithAggregatesFilter<"job"> | string
    description?: StringNullableWithAggregatesFilter<"job"> | string | null
    status?: StringWithAggregatesFilter<"job"> | string
    data?: JsonNullableWithAggregatesFilter<"job">
    progress?: IntNullableWithAggregatesFilter<"job"> | number | null
    error_message?: StringNullableWithAggregatesFilter<"job"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"job"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job"> | Date | string
    started_at?: DateTimeNullableWithAggregatesFilter<"job"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"job"> | Date | string | null
    user_id?: UuidWithAggregatesFilter<"job"> | string
    job_type?: StringWithAggregatesFilter<"job"> | string
    priority?: IntWithAggregatesFilter<"job"> | number
  }

  export type job_historyWhereInput = {
    AND?: job_historyWhereInput | job_historyWhereInput[]
    OR?: job_historyWhereInput[]
    NOT?: job_historyWhereInput | job_historyWhereInput[]
    id?: UuidFilter<"job_history"> | string
    job_id?: UuidFilter<"job_history"> | string
    status?: StringFilter<"job_history"> | string
    data?: JsonNullableFilter<"job_history">
    created_at?: DateTimeFilter<"job_history"> | Date | string
    message?: StringNullableFilter<"job_history"> | string | null
    job?: XOR<JobRelationFilter, jobWhereInput>
  }

  export type job_historyOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    message?: SortOrderInput | SortOrder
    job?: jobOrderByWithRelationInput
  }

  export type job_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: job_historyWhereInput | job_historyWhereInput[]
    OR?: job_historyWhereInput[]
    NOT?: job_historyWhereInput | job_historyWhereInput[]
    job_id?: UuidFilter<"job_history"> | string
    status?: StringFilter<"job_history"> | string
    data?: JsonNullableFilter<"job_history">
    created_at?: DateTimeFilter<"job_history"> | Date | string
    message?: StringNullableFilter<"job_history"> | string | null
    job?: XOR<JobRelationFilter, jobWhereInput>
  }, "id">

  export type job_historyOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    message?: SortOrderInput | SortOrder
    _count?: job_historyCountOrderByAggregateInput
    _max?: job_historyMaxOrderByAggregateInput
    _min?: job_historyMinOrderByAggregateInput
  }

  export type job_historyScalarWhereWithAggregatesInput = {
    AND?: job_historyScalarWhereWithAggregatesInput | job_historyScalarWhereWithAggregatesInput[]
    OR?: job_historyScalarWhereWithAggregatesInput[]
    NOT?: job_historyScalarWhereWithAggregatesInput | job_historyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"job_history"> | string
    job_id?: UuidWithAggregatesFilter<"job_history"> | string
    status?: StringWithAggregatesFilter<"job_history"> | string
    data?: JsonNullableWithAggregatesFilter<"job_history">
    created_at?: DateTimeWithAggregatesFilter<"job_history"> | Date | string
    message?: StringNullableWithAggregatesFilter<"job_history"> | string | null
  }

  export type miniapp_userWhereInput = {
    AND?: miniapp_userWhereInput | miniapp_userWhereInput[]
    OR?: miniapp_userWhereInput[]
    NOT?: miniapp_userWhereInput | miniapp_userWhereInput[]
    id?: UuidFilter<"miniapp_user"> | string
    farcaster_id?: StringFilter<"miniapp_user"> | string
    farcaster_username?: StringNullableFilter<"miniapp_user"> | string | null
    farcaster_pfp?: StringNullableFilter<"miniapp_user"> | string | null
    wallet_address?: StringNullableFilter<"miniapp_user"> | string | null
    created_at?: DateTimeFilter<"miniapp_user"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_user"> | Date | string
    notification_token?: StringNullableFilter<"miniapp_user"> | string | null
    miniapp_generation?: Miniapp_generationListRelationFilter
    miniapp_payment?: Miniapp_paymentListRelationFilter
    social_links?: Social_linkListRelationFilter
  }

  export type miniapp_userOrderByWithRelationInput = {
    id?: SortOrder
    farcaster_id?: SortOrder
    farcaster_username?: SortOrderInput | SortOrder
    farcaster_pfp?: SortOrderInput | SortOrder
    wallet_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    notification_token?: SortOrderInput | SortOrder
    miniapp_generation?: miniapp_generationOrderByRelationAggregateInput
    miniapp_payment?: miniapp_paymentOrderByRelationAggregateInput
    social_links?: social_linkOrderByRelationAggregateInput
  }

  export type miniapp_userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    farcaster_id?: string
    AND?: miniapp_userWhereInput | miniapp_userWhereInput[]
    OR?: miniapp_userWhereInput[]
    NOT?: miniapp_userWhereInput | miniapp_userWhereInput[]
    farcaster_username?: StringNullableFilter<"miniapp_user"> | string | null
    farcaster_pfp?: StringNullableFilter<"miniapp_user"> | string | null
    wallet_address?: StringNullableFilter<"miniapp_user"> | string | null
    created_at?: DateTimeFilter<"miniapp_user"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_user"> | Date | string
    notification_token?: StringNullableFilter<"miniapp_user"> | string | null
    miniapp_generation?: Miniapp_generationListRelationFilter
    miniapp_payment?: Miniapp_paymentListRelationFilter
    social_links?: Social_linkListRelationFilter
  }, "id" | "farcaster_id">

  export type miniapp_userOrderByWithAggregationInput = {
    id?: SortOrder
    farcaster_id?: SortOrder
    farcaster_username?: SortOrderInput | SortOrder
    farcaster_pfp?: SortOrderInput | SortOrder
    wallet_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    notification_token?: SortOrderInput | SortOrder
    _count?: miniapp_userCountOrderByAggregateInput
    _max?: miniapp_userMaxOrderByAggregateInput
    _min?: miniapp_userMinOrderByAggregateInput
  }

  export type miniapp_userScalarWhereWithAggregatesInput = {
    AND?: miniapp_userScalarWhereWithAggregatesInput | miniapp_userScalarWhereWithAggregatesInput[]
    OR?: miniapp_userScalarWhereWithAggregatesInput[]
    NOT?: miniapp_userScalarWhereWithAggregatesInput | miniapp_userScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"miniapp_user"> | string
    farcaster_id?: StringWithAggregatesFilter<"miniapp_user"> | string
    farcaster_username?: StringNullableWithAggregatesFilter<"miniapp_user"> | string | null
    farcaster_pfp?: StringNullableWithAggregatesFilter<"miniapp_user"> | string | null
    wallet_address?: StringNullableWithAggregatesFilter<"miniapp_user"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"miniapp_user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"miniapp_user"> | Date | string
    notification_token?: StringNullableWithAggregatesFilter<"miniapp_user"> | string | null
  }

  export type miniapp_collection_configWhereInput = {
    AND?: miniapp_collection_configWhereInput | miniapp_collection_configWhereInput[]
    OR?: miniapp_collection_configWhereInput[]
    NOT?: miniapp_collection_configWhereInput | miniapp_collection_configWhereInput[]
    id?: UuidFilter<"miniapp_collection_config"> | string
    collection_id?: UuidFilter<"miniapp_collection_config"> | string
    price?: FloatFilter<"miniapp_collection_config"> | number
    generations_per_payment?: IntFilter<"miniapp_collection_config"> | number
    is_active?: BoolFilter<"miniapp_collection_config"> | boolean
    created_at?: DateTimeFilter<"miniapp_collection_config"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_collection_config"> | Date | string
    max_retries?: IntFilter<"miniapp_collection_config"> | number
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }

  export type miniapp_collection_configOrderByWithRelationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    price?: SortOrder
    generations_per_payment?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    max_retries?: SortOrder
    collection?: collectionOrderByWithRelationInput
  }

  export type miniapp_collection_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collection_id?: string
    AND?: miniapp_collection_configWhereInput | miniapp_collection_configWhereInput[]
    OR?: miniapp_collection_configWhereInput[]
    NOT?: miniapp_collection_configWhereInput | miniapp_collection_configWhereInput[]
    price?: FloatFilter<"miniapp_collection_config"> | number
    generations_per_payment?: IntFilter<"miniapp_collection_config"> | number
    is_active?: BoolFilter<"miniapp_collection_config"> | boolean
    created_at?: DateTimeFilter<"miniapp_collection_config"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_collection_config"> | Date | string
    max_retries?: IntFilter<"miniapp_collection_config"> | number
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
  }, "id" | "collection_id">

  export type miniapp_collection_configOrderByWithAggregationInput = {
    id?: SortOrder
    collection_id?: SortOrder
    price?: SortOrder
    generations_per_payment?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    max_retries?: SortOrder
    _count?: miniapp_collection_configCountOrderByAggregateInput
    _avg?: miniapp_collection_configAvgOrderByAggregateInput
    _max?: miniapp_collection_configMaxOrderByAggregateInput
    _min?: miniapp_collection_configMinOrderByAggregateInput
    _sum?: miniapp_collection_configSumOrderByAggregateInput
  }

  export type miniapp_collection_configScalarWhereWithAggregatesInput = {
    AND?: miniapp_collection_configScalarWhereWithAggregatesInput | miniapp_collection_configScalarWhereWithAggregatesInput[]
    OR?: miniapp_collection_configScalarWhereWithAggregatesInput[]
    NOT?: miniapp_collection_configScalarWhereWithAggregatesInput | miniapp_collection_configScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"miniapp_collection_config"> | string
    collection_id?: UuidWithAggregatesFilter<"miniapp_collection_config"> | string
    price?: FloatWithAggregatesFilter<"miniapp_collection_config"> | number
    generations_per_payment?: IntWithAggregatesFilter<"miniapp_collection_config"> | number
    is_active?: BoolWithAggregatesFilter<"miniapp_collection_config"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"miniapp_collection_config"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"miniapp_collection_config"> | Date | string
    max_retries?: IntWithAggregatesFilter<"miniapp_collection_config"> | number
  }

  export type miniapp_paymentWhereInput = {
    AND?: miniapp_paymentWhereInput | miniapp_paymentWhereInput[]
    OR?: miniapp_paymentWhereInput[]
    NOT?: miniapp_paymentWhereInput | miniapp_paymentWhereInput[]
    id?: UuidFilter<"miniapp_payment"> | string
    user_id?: UuidFilter<"miniapp_payment"> | string
    collection_id?: UuidFilter<"miniapp_payment"> | string
    amount?: FloatFilter<"miniapp_payment"> | number
    transaction_hash?: StringNullableFilter<"miniapp_payment"> | string | null
    payment_status?: StringFilter<"miniapp_payment"> | string
    generations_allowed?: IntFilter<"miniapp_payment"> | number
    generations_used?: IntFilter<"miniapp_payment"> | number
    created_at?: DateTimeFilter<"miniapp_payment"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_payment"> | Date | string
    miniapp_generation?: Miniapp_generationListRelationFilter
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    miniapp_user?: XOR<Miniapp_userRelationFilter, miniapp_userWhereInput>
  }

  export type miniapp_paymentOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    amount?: SortOrder
    transaction_hash?: SortOrderInput | SortOrder
    payment_status?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    miniapp_generation?: miniapp_generationOrderByRelationAggregateInput
    collection?: collectionOrderByWithRelationInput
    miniapp_user?: miniapp_userOrderByWithRelationInput
  }

  export type miniapp_paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transaction_hash?: string
    AND?: miniapp_paymentWhereInput | miniapp_paymentWhereInput[]
    OR?: miniapp_paymentWhereInput[]
    NOT?: miniapp_paymentWhereInput | miniapp_paymentWhereInput[]
    user_id?: UuidFilter<"miniapp_payment"> | string
    collection_id?: UuidFilter<"miniapp_payment"> | string
    amount?: FloatFilter<"miniapp_payment"> | number
    payment_status?: StringFilter<"miniapp_payment"> | string
    generations_allowed?: IntFilter<"miniapp_payment"> | number
    generations_used?: IntFilter<"miniapp_payment"> | number
    created_at?: DateTimeFilter<"miniapp_payment"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_payment"> | Date | string
    miniapp_generation?: Miniapp_generationListRelationFilter
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    miniapp_user?: XOR<Miniapp_userRelationFilter, miniapp_userWhereInput>
  }, "id" | "transaction_hash">

  export type miniapp_paymentOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    amount?: SortOrder
    transaction_hash?: SortOrderInput | SortOrder
    payment_status?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: miniapp_paymentCountOrderByAggregateInput
    _avg?: miniapp_paymentAvgOrderByAggregateInput
    _max?: miniapp_paymentMaxOrderByAggregateInput
    _min?: miniapp_paymentMinOrderByAggregateInput
    _sum?: miniapp_paymentSumOrderByAggregateInput
  }

  export type miniapp_paymentScalarWhereWithAggregatesInput = {
    AND?: miniapp_paymentScalarWhereWithAggregatesInput | miniapp_paymentScalarWhereWithAggregatesInput[]
    OR?: miniapp_paymentScalarWhereWithAggregatesInput[]
    NOT?: miniapp_paymentScalarWhereWithAggregatesInput | miniapp_paymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"miniapp_payment"> | string
    user_id?: UuidWithAggregatesFilter<"miniapp_payment"> | string
    collection_id?: UuidWithAggregatesFilter<"miniapp_payment"> | string
    amount?: FloatWithAggregatesFilter<"miniapp_payment"> | number
    transaction_hash?: StringNullableWithAggregatesFilter<"miniapp_payment"> | string | null
    payment_status?: StringWithAggregatesFilter<"miniapp_payment"> | string
    generations_allowed?: IntWithAggregatesFilter<"miniapp_payment"> | number
    generations_used?: IntWithAggregatesFilter<"miniapp_payment"> | number
    created_at?: DateTimeWithAggregatesFilter<"miniapp_payment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"miniapp_payment"> | Date | string
  }

  export type miniapp_generationWhereInput = {
    AND?: miniapp_generationWhereInput | miniapp_generationWhereInput[]
    OR?: miniapp_generationWhereInput[]
    NOT?: miniapp_generationWhereInput | miniapp_generationWhereInput[]
    id?: UuidFilter<"miniapp_generation"> | string
    user_id?: UuidFilter<"miniapp_generation"> | string
    collection_id?: UuidFilter<"miniapp_generation"> | string
    payment_id?: UuidNullableFilter<"miniapp_generation"> | string | null
    input_data?: JsonNullableFilter<"miniapp_generation">
    output_url?: StringNullableFilter<"miniapp_generation"> | string | null
    output_data?: JsonNullableFilter<"miniapp_generation">
    error_message?: StringNullableFilter<"miniapp_generation"> | string | null
    created_at?: DateTimeFilter<"miniapp_generation"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_generation"> | Date | string
    job_id?: StringNullableFilter<"miniapp_generation"> | string | null
    generated_image?: StringNullableFilter<"miniapp_generation"> | string | null
    status?: EnumGenerationStatusFilter<"miniapp_generation"> | $Enums.GenerationStatus
    retry_count?: IntFilter<"miniapp_generation"> | number
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    miniapp_payment?: XOR<Miniapp_paymentNullableRelationFilter, miniapp_paymentWhereInput> | null
    miniapp_user?: XOR<Miniapp_userRelationFilter, miniapp_userWhereInput>
  }

  export type miniapp_generationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    payment_id?: SortOrderInput | SortOrder
    input_data?: SortOrderInput | SortOrder
    output_url?: SortOrderInput | SortOrder
    output_data?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_id?: SortOrderInput | SortOrder
    generated_image?: SortOrderInput | SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    collection?: collectionOrderByWithRelationInput
    miniapp_payment?: miniapp_paymentOrderByWithRelationInput
    miniapp_user?: miniapp_userOrderByWithRelationInput
  }

  export type miniapp_generationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: miniapp_generationWhereInput | miniapp_generationWhereInput[]
    OR?: miniapp_generationWhereInput[]
    NOT?: miniapp_generationWhereInput | miniapp_generationWhereInput[]
    user_id?: UuidFilter<"miniapp_generation"> | string
    collection_id?: UuidFilter<"miniapp_generation"> | string
    payment_id?: UuidNullableFilter<"miniapp_generation"> | string | null
    input_data?: JsonNullableFilter<"miniapp_generation">
    output_url?: StringNullableFilter<"miniapp_generation"> | string | null
    output_data?: JsonNullableFilter<"miniapp_generation">
    error_message?: StringNullableFilter<"miniapp_generation"> | string | null
    created_at?: DateTimeFilter<"miniapp_generation"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_generation"> | Date | string
    job_id?: StringNullableFilter<"miniapp_generation"> | string | null
    generated_image?: StringNullableFilter<"miniapp_generation"> | string | null
    status?: EnumGenerationStatusFilter<"miniapp_generation"> | $Enums.GenerationStatus
    retry_count?: IntFilter<"miniapp_generation"> | number
    collection?: XOR<CollectionRelationFilter, collectionWhereInput>
    miniapp_payment?: XOR<Miniapp_paymentNullableRelationFilter, miniapp_paymentWhereInput> | null
    miniapp_user?: XOR<Miniapp_userRelationFilter, miniapp_userWhereInput>
  }, "id">

  export type miniapp_generationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    payment_id?: SortOrderInput | SortOrder
    input_data?: SortOrderInput | SortOrder
    output_url?: SortOrderInput | SortOrder
    output_data?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_id?: SortOrderInput | SortOrder
    generated_image?: SortOrderInput | SortOrder
    status?: SortOrder
    retry_count?: SortOrder
    _count?: miniapp_generationCountOrderByAggregateInput
    _avg?: miniapp_generationAvgOrderByAggregateInput
    _max?: miniapp_generationMaxOrderByAggregateInput
    _min?: miniapp_generationMinOrderByAggregateInput
    _sum?: miniapp_generationSumOrderByAggregateInput
  }

  export type miniapp_generationScalarWhereWithAggregatesInput = {
    AND?: miniapp_generationScalarWhereWithAggregatesInput | miniapp_generationScalarWhereWithAggregatesInput[]
    OR?: miniapp_generationScalarWhereWithAggregatesInput[]
    NOT?: miniapp_generationScalarWhereWithAggregatesInput | miniapp_generationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"miniapp_generation"> | string
    user_id?: UuidWithAggregatesFilter<"miniapp_generation"> | string
    collection_id?: UuidWithAggregatesFilter<"miniapp_generation"> | string
    payment_id?: UuidNullableWithAggregatesFilter<"miniapp_generation"> | string | null
    input_data?: JsonNullableWithAggregatesFilter<"miniapp_generation">
    output_url?: StringNullableWithAggregatesFilter<"miniapp_generation"> | string | null
    output_data?: JsonNullableWithAggregatesFilter<"miniapp_generation">
    error_message?: StringNullableWithAggregatesFilter<"miniapp_generation"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"miniapp_generation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"miniapp_generation"> | Date | string
    job_id?: StringNullableWithAggregatesFilter<"miniapp_generation"> | string | null
    generated_image?: StringNullableWithAggregatesFilter<"miniapp_generation"> | string | null
    status?: EnumGenerationStatusWithAggregatesFilter<"miniapp_generation"> | $Enums.GenerationStatus
    retry_count?: IntWithAggregatesFilter<"miniapp_generation"> | number
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: StringFilter<"Model"> | string
    name?: StringFilter<"Model"> | string
    downloadUrl?: StringFilter<"Model"> | string
    saveTo?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    fileSize?: StringNullableFilter<"Model"> | string | null
    hash?: StringNullableFilter<"Model"> | string | null
    status?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    authEnvVar?: StringNullableFilter<"Model"> | string | null
    isAuthReq?: BoolFilter<"Model"> | boolean
    workflowModels?: WorkflowModelListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    downloadUrl?: SortOrder
    saveTo?: SortOrder
    description?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authEnvVar?: SortOrderInput | SortOrder
    isAuthReq?: SortOrder
    workflowModels?: WorkflowModelOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    downloadUrl?: StringFilter<"Model"> | string
    saveTo?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    fileSize?: StringNullableFilter<"Model"> | string | null
    hash?: StringNullableFilter<"Model"> | string | null
    status?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    authEnvVar?: StringNullableFilter<"Model"> | string | null
    isAuthReq?: BoolFilter<"Model"> | boolean
    workflowModels?: WorkflowModelListRelationFilter
  }, "id" | "name">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    downloadUrl?: SortOrder
    saveTo?: SortOrder
    description?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authEnvVar?: SortOrderInput | SortOrder
    isAuthReq?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Model"> | string
    name?: StringWithAggregatesFilter<"Model"> | string
    downloadUrl?: StringWithAggregatesFilter<"Model"> | string
    saveTo?: StringWithAggregatesFilter<"Model"> | string
    description?: StringNullableWithAggregatesFilter<"Model"> | string | null
    fileSize?: StringNullableWithAggregatesFilter<"Model"> | string | null
    hash?: StringNullableWithAggregatesFilter<"Model"> | string | null
    status?: StringWithAggregatesFilter<"Model"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    authEnvVar?: StringNullableWithAggregatesFilter<"Model"> | string | null
    isAuthReq?: BoolWithAggregatesFilter<"Model"> | boolean
  }

  export type WorkflowModelWhereInput = {
    AND?: WorkflowModelWhereInput | WorkflowModelWhereInput[]
    OR?: WorkflowModelWhereInput[]
    NOT?: WorkflowModelWhereInput | WorkflowModelWhereInput[]
    id?: StringFilter<"WorkflowModel"> | string
    workflowId?: UuidFilter<"WorkflowModel"> | string
    modelId?: StringFilter<"WorkflowModel"> | string
    isRequired?: BoolFilter<"WorkflowModel"> | boolean
    createdAt?: DateTimeFilter<"WorkflowModel"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    workflow?: XOR<WorkflowRelationFilter, workflowWhereInput>
  }

  export type WorkflowModelOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    modelId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    workflow?: workflowOrderByWithRelationInput
  }

  export type WorkflowModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workflowId_modelId?: WorkflowModelWorkflowIdModelIdCompoundUniqueInput
    AND?: WorkflowModelWhereInput | WorkflowModelWhereInput[]
    OR?: WorkflowModelWhereInput[]
    NOT?: WorkflowModelWhereInput | WorkflowModelWhereInput[]
    workflowId?: UuidFilter<"WorkflowModel"> | string
    modelId?: StringFilter<"WorkflowModel"> | string
    isRequired?: BoolFilter<"WorkflowModel"> | boolean
    createdAt?: DateTimeFilter<"WorkflowModel"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    workflow?: XOR<WorkflowRelationFilter, workflowWhereInput>
  }, "id" | "workflowId_modelId">

  export type WorkflowModelOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    modelId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    _count?: WorkflowModelCountOrderByAggregateInput
    _max?: WorkflowModelMaxOrderByAggregateInput
    _min?: WorkflowModelMinOrderByAggregateInput
  }

  export type WorkflowModelScalarWhereWithAggregatesInput = {
    AND?: WorkflowModelScalarWhereWithAggregatesInput | WorkflowModelScalarWhereWithAggregatesInput[]
    OR?: WorkflowModelScalarWhereWithAggregatesInput[]
    NOT?: WorkflowModelScalarWhereWithAggregatesInput | WorkflowModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowModel"> | string
    workflowId?: UuidWithAggregatesFilter<"WorkflowModel"> | string
    modelId?: StringWithAggregatesFilter<"WorkflowModel"> | string
    isRequired?: BoolWithAggregatesFilter<"WorkflowModel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowModel"> | Date | string
  }

  export type component_flat_file_recoverWhereInput = {
    AND?: component_flat_file_recoverWhereInput | component_flat_file_recoverWhereInput[]
    OR?: component_flat_file_recoverWhereInput[]
    NOT?: component_flat_file_recoverWhereInput | component_flat_file_recoverWhereInput[]
    id?: BigIntFilter<"component_flat_file_recover"> | bigint | number
    component_id?: BigIntFilter<"component_flat_file_recover"> | bigint | number
    flat_file_id?: BigIntFilter<"component_flat_file_recover"> | bigint | number
    recovered_at?: DateTimeFilter<"component_flat_file_recover"> | Date | string
    issue_type?: StringFilter<"component_flat_file_recover"> | string
  }

  export type component_flat_file_recoverOrderByWithRelationInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    recovered_at?: SortOrder
    issue_type?: SortOrder
  }

  export type component_flat_file_recoverWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: component_flat_file_recoverWhereInput | component_flat_file_recoverWhereInput[]
    OR?: component_flat_file_recoverWhereInput[]
    NOT?: component_flat_file_recoverWhereInput | component_flat_file_recoverWhereInput[]
    component_id?: BigIntFilter<"component_flat_file_recover"> | bigint | number
    flat_file_id?: BigIntFilter<"component_flat_file_recover"> | bigint | number
    recovered_at?: DateTimeFilter<"component_flat_file_recover"> | Date | string
    issue_type?: StringFilter<"component_flat_file_recover"> | string
  }, "id">

  export type component_flat_file_recoverOrderByWithAggregationInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    recovered_at?: SortOrder
    issue_type?: SortOrder
    _count?: component_flat_file_recoverCountOrderByAggregateInput
    _avg?: component_flat_file_recoverAvgOrderByAggregateInput
    _max?: component_flat_file_recoverMaxOrderByAggregateInput
    _min?: component_flat_file_recoverMinOrderByAggregateInput
    _sum?: component_flat_file_recoverSumOrderByAggregateInput
  }

  export type component_flat_file_recoverScalarWhereWithAggregatesInput = {
    AND?: component_flat_file_recoverScalarWhereWithAggregatesInput | component_flat_file_recoverScalarWhereWithAggregatesInput[]
    OR?: component_flat_file_recoverScalarWhereWithAggregatesInput[]
    NOT?: component_flat_file_recoverScalarWhereWithAggregatesInput | component_flat_file_recoverScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"component_flat_file_recover"> | bigint | number
    component_id?: BigIntWithAggregatesFilter<"component_flat_file_recover"> | bigint | number
    flat_file_id?: BigIntWithAggregatesFilter<"component_flat_file_recover"> | bigint | number
    recovered_at?: DateTimeWithAggregatesFilter<"component_flat_file_recover"> | Date | string
    issue_type?: StringWithAggregatesFilter<"component_flat_file_recover"> | string
  }

  export type social_linkWhereInput = {
    AND?: social_linkWhereInput | social_linkWhereInput[]
    OR?: social_linkWhereInput[]
    NOT?: social_linkWhereInput | social_linkWhereInput[]
    id?: UuidFilter<"social_link"> | string
    social_org?: Enumsocial_org_enumFilter<"social_link"> | $Enums.social_org_enum
    identifier?: StringFilter<"social_link"> | string
    created_at?: DateTimeFilter<"social_link"> | Date | string
    updated_at?: DateTimeFilter<"social_link"> | Date | string
    miniapp_user_id?: UuidNullableFilter<"social_link"> | string | null
    custodial_collections?: CollectionListRelationFilter
    miniapp_user?: XOR<Miniapp_userNullableRelationFilter, miniapp_userWhereInput> | null
  }

  export type social_linkOrderByWithRelationInput = {
    id?: SortOrder
    social_org?: SortOrder
    identifier?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    miniapp_user_id?: SortOrderInput | SortOrder
    custodial_collections?: collectionOrderByRelationAggregateInput
    miniapp_user?: miniapp_userOrderByWithRelationInput
  }

  export type social_linkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    social_org_identifier?: social_linkSocial_orgIdentifierCompoundUniqueInput
    AND?: social_linkWhereInput | social_linkWhereInput[]
    OR?: social_linkWhereInput[]
    NOT?: social_linkWhereInput | social_linkWhereInput[]
    social_org?: Enumsocial_org_enumFilter<"social_link"> | $Enums.social_org_enum
    identifier?: StringFilter<"social_link"> | string
    created_at?: DateTimeFilter<"social_link"> | Date | string
    updated_at?: DateTimeFilter<"social_link"> | Date | string
    miniapp_user_id?: UuidNullableFilter<"social_link"> | string | null
    custodial_collections?: CollectionListRelationFilter
    miniapp_user?: XOR<Miniapp_userNullableRelationFilter, miniapp_userWhereInput> | null
  }, "id" | "social_org_identifier">

  export type social_linkOrderByWithAggregationInput = {
    id?: SortOrder
    social_org?: SortOrder
    identifier?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    miniapp_user_id?: SortOrderInput | SortOrder
    _count?: social_linkCountOrderByAggregateInput
    _max?: social_linkMaxOrderByAggregateInput
    _min?: social_linkMinOrderByAggregateInput
  }

  export type social_linkScalarWhereWithAggregatesInput = {
    AND?: social_linkScalarWhereWithAggregatesInput | social_linkScalarWhereWithAggregatesInput[]
    OR?: social_linkScalarWhereWithAggregatesInput[]
    NOT?: social_linkScalarWhereWithAggregatesInput | social_linkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"social_link"> | string
    social_org?: Enumsocial_org_enumWithAggregatesFilter<"social_link"> | $Enums.social_org_enum
    identifier?: StringWithAggregatesFilter<"social_link"> | string
    created_at?: DateTimeWithAggregatesFilter<"social_link"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"social_link"> | Date | string
    miniapp_user_id?: UuidNullableWithAggregatesFilter<"social_link"> | string | null
  }

  export type custom_nodesWhereInput = {
    AND?: custom_nodesWhereInput | custom_nodesWhereInput[]
    OR?: custom_nodesWhereInput[]
    NOT?: custom_nodesWhereInput | custom_nodesWhereInput[]
    id?: UuidFilter<"custom_nodes"> | string
    name?: StringFilter<"custom_nodes"> | string
    download_url?: StringFilter<"custom_nodes"> | string
    description?: StringNullableFilter<"custom_nodes"> | string | null
    is_env_required?: BoolFilter<"custom_nodes"> | boolean
    env_conf?: JsonNullableFilter<"custom_nodes">
    hash?: StringNullableFilter<"custom_nodes"> | string | null
    created_at?: DateTimeFilter<"custom_nodes"> | Date | string
    updated_at?: DateTimeFilter<"custom_nodes"> | Date | string
    install_settings?: JsonNullableFilter<"custom_nodes">
    is_default?: BoolFilter<"custom_nodes"> | boolean
    install_order?: IntNullableFilter<"custom_nodes"> | number | null
    workflow_custom_nodes?: Workflow_custom_nodesListRelationFilter
  }

  export type custom_nodesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    download_url?: SortOrder
    description?: SortOrderInput | SortOrder
    is_env_required?: SortOrder
    env_conf?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    install_settings?: SortOrderInput | SortOrder
    is_default?: SortOrder
    install_order?: SortOrderInput | SortOrder
    workflow_custom_nodes?: workflow_custom_nodesOrderByRelationAggregateInput
  }

  export type custom_nodesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: custom_nodesWhereInput | custom_nodesWhereInput[]
    OR?: custom_nodesWhereInput[]
    NOT?: custom_nodesWhereInput | custom_nodesWhereInput[]
    name?: StringFilter<"custom_nodes"> | string
    download_url?: StringFilter<"custom_nodes"> | string
    description?: StringNullableFilter<"custom_nodes"> | string | null
    is_env_required?: BoolFilter<"custom_nodes"> | boolean
    env_conf?: JsonNullableFilter<"custom_nodes">
    hash?: StringNullableFilter<"custom_nodes"> | string | null
    created_at?: DateTimeFilter<"custom_nodes"> | Date | string
    updated_at?: DateTimeFilter<"custom_nodes"> | Date | string
    install_settings?: JsonNullableFilter<"custom_nodes">
    is_default?: BoolFilter<"custom_nodes"> | boolean
    install_order?: IntNullableFilter<"custom_nodes"> | number | null
    workflow_custom_nodes?: Workflow_custom_nodesListRelationFilter
  }, "id">

  export type custom_nodesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    download_url?: SortOrder
    description?: SortOrderInput | SortOrder
    is_env_required?: SortOrder
    env_conf?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    install_settings?: SortOrderInput | SortOrder
    is_default?: SortOrder
    install_order?: SortOrderInput | SortOrder
    _count?: custom_nodesCountOrderByAggregateInput
    _avg?: custom_nodesAvgOrderByAggregateInput
    _max?: custom_nodesMaxOrderByAggregateInput
    _min?: custom_nodesMinOrderByAggregateInput
    _sum?: custom_nodesSumOrderByAggregateInput
  }

  export type custom_nodesScalarWhereWithAggregatesInput = {
    AND?: custom_nodesScalarWhereWithAggregatesInput | custom_nodesScalarWhereWithAggregatesInput[]
    OR?: custom_nodesScalarWhereWithAggregatesInput[]
    NOT?: custom_nodesScalarWhereWithAggregatesInput | custom_nodesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"custom_nodes"> | string
    name?: StringWithAggregatesFilter<"custom_nodes"> | string
    download_url?: StringWithAggregatesFilter<"custom_nodes"> | string
    description?: StringNullableWithAggregatesFilter<"custom_nodes"> | string | null
    is_env_required?: BoolWithAggregatesFilter<"custom_nodes"> | boolean
    env_conf?: JsonNullableWithAggregatesFilter<"custom_nodes">
    hash?: StringNullableWithAggregatesFilter<"custom_nodes"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"custom_nodes"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"custom_nodes"> | Date | string
    install_settings?: JsonNullableWithAggregatesFilter<"custom_nodes">
    is_default?: BoolWithAggregatesFilter<"custom_nodes"> | boolean
    install_order?: IntNullableWithAggregatesFilter<"custom_nodes"> | number | null
  }

  export type workflow_custom_nodesWhereInput = {
    AND?: workflow_custom_nodesWhereInput | workflow_custom_nodesWhereInput[]
    OR?: workflow_custom_nodesWhereInput[]
    NOT?: workflow_custom_nodesWhereInput | workflow_custom_nodesWhereInput[]
    id?: BigIntFilter<"workflow_custom_nodes"> | bigint | number
    workflow_id?: UuidFilter<"workflow_custom_nodes"> | string
    custom_node_id?: UuidFilter<"workflow_custom_nodes"> | string
    created_at?: DateTimeFilter<"workflow_custom_nodes"> | Date | string
    custom_nodes?: XOR<Custom_nodesRelationFilter, custom_nodesWhereInput>
    workflow?: XOR<WorkflowRelationFilter, workflowWhereInput>
  }

  export type workflow_custom_nodesOrderByWithRelationInput = {
    id?: SortOrder
    workflow_id?: SortOrder
    custom_node_id?: SortOrder
    created_at?: SortOrder
    custom_nodes?: custom_nodesOrderByWithRelationInput
    workflow?: workflowOrderByWithRelationInput
  }

  export type workflow_custom_nodesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    workflow_id_custom_node_id?: workflow_custom_nodesWorkflow_idCustom_node_idCompoundUniqueInput
    AND?: workflow_custom_nodesWhereInput | workflow_custom_nodesWhereInput[]
    OR?: workflow_custom_nodesWhereInput[]
    NOT?: workflow_custom_nodesWhereInput | workflow_custom_nodesWhereInput[]
    workflow_id?: UuidFilter<"workflow_custom_nodes"> | string
    custom_node_id?: UuidFilter<"workflow_custom_nodes"> | string
    created_at?: DateTimeFilter<"workflow_custom_nodes"> | Date | string
    custom_nodes?: XOR<Custom_nodesRelationFilter, custom_nodesWhereInput>
    workflow?: XOR<WorkflowRelationFilter, workflowWhereInput>
  }, "id" | "workflow_id_custom_node_id">

  export type workflow_custom_nodesOrderByWithAggregationInput = {
    id?: SortOrder
    workflow_id?: SortOrder
    custom_node_id?: SortOrder
    created_at?: SortOrder
    _count?: workflow_custom_nodesCountOrderByAggregateInput
    _avg?: workflow_custom_nodesAvgOrderByAggregateInput
    _max?: workflow_custom_nodesMaxOrderByAggregateInput
    _min?: workflow_custom_nodesMinOrderByAggregateInput
    _sum?: workflow_custom_nodesSumOrderByAggregateInput
  }

  export type workflow_custom_nodesScalarWhereWithAggregatesInput = {
    AND?: workflow_custom_nodesScalarWhereWithAggregatesInput | workflow_custom_nodesScalarWhereWithAggregatesInput[]
    OR?: workflow_custom_nodesScalarWhereWithAggregatesInput[]
    NOT?: workflow_custom_nodesScalarWhereWithAggregatesInput | workflow_custom_nodesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"workflow_custom_nodes"> | bigint | number
    workflow_id?: UuidWithAggregatesFilter<"workflow_custom_nodes"> | string
    custom_node_id?: UuidWithAggregatesFilter<"workflow_custom_nodes"> | string
    created_at?: DateTimeWithAggregatesFilter<"workflow_custom_nodes"> | Date | string
  }

  export type assignmentCreateInput = {
    id?: bigint | number
    user_id?: string | null
    address?: string | null
    token_id?: string | null
    created_at?: Date | string
  }

  export type assignmentUncheckedCreateInput = {
    id?: bigint | number
    user_id?: string | null
    address?: string | null
    token_id?: string | null
    created_at?: Date | string
  }

  export type assignmentUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    token_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    token_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentCreateManyInput = {
    id?: bigint | number
    user_id?: string | null
    address?: string | null
    token_id?: string | null
    created_at?: Date | string
  }

  export type assignmentUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    token_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    token_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collectionCreateInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionCreateManyInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
  }

  export type collectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collection_remixCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    collection_preview_version?: collection_preview_versionCreateNestedOneWithoutCollection_remixInput
    source_collection: collectionCreateNestedOneWithoutSource_remixInput
    target_collection: collectionCreateNestedOneWithoutTarget_remixInput
  }

  export type collection_remixUncheckedCreateInput = {
    id?: bigint | number
    source_collection_id: string
    target_collection_id: string
    created_at?: Date | string | null
    collection_preview_version_id?: bigint | number | null
  }

  export type collection_remixUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version?: collection_preview_versionUpdateOneWithoutCollection_remixNestedInput
    source_collection?: collectionUpdateOneRequiredWithoutSource_remixNestedInput
    target_collection?: collectionUpdateOneRequiredWithoutTarget_remixNestedInput
  }

  export type collection_remixUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source_collection_id?: StringFieldUpdateOperationsInput | string
    target_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collection_remixCreateManyInput = {
    id?: bigint | number
    source_collection_id: string
    target_collection_id: string
    created_at?: Date | string | null
    collection_preview_version_id?: bigint | number | null
  }

  export type collection_remixUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_remixUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source_collection_id?: StringFieldUpdateOperationsInput | string
    target_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type eventCreateInput = {
    id?: string
    event_name: string
    property_name: string
    property_value?: string | null
    created_at?: Date | string
    user_id: string
    event_id: string
    event_type: string
  }

  export type eventUncheckedCreateInput = {
    id?: string
    event_name: string
    property_name: string
    property_value?: string | null
    created_at?: Date | string
    user_id: string
    event_id: string
    event_type: string
  }

  export type eventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    property_name?: StringFieldUpdateOperationsInput | string
    property_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
  }

  export type eventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    property_name?: StringFieldUpdateOperationsInput | string
    property_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
  }

  export type eventCreateManyInput = {
    id?: string
    event_name: string
    property_name: string
    property_value?: string | null
    created_at?: Date | string
    user_id: string
    event_id: string
    event_type: string
  }

  export type eventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    property_name?: StringFieldUpdateOperationsInput | string
    property_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
  }

  export type eventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    property_name?: StringFieldUpdateOperationsInput | string
    property_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
  }

  export type flat_fileCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
    chat_message?: chat_messageCreateNestedManyWithoutFlat_fileInput
    component_flat_files?: component_flat_fileCreateNestedManyWithoutFlat_fileInput
  }

  export type flat_fileUncheckedCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
    chat_message?: chat_messageUncheckedCreateNestedManyWithoutFlat_fileInput
    component_flat_files?: component_flat_fileUncheckedCreateNestedManyWithoutFlat_fileInput
  }

  export type flat_fileUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
    chat_message?: chat_messageUpdateManyWithoutFlat_fileNestedInput
    component_flat_files?: component_flat_fileUpdateManyWithoutFlat_fileNestedInput
  }

  export type flat_fileUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
    chat_message?: chat_messageUncheckedUpdateManyWithoutFlat_fileNestedInput
    component_flat_files?: component_flat_fileUncheckedUpdateManyWithoutFlat_fileNestedInput
  }

  export type flat_fileCreateManyInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
  }

  export type flat_fileUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
  }

  export type flat_fileUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
  }

  export type component_flat_fileCreateInput = {
    id?: bigint | number
    component: componentCreateNestedOneWithoutComponent_flat_filesInput
    flat_file: flat_fileCreateNestedOneWithoutComponent_flat_filesInput
  }

  export type component_flat_fileUncheckedCreateInput = {
    id?: bigint | number
    component_id: bigint | number
    flat_file_id: bigint | number
  }

  export type component_flat_fileUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component?: componentUpdateOneRequiredWithoutComponent_flat_filesNestedInput
    flat_file?: flat_fileUpdateOneRequiredWithoutComponent_flat_filesNestedInput
  }

  export type component_flat_fileUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type component_flat_fileCreateManyInput = {
    id?: bigint | number
    component_id: bigint | number
    flat_file_id: bigint | number
  }

  export type component_flat_fileUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type component_flat_fileUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type projectCreateInput = {
    id?: string
    created_at?: Date | string
    name: string
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: string | null
    version?: string | null
    archived?: boolean
    is_default?: boolean
    collection?: collectionCreateNestedManyWithoutProjectInput
  }

  export type projectUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    name: string
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: string | null
    version?: string | null
    archived?: boolean
    is_default?: boolean
    collection?: collectionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type projectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    collection?: collectionUpdateManyWithoutProjectNestedInput
  }

  export type projectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    collection?: collectionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type projectCreateManyInput = {
    id?: string
    created_at?: Date | string
    name: string
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: string | null
    version?: string | null
    archived?: boolean
    is_default?: boolean
  }

  export type projectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type project_historyCreateInput = {
    id?: string
    created_at?: Date | string
    data: JsonNullValueInput | InputJsonValue
    user_id: string
    project_id: string
    name?: string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type project_historyUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    data: JsonNullValueInput | InputJsonValue
    user_id: string
    project_id: string
    name?: string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type project_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user_id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type project_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user_id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type project_historyCreateManyInput = {
    id?: string
    created_at?: Date | string
    data: JsonNullValueInput | InputJsonValue
    user_id: string
    project_id: string
    name?: string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type project_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user_id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type project_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    user_id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    images?: NullableJsonNullValueInput | InputJsonValue
  }

  export type roleCreateInput = {
    id?: string
    user_id: string
    created_at?: Date | string
    name: string
  }

  export type roleUncheckedCreateInput = {
    id?: string
    user_id: string
    created_at?: Date | string
    name: string
  }

  export type roleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roleCreateManyInput = {
    id?: string
    user_id: string
    created_at?: Date | string
    name: string
  }

  export type roleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type roleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type walletCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    address: string
    user_id?: string | null
  }

  export type walletUncheckedCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    address: string
    user_id?: string | null
  }

  export type walletUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletCreateManyInput = {
    id?: bigint | number
    created_at?: Date | string | null
    address: string
    user_id?: string | null
  }

  export type walletUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credits_historyCreateInput = {
    flow: string
    amount: Decimal | DecimalJsLike | number | string
    credit_type: string
    created_at?: Date | string | null
    user_id: string
    comment?: string | null
  }

  export type credits_historyUncheckedCreateInput = {
    id?: number
    flow: string
    amount: Decimal | DecimalJsLike | number | string
    credit_type: string
    created_at?: Date | string | null
    user_id: string
    comment?: string | null
  }

  export type credits_historyUpdateInput = {
    flow?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credits_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    flow?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credits_historyCreateManyInput = {
    id?: number
    flow: string
    amount: Decimal | DecimalJsLike | number | string
    credit_type: string
    created_at?: Date | string | null
    user_id: string
    comment?: string | null
  }

  export type credits_historyUpdateManyMutationInput = {
    flow?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credits_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    flow?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credits_balanceCreateInput = {
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance: Decimal | DecimalJsLike | number | string
    credit_type: string
  }

  export type credits_balanceUncheckedCreateInput = {
    id?: number
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance: Decimal | DecimalJsLike | number | string
    credit_type: string
  }

  export type credits_balanceUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
  }

  export type credits_balanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
  }

  export type credits_balanceCreateManyInput = {
    id?: number
    user_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance: Decimal | DecimalJsLike | number | string
    credit_type: string
  }

  export type credits_balanceUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
  }

  export type credits_balanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit_type?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionCreateInput = {
    id?: string
    stripe_subscription_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: string | null
    status: string
    stripe_product_id: string
    subscription_key: string
    cancel_at_period_end: boolean
    current_period_end: Date | string
    current_period_start: Date | string
  }

  export type subscriptionUncheckedCreateInput = {
    id?: string
    stripe_subscription_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: string | null
    status: string
    stripe_product_id: string
    subscription_key: string
    cancel_at_period_end: boolean
    current_period_end: Date | string
    current_period_start: Date | string
  }

  export type subscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    subscription_key?: StringFieldUpdateOperationsInput | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    subscription_key?: StringFieldUpdateOperationsInput | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionCreateManyInput = {
    id?: string
    stripe_subscription_id: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: string | null
    status: string
    stripe_product_id: string
    subscription_key: string
    cancel_at_period_end: boolean
    current_period_end: Date | string
    current_period_start: Date | string
  }

  export type subscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    subscription_key?: StringFieldUpdateOperationsInput | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    subscription_key?: StringFieldUpdateOperationsInput | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerCreateInput = {
    id: string
    stripe_customer_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    prefinery_referral_code?: string | null
    has_migrated?: boolean
  }

  export type customerUncheckedCreateInput = {
    id: string
    stripe_customer_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    prefinery_referral_code?: string | null
    has_migrated?: boolean
  }

  export type customerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prefinery_referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    has_migrated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type customerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prefinery_referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    has_migrated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type customerCreateManyInput = {
    id: string
    stripe_customer_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    prefinery_referral_code?: string | null
    has_migrated?: boolean
  }

  export type customerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prefinery_referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    has_migrated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type customerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prefinery_referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    has_migrated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productCreateInput = {
    name: string
    type: string
    stripe_price_id: string
    stripe_product_id: string
    price: Decimal | DecimalJsLike | number | string
    credits_quantity?: number | null
    credits_type?: string | null
    active: boolean
    created_at?: Date | string | null
    updated_at: Date | string
    lookup_key: string
    rank?: number
    features?: string | null
  }

  export type productUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    stripe_price_id: string
    stripe_product_id: string
    price: Decimal | DecimalJsLike | number | string
    credits_quantity?: number | null
    credits_type?: string | null
    active: boolean
    created_at?: Date | string | null
    updated_at: Date | string
    lookup_key: string
    rank?: number
    features?: string | null
  }

  export type productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credits_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    credits_type?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lookup_key?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credits_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    credits_type?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lookup_key?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productCreateManyInput = {
    id?: number
    name: string
    type: string
    stripe_price_id: string
    stripe_product_id: string
    price: Decimal | DecimalJsLike | number | string
    credits_quantity?: number | null
    credits_type?: string | null
    active: boolean
    created_at?: Date | string | null
    updated_at: Date | string
    lookup_key: string
    rank?: number
    features?: string | null
  }

  export type productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credits_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    credits_type?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lookup_key?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stripe_price_id?: StringFieldUpdateOperationsInput | string
    stripe_product_id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credits_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    credits_type?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lookup_key?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_templateCreateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    current_project_history_id?: string | null
    project_template_save?: project_template_saveCreateNestedManyWithoutProject_templateInput
  }

  export type project_templateUncheckedCreateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    current_project_history_id?: string | null
    project_template_save?: project_template_saveUncheckedCreateNestedManyWithoutProject_templateInput
  }

  export type project_templateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_template_save?: project_template_saveUpdateManyWithoutProject_templateNestedInput
  }

  export type project_templateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_template_save?: project_template_saveUncheckedUpdateManyWithoutProject_templateNestedInput
  }

  export type project_templateCreateManyInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    current_project_history_id?: string | null
  }

  export type project_templateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_templateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_template_saveCreateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    project_history_id?: string | null
    project_template: project_templateCreateNestedOneWithoutProject_template_saveInput
  }

  export type project_template_saveUncheckedCreateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    project_template_id: bigint | number
    project_history_id?: string | null
  }

  export type project_template_saveUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_template?: project_templateUpdateOneRequiredWithoutProject_template_saveNestedInput
  }

  export type project_template_saveUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_template_saveCreateManyInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    project_template_id: bigint | number
    project_history_id?: string | null
  }

  export type project_template_saveUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_template_saveUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_template_id?: BigIntFieldUpdateOperationsInput | bigint | number
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collection_rewardCreateInput = {
    collection_id: string
    tag: string
    credits: number
    enabled?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    collection_reward_redemption?: collection_reward_redemptionCreateNestedManyWithoutCollection_rewardInput
  }

  export type collection_rewardUncheckedCreateInput = {
    id?: number
    collection_id: string
    tag: string
    credits: number
    enabled?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    collection_reward_redemption?: collection_reward_redemptionUncheckedCreateNestedManyWithoutCollection_rewardInput
  }

  export type collection_rewardUpdateInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_reward_redemption?: collection_reward_redemptionUpdateManyWithoutCollection_rewardNestedInput
  }

  export type collection_rewardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_reward_redemption?: collection_reward_redemptionUncheckedUpdateManyWithoutCollection_rewardNestedInput
  }

  export type collection_rewardCreateManyInput = {
    id?: number
    collection_id: string
    tag: string
    credits: number
    enabled?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type collection_rewardUpdateManyMutationInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_rewardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_reward_redemptionCreateInput = {
    user_id: string
    wallet_address: string
    token_id: string
    created_at?: Date | string
    collection_reward: collection_rewardCreateNestedOneWithoutCollection_reward_redemptionInput
  }

  export type collection_reward_redemptionUncheckedCreateInput = {
    id?: number
    user_id: string
    wallet_address: string
    token_id: string
    collection_reward_id: number
    created_at?: Date | string
  }

  export type collection_reward_redemptionUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_reward?: collection_rewardUpdateOneRequiredWithoutCollection_reward_redemptionNestedInput
  }

  export type collection_reward_redemptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    collection_reward_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_reward_redemptionCreateManyInput = {
    id?: number
    user_id: string
    wallet_address: string
    token_id: string
    collection_reward_id: number
    created_at?: Date | string
  }

  export type collection_reward_redemptionUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_reward_redemptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    collection_reward_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_sales_receiversCreateInput = {
    address: string
    value: number
    type: string
    collection: collectionCreateNestedOneWithoutCollection_sales_receiversInput
  }

  export type collection_sales_receiversUncheckedCreateInput = {
    id?: number
    collection_id: string
    address: string
    value: number
    type: string
  }

  export type collection_sales_receiversUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    collection?: collectionUpdateOneRequiredWithoutCollection_sales_receiversNestedInput
  }

  export type collection_sales_receiversUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sales_receiversCreateManyInput = {
    id?: number
    collection_id: string
    address: string
    value: number
    type: string
  }

  export type collection_sales_receiversUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sales_receiversUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type collection_historyCreateInput = {
    event: string
    current_value: string
    new_value: string
    created_at?: Date | string
    collection: collectionCreateNestedOneWithoutCollection_historyInput
  }

  export type collection_historyUncheckedCreateInput = {
    id?: number
    event: string
    current_value: string
    new_value: string
    created_at?: Date | string
    collection_id: string
  }

  export type collection_historyUpdateInput = {
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: collectionUpdateOneRequiredWithoutCollection_historyNestedInput
  }

  export type collection_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_id?: StringFieldUpdateOperationsInput | string
  }

  export type collection_historyCreateManyInput = {
    id?: number
    event: string
    current_value: string
    new_value: string
    created_at?: Date | string
    collection_id: string
  }

  export type collection_historyUpdateManyMutationInput = {
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_id?: StringFieldUpdateOperationsInput | string
  }

  export type profileCreateInput = {
    id: string
    profile_image?: string | null
    profile_preference?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    profile_username?: string | null
  }

  export type profileUncheckedCreateInput = {
    id: string
    profile_image?: string | null
    profile_preference?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    profile_username?: string | null
  }

  export type profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    profile_preference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    profile_preference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileCreateManyInput = {
    id: string
    profile_image?: string | null
    profile_preference?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    profile_username?: string | null
  }

  export type profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    profile_preference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    profile_preference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collection_previewCreateInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection: collectionCreateNestedOneWithoutCollection_previewInput
    collection_preview_version?: collection_preview_versionCreateNestedManyWithoutCollection_previewInput
  }

  export type collection_previewUncheckedCreateInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    collection_id: string
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection_preview_version?: collection_preview_versionUncheckedCreateNestedManyWithoutCollection_previewInput
  }

  export type collection_previewUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
    collection?: collectionUpdateOneRequiredWithoutCollection_previewNestedInput
    collection_preview_version?: collection_preview_versionUpdateManyWithoutCollection_previewNestedInput
  }

  export type collection_previewUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
    collection_preview_version?: collection_preview_versionUncheckedUpdateManyWithoutCollection_previewNestedInput
  }

  export type collection_previewCreateManyInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    collection_id: string
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
  }

  export type collection_previewUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type collection_previewUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type collection_preview_versionCreateInput = {
    id?: bigint | number
    version?: number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
    collection_preview: collection_previewCreateNestedOneWithoutCollection_preview_versionInput
    collection_remix?: collection_remixCreateNestedManyWithoutCollection_preview_versionInput
  }

  export type collection_preview_versionUncheckedCreateInput = {
    id?: bigint | number
    version?: number
    collection_preview_id: bigint | number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
    collection_remix?: collection_remixUncheckedCreateNestedManyWithoutCollection_preview_versionInput
  }

  export type collection_preview_versionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview?: collection_previewUpdateOneRequiredWithoutCollection_preview_versionNestedInput
    collection_remix?: collection_remixUpdateManyWithoutCollection_preview_versionNestedInput
  }

  export type collection_preview_versionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    collection_preview_id?: BigIntFieldUpdateOperationsInput | bigint | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_remix?: collection_remixUncheckedUpdateManyWithoutCollection_preview_versionNestedInput
  }

  export type collection_preview_versionCreateManyInput = {
    id?: bigint | number
    version?: number
    collection_preview_id: bigint | number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
  }

  export type collection_preview_versionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_preview_versionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    collection_preview_id?: BigIntFieldUpdateOperationsInput | bigint | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_sample_imagesCreateInput = {
    id?: bigint | number
    url: string
    collection: collectionCreateNestedOneWithoutCollection_sample_imagesInput
  }

  export type collection_sample_imagesUncheckedCreateInput = {
    id?: bigint | number
    url: string
    collection_id: string
  }

  export type collection_sample_imagesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    collection?: collectionUpdateOneRequiredWithoutCollection_sample_imagesNestedInput
  }

  export type collection_sample_imagesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sample_imagesCreateManyInput = {
    id?: bigint | number
    url: string
    collection_id: string
  }

  export type collection_sample_imagesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sample_imagesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
  }

  export type chatCreateInput = {
    id?: string
    created_at?: Date | string | null
    entity_type: string
    entity_id: string
    chat_message?: chat_messageCreateNestedManyWithoutChatInput
  }

  export type chatUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    entity_type: string
    entity_id: string
    chat_message?: chat_messageUncheckedCreateNestedManyWithoutChatInput
  }

  export type chatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    chat_message?: chat_messageUpdateManyWithoutChatNestedInput
  }

  export type chatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    chat_message?: chat_messageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type chatCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    entity_type: string
    entity_id: string
  }

  export type chatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type chatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type chat_messageCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    chat: chatCreateNestedOneWithoutChat_messageInput
    flat_file?: flat_fileCreateNestedOneWithoutChat_messageInput
  }

  export type chat_messageUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    chat_id: string
    flat_file_id?: bigint | number | null
  }

  export type chat_messageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chat?: chatUpdateOneRequiredWithoutChat_messageNestedInput
    flat_file?: flat_fileUpdateOneWithoutChat_messageNestedInput
  }

  export type chat_messageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    flat_file_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type chat_messageCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    chat_id: string
    flat_file_id?: bigint | number | null
  }

  export type chat_messageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type chat_messageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    flat_file_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type socket_io_attachmentsCreateInput = {
    id?: bigint | number
    payload: Buffer
    created_at?: Date | string | null
  }

  export type socket_io_attachmentsUncheckedCreateInput = {
    id?: bigint | number
    payload: Buffer
    created_at?: Date | string | null
  }

  export type socket_io_attachmentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socket_io_attachmentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socket_io_attachmentsCreateManyInput = {
    id?: bigint | number
    payload: Buffer
    created_at?: Date | string | null
  }

  export type socket_io_attachmentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type socket_io_attachmentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type componentCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    collection: collectionCreateNestedOneWithoutCollection_nodeInput
    component_flat_files?: component_flat_fileCreateNestedManyWithoutComponentInput
  }

  export type componentUncheckedCreateInput = {
    id?: bigint | number
    collection_id: string
    created_at?: Date | string | null
    component_flat_files?: component_flat_fileUncheckedCreateNestedManyWithoutComponentInput
  }

  export type componentUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection?: collectionUpdateOneRequiredWithoutCollection_nodeNestedInput
    component_flat_files?: component_flat_fileUpdateManyWithoutComponentNestedInput
  }

  export type componentUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component_flat_files?: component_flat_fileUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type componentCreateManyInput = {
    id?: bigint | number
    collection_id: string
    created_at?: Date | string | null
  }

  export type componentUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type componentUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workflowCreateInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    server?: serverCreateNestedOneWithoutWorkflowInput
    workflow_custom_nodes?: workflow_custom_nodesCreateNestedManyWithoutWorkflowInput
    workflow_models?: WorkflowModelCreateNestedManyWithoutWorkflowInput
  }

  export type workflowUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    server_id?: string | null
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedCreateNestedManyWithoutWorkflowInput
    workflow_models?: WorkflowModelUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type workflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    server?: serverUpdateOneWithoutWorkflowNestedInput
    workflow_custom_nodes?: workflow_custom_nodesUpdateManyWithoutWorkflowNestedInput
    workflow_models?: WorkflowModelUpdateManyWithoutWorkflowNestedInput
  }

  export type workflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    server_id?: NullableStringFieldUpdateOperationsInput | string | null
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedUpdateManyWithoutWorkflowNestedInput
    workflow_models?: WorkflowModelUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type workflowCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    server_id?: string | null
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
  }

  export type workflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type workflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    server_id?: NullableStringFieldUpdateOperationsInput | string | null
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serverCreateInput = {
    id?: string
    name: string
    url: string
    created_at?: Date | string
    updated_at?: Date | string
    workflow?: workflowCreateNestedManyWithoutServerInput
  }

  export type serverUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    created_at?: Date | string
    updated_at?: Date | string
    workflow?: workflowUncheckedCreateNestedManyWithoutServerInput
  }

  export type serverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: workflowUpdateManyWithoutServerNestedInput
  }

  export type serverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: workflowUncheckedUpdateManyWithoutServerNestedInput
  }

  export type serverCreateManyInput = {
    id?: string
    name: string
    url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type serverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type form_configCreateInput = {
    id?: string
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type form_configUncheckedCreateInput = {
    id?: string
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type form_configUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type form_configUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type form_configCreateManyInput = {
    id?: string
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type form_configUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type form_configUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_keyCreateInput = {
    id?: string
    alias: string
    key: string
    workflow_name: string
    user_id: string
    created_at?: Date | string
  }

  export type api_keyUncheckedCreateInput = {
    id?: string
    alias: string
    key: string
    workflow_name: string
    user_id: string
    created_at?: Date | string
  }

  export type api_keyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    workflow_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_keyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    workflow_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_keyCreateManyInput = {
    id?: string
    alias: string
    key: string
    workflow_name: string
    user_id: string
    created_at?: Date | string
  }

  export type api_keyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    workflow_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_keyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    workflow_name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_api_keysCreateInput = {
    id?: string
    user_id: string
    key_hash: string
    name?: string | null
    expires_at?: Date | string | null
    created_at?: Date | string
    is_active?: boolean
  }

  export type user_api_keysUncheckedCreateInput = {
    id?: string
    user_id: string
    key_hash: string
    name?: string | null
    expires_at?: Date | string | null
    created_at?: Date | string
    is_active?: boolean
  }

  export type user_api_keysUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    key_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_api_keysUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    key_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_api_keysCreateManyInput = {
    id?: string
    user_id: string
    key_hash: string
    name?: string | null
    expires_at?: Date | string | null
    created_at?: Date | string
    is_active?: boolean
  }

  export type user_api_keysUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    key_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_api_keysUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    key_hash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type jobCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: number | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    user_id: string
    job_type: string
    priority?: number
    job_history?: job_historyCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: number | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    user_id: string
    job_type: string
    priority?: number
    job_history?: job_historyUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    job_history?: job_historyUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    job_history?: job_historyUncheckedUpdateManyWithoutJobNestedInput
  }

  export type jobCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: number | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    user_id: string
    job_type: string
    priority?: number
  }

  export type jobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type jobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type job_historyCreateInput = {
    id?: string
    status: string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    message?: string | null
    job: jobCreateNestedOneWithoutJob_historyInput
  }

  export type job_historyUncheckedCreateInput = {
    id?: string
    job_id: string
    status: string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    message?: string | null
  }

  export type job_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUpdateOneRequiredWithoutJob_historyNestedInput
  }

  export type job_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type job_historyCreateManyInput = {
    id?: string
    job_id: string
    status: string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    message?: string | null
  }

  export type job_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type job_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type miniapp_userCreateInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutMiniapp_userInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutMiniapp_userInput
    social_links?: social_linkCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userUncheckedCreateInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_userInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutMiniapp_userInput
    social_links?: social_linkUncheckedCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_generation?: miniapp_generationUpdateManyWithoutMiniapp_userNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutMiniapp_userNestedInput
    social_links?: social_linkUpdateManyWithoutMiniapp_userNestedInput
  }

  export type miniapp_userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutMiniapp_userNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutMiniapp_userNestedInput
    social_links?: social_linkUncheckedUpdateManyWithoutMiniapp_userNestedInput
  }

  export type miniapp_userCreateManyInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
  }

  export type miniapp_userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type miniapp_userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type miniapp_collection_configCreateInput = {
    id?: string
    price?: number
    generations_per_payment?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    max_retries?: number
    collection: collectionCreateNestedOneWithoutMiniapp_collection_configInput
  }

  export type miniapp_collection_configUncheckedCreateInput = {
    id?: string
    collection_id: string
    price?: number
    generations_per_payment?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    max_retries?: number
  }

  export type miniapp_collection_configUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    generations_per_payment?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    max_retries?: IntFieldUpdateOperationsInput | number
    collection?: collectionUpdateOneRequiredWithoutMiniapp_collection_configNestedInput
  }

  export type miniapp_collection_configUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    generations_per_payment?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    max_retries?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_collection_configCreateManyInput = {
    id?: string
    collection_id: string
    price?: number
    generations_per_payment?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    max_retries?: number
  }

  export type miniapp_collection_configUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    generations_per_payment?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    max_retries?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_collection_configUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    generations_per_payment?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    max_retries?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_paymentCreateInput = {
    id?: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutMiniapp_paymentInput
    collection: collectionCreateNestedOneWithoutMiniapp_paymentInput
    miniapp_user: miniapp_userCreateNestedOneWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentUncheckedCreateInput = {
    id?: string
    user_id: string
    collection_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_generation?: miniapp_generationUpdateManyWithoutMiniapp_paymentNestedInput
    collection?: collectionUpdateOneRequiredWithoutMiniapp_paymentNestedInput
    miniapp_user?: miniapp_userUpdateOneRequiredWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentCreateManyInput = {
    id?: string
    user_id: string
    collection_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type miniapp_paymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type miniapp_paymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type miniapp_generationCreateInput = {
    id?: string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
    collection: collectionCreateNestedOneWithoutMiniapp_generationInput
    miniapp_payment?: miniapp_paymentCreateNestedOneWithoutMiniapp_generationInput
    miniapp_user: miniapp_userCreateNestedOneWithoutMiniapp_generationInput
  }

  export type miniapp_generationUncheckedCreateInput = {
    id?: string
    user_id: string
    collection_id: string
    payment_id?: string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_generationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
    collection?: collectionUpdateOneRequiredWithoutMiniapp_generationNestedInput
    miniapp_payment?: miniapp_paymentUpdateOneWithoutMiniapp_generationNestedInput
    miniapp_user?: miniapp_userUpdateOneRequiredWithoutMiniapp_generationNestedInput
  }

  export type miniapp_generationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationCreateManyInput = {
    id?: string
    user_id: string
    collection_id: string
    payment_id?: string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_generationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type ModelCreateInput = {
    id?: string
    name: string
    downloadUrl: string
    saveTo: string
    description?: string | null
    fileSize?: string | null
    hash?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authEnvVar?: string | null
    isAuthReq?: boolean
    workflowModels?: WorkflowModelCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    name: string
    downloadUrl: string
    saveTo: string
    description?: string | null
    fileSize?: string | null
    hash?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authEnvVar?: string | null
    isAuthReq?: boolean
    workflowModels?: WorkflowModelUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    saveTo?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authEnvVar?: NullableStringFieldUpdateOperationsInput | string | null
    isAuthReq?: BoolFieldUpdateOperationsInput | boolean
    workflowModels?: WorkflowModelUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    saveTo?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authEnvVar?: NullableStringFieldUpdateOperationsInput | string | null
    isAuthReq?: BoolFieldUpdateOperationsInput | boolean
    workflowModels?: WorkflowModelUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: string
    name: string
    downloadUrl: string
    saveTo: string
    description?: string | null
    fileSize?: string | null
    hash?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authEnvVar?: string | null
    isAuthReq?: boolean
  }

  export type ModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    saveTo?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authEnvVar?: NullableStringFieldUpdateOperationsInput | string | null
    isAuthReq?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    saveTo?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authEnvVar?: NullableStringFieldUpdateOperationsInput | string | null
    isAuthReq?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowModelCreateInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    model: ModelCreateNestedOneWithoutWorkflowModelsInput
    workflow: workflowCreateNestedOneWithoutWorkflow_modelsInput
  }

  export type WorkflowModelUncheckedCreateInput = {
    id?: string
    workflowId: string
    modelId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type WorkflowModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutWorkflowModelsNestedInput
    workflow?: workflowUpdateOneRequiredWithoutWorkflow_modelsNestedInput
  }

  export type WorkflowModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowModelCreateManyInput = {
    id?: string
    workflowId: string
    modelId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type WorkflowModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type component_flat_file_recoverCreateInput = {
    id: bigint | number
    component_id: bigint | number
    flat_file_id: bigint | number
    recovered_at?: Date | string
    issue_type: string
  }

  export type component_flat_file_recoverUncheckedCreateInput = {
    id: bigint | number
    component_id: bigint | number
    flat_file_id: bigint | number
    recovered_at?: Date | string
    issue_type: string
  }

  export type component_flat_file_recoverUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recovered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    issue_type?: StringFieldUpdateOperationsInput | string
  }

  export type component_flat_file_recoverUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recovered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    issue_type?: StringFieldUpdateOperationsInput | string
  }

  export type component_flat_file_recoverCreateManyInput = {
    id: bigint | number
    component_id: bigint | number
    flat_file_id: bigint | number
    recovered_at?: Date | string
    issue_type: string
  }

  export type component_flat_file_recoverUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recovered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    issue_type?: StringFieldUpdateOperationsInput | string
  }

  export type component_flat_file_recoverUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recovered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    issue_type?: StringFieldUpdateOperationsInput | string
  }

  export type social_linkCreateInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    custodial_collections?: collectionCreateNestedManyWithoutSocial_linkInput
    miniapp_user?: miniapp_userCreateNestedOneWithoutSocial_linksInput
  }

  export type social_linkUncheckedCreateInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_user_id?: string | null
    custodial_collections?: collectionUncheckedCreateNestedManyWithoutSocial_linkInput
  }

  export type social_linkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    custodial_collections?: collectionUpdateManyWithoutSocial_linkNestedInput
    miniapp_user?: miniapp_userUpdateOneWithoutSocial_linksNestedInput
  }

  export type social_linkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    custodial_collections?: collectionUncheckedUpdateManyWithoutSocial_linkNestedInput
  }

  export type social_linkCreateManyInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_user_id?: string | null
  }

  export type social_linkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_linkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type custom_nodesCreateInput = {
    id?: string
    name: string
    download_url: string
    description?: string | null
    is_env_required?: boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean
    install_order?: number | null
    workflow_custom_nodes?: workflow_custom_nodesCreateNestedManyWithoutCustom_nodesInput
  }

  export type custom_nodesUncheckedCreateInput = {
    id?: string
    name: string
    download_url: string
    description?: string | null
    is_env_required?: boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean
    install_order?: number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedCreateNestedManyWithoutCustom_nodesInput
  }

  export type custom_nodesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    download_url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_env_required?: BoolFieldUpdateOperationsInput | boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: BoolFieldUpdateOperationsInput | boolean
    install_order?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_custom_nodes?: workflow_custom_nodesUpdateManyWithoutCustom_nodesNestedInput
  }

  export type custom_nodesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    download_url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_env_required?: BoolFieldUpdateOperationsInput | boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: BoolFieldUpdateOperationsInput | boolean
    install_order?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedUpdateManyWithoutCustom_nodesNestedInput
  }

  export type custom_nodesCreateManyInput = {
    id?: string
    name: string
    download_url: string
    description?: string | null
    is_env_required?: boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean
    install_order?: number | null
  }

  export type custom_nodesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    download_url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_env_required?: BoolFieldUpdateOperationsInput | boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: BoolFieldUpdateOperationsInput | boolean
    install_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type custom_nodesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    download_url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_env_required?: BoolFieldUpdateOperationsInput | boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: BoolFieldUpdateOperationsInput | boolean
    install_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type workflow_custom_nodesCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    custom_nodes: custom_nodesCreateNestedOneWithoutWorkflow_custom_nodesInput
    workflow: workflowCreateNestedOneWithoutWorkflow_custom_nodesInput
  }

  export type workflow_custom_nodesUncheckedCreateInput = {
    id?: bigint | number
    workflow_id: string
    custom_node_id: string
    created_at?: Date | string
  }

  export type workflow_custom_nodesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    custom_nodes?: custom_nodesUpdateOneRequiredWithoutWorkflow_custom_nodesNestedInput
    workflow?: workflowUpdateOneRequiredWithoutWorkflow_custom_nodesNestedInput
  }

  export type workflow_custom_nodesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    workflow_id?: StringFieldUpdateOperationsInput | string
    custom_node_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workflow_custom_nodesCreateManyInput = {
    id?: bigint | number
    workflow_id: string
    custom_node_id: string
    created_at?: Date | string
  }

  export type workflow_custom_nodesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workflow_custom_nodesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    workflow_id?: StringFieldUpdateOperationsInput | string
    custom_node_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type assignmentCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    address?: SortOrder
    token_id?: SortOrder
    created_at?: SortOrder
  }

  export type assignmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type assignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    address?: SortOrder
    token_id?: SortOrder
    created_at?: SortOrder
  }

  export type assignmentMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    address?: SortOrder
    token_id?: SortOrder
    created_at?: SortOrder
  }

  export type assignmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Social_linkNullableRelationFilter = {
    is?: social_linkWhereInput | null
    isNot?: social_linkWhereInput | null
  }

  export type ProjectRelationFilter = {
    is?: projectWhereInput
    isNot?: projectWhereInput
  }

  export type Collection_historyListRelationFilter = {
    every?: collection_historyWhereInput
    some?: collection_historyWhereInput
    none?: collection_historyWhereInput
  }

  export type Collection_previewNullableRelationFilter = {
    is?: collection_previewWhereInput | null
    isNot?: collection_previewWhereInput | null
  }

  export type Collection_remixListRelationFilter = {
    every?: collection_remixWhereInput
    some?: collection_remixWhereInput
    none?: collection_remixWhereInput
  }

  export type Collection_sales_receiversListRelationFilter = {
    every?: collection_sales_receiversWhereInput
    some?: collection_sales_receiversWhereInput
    none?: collection_sales_receiversWhereInput
  }

  export type Collection_sample_imagesListRelationFilter = {
    every?: collection_sample_imagesWhereInput
    some?: collection_sample_imagesWhereInput
    none?: collection_sample_imagesWhereInput
  }

  export type ComponentListRelationFilter = {
    every?: componentWhereInput
    some?: componentWhereInput
    none?: componentWhereInput
  }

  export type Miniapp_collection_configNullableRelationFilter = {
    is?: miniapp_collection_configWhereInput | null
    isNot?: miniapp_collection_configWhereInput | null
  }

  export type Miniapp_generationListRelationFilter = {
    every?: miniapp_generationWhereInput
    some?: miniapp_generationWhereInput
    none?: miniapp_generationWhereInput
  }

  export type Miniapp_paymentListRelationFilter = {
    every?: miniapp_paymentWhereInput
    some?: miniapp_paymentWhereInput
    none?: miniapp_paymentWhereInput
  }

  export type collection_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collection_remixOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collection_sales_receiversOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collection_sample_imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type componentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type miniapp_generationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type miniapp_paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collectionCountOrderByAggregateInput = {
    id?: SortOrder
    archived?: SortOrder
    batch_max_tokens?: SortOrder
    batch_mint_enabled?: SortOrder
    blockchain?: SortOrder
    cover_image_url?: SortOrder
    data?: SortOrder
    description?: SortOrder
    editions?: SortOrder
    encryption_enabled?: SortOrder
    images?: SortOrder
    is_current?: SortOrder
    price?: SortOrder
    project_id?: SortOrder
    publish_date?: SortOrder
    status?: SortOrder
    title?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    is_custodial?: SortOrder
    custodied_for?: SortOrder
    miniapp_cover_image?: SortOrder
  }

  export type collectionAvgOrderByAggregateInput = {
    batch_max_tokens?: SortOrder
    editions?: SortOrder
    price?: SortOrder
  }

  export type collectionMaxOrderByAggregateInput = {
    id?: SortOrder
    archived?: SortOrder
    batch_max_tokens?: SortOrder
    batch_mint_enabled?: SortOrder
    blockchain?: SortOrder
    cover_image_url?: SortOrder
    description?: SortOrder
    editions?: SortOrder
    encryption_enabled?: SortOrder
    is_current?: SortOrder
    price?: SortOrder
    project_id?: SortOrder
    publish_date?: SortOrder
    status?: SortOrder
    title?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    is_custodial?: SortOrder
    custodied_for?: SortOrder
    miniapp_cover_image?: SortOrder
  }

  export type collectionMinOrderByAggregateInput = {
    id?: SortOrder
    archived?: SortOrder
    batch_max_tokens?: SortOrder
    batch_mint_enabled?: SortOrder
    blockchain?: SortOrder
    cover_image_url?: SortOrder
    description?: SortOrder
    editions?: SortOrder
    encryption_enabled?: SortOrder
    is_current?: SortOrder
    price?: SortOrder
    project_id?: SortOrder
    publish_date?: SortOrder
    status?: SortOrder
    title?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    is_custodial?: SortOrder
    custodied_for?: SortOrder
    miniapp_cover_image?: SortOrder
  }

  export type collectionSumOrderByAggregateInput = {
    batch_max_tokens?: SortOrder
    editions?: SortOrder
    price?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type Collection_preview_versionNullableRelationFilter = {
    is?: collection_preview_versionWhereInput | null
    isNot?: collection_preview_versionWhereInput | null
  }

  export type CollectionRelationFilter = {
    is?: collectionWhereInput
    isNot?: collectionWhereInput
  }

  export type collection_remixCountOrderByAggregateInput = {
    id?: SortOrder
    source_collection_id?: SortOrder
    target_collection_id?: SortOrder
    created_at?: SortOrder
    collection_preview_version_id?: SortOrder
  }

  export type collection_remixAvgOrderByAggregateInput = {
    id?: SortOrder
    collection_preview_version_id?: SortOrder
  }

  export type collection_remixMaxOrderByAggregateInput = {
    id?: SortOrder
    source_collection_id?: SortOrder
    target_collection_id?: SortOrder
    created_at?: SortOrder
    collection_preview_version_id?: SortOrder
  }

  export type collection_remixMinOrderByAggregateInput = {
    id?: SortOrder
    source_collection_id?: SortOrder
    target_collection_id?: SortOrder
    created_at?: SortOrder
    collection_preview_version_id?: SortOrder
  }

  export type collection_remixSumOrderByAggregateInput = {
    id?: SortOrder
    collection_preview_version_id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type eventCountOrderByAggregateInput = {
    id?: SortOrder
    event_name?: SortOrder
    property_name?: SortOrder
    property_value?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_type?: SortOrder
  }

  export type eventMaxOrderByAggregateInput = {
    id?: SortOrder
    event_name?: SortOrder
    property_name?: SortOrder
    property_value?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_type?: SortOrder
  }

  export type eventMinOrderByAggregateInput = {
    id?: SortOrder
    event_name?: SortOrder
    property_name?: SortOrder
    property_value?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_type?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Chat_messageListRelationFilter = {
    every?: chat_messageWhereInput
    some?: chat_messageWhereInput
    none?: chat_messageWhereInput
  }

  export type Component_flat_fileListRelationFilter = {
    every?: component_flat_fileWhereInput
    some?: component_flat_fileWhereInput
    none?: component_flat_fileWhereInput
  }

  export type chat_messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type component_flat_fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type flat_fileCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    url?: SortOrder
    hidden?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    gen_in_data?: SortOrder
    gen_out_data?: SortOrder
    mime_type?: SortOrder
    rel_id?: SortOrder
    rel_type?: SortOrder
    tags?: SortOrder
  }

  export type flat_fileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type flat_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    url?: SortOrder
    hidden?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    mime_type?: SortOrder
    rel_id?: SortOrder
    rel_type?: SortOrder
  }

  export type flat_fileMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    url?: SortOrder
    hidden?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    mime_type?: SortOrder
    rel_id?: SortOrder
    rel_type?: SortOrder
  }

  export type flat_fileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ComponentRelationFilter = {
    is?: componentWhereInput
    isNot?: componentWhereInput
  }

  export type Flat_fileRelationFilter = {
    is?: flat_fileWhereInput
    isNot?: flat_fileWhereInput
  }

  export type component_flat_fileComponent_idFlat_file_idCompoundUniqueInput = {
    component_id: bigint | number
    flat_file_id: bigint | number
  }

  export type component_flat_fileCountOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type component_flat_fileAvgOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type component_flat_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type component_flat_fileMinOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type component_flat_fileSumOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type CollectionListRelationFilter = {
    every?: collectionWhereInput
    some?: collectionWhereInput
    none?: collectionWhereInput
  }

  export type collectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projectCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    data?: SortOrder
    current_project_history_id?: SortOrder
    version?: SortOrder
    archived?: SortOrder
    is_default?: SortOrder
  }

  export type projectMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    current_project_history_id?: SortOrder
    version?: SortOrder
    archived?: SortOrder
    is_default?: SortOrder
  }

  export type projectMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
    user_id?: SortOrder
    current_project_history_id?: SortOrder
    version?: SortOrder
    archived?: SortOrder
    is_default?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type project_historyCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    data?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
    images?: SortOrder
  }

  export type project_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
  }

  export type project_historyMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    name?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    name?: SortOrder
  }

  export type walletCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    address?: SortOrder
    user_id?: SortOrder
  }

  export type walletAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type walletMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    address?: SortOrder
    user_id?: SortOrder
  }

  export type walletMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    address?: SortOrder
    user_id?: SortOrder
  }

  export type walletSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type credits_historyCountOrderByAggregateInput = {
    id?: SortOrder
    flow?: SortOrder
    amount?: SortOrder
    credit_type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
  }

  export type credits_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type credits_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    flow?: SortOrder
    amount?: SortOrder
    credit_type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
  }

  export type credits_historyMinOrderByAggregateInput = {
    id?: SortOrder
    flow?: SortOrder
    amount?: SortOrder
    credit_type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    comment?: SortOrder
  }

  export type credits_historySumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type credits_balanceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    balance?: SortOrder
    credit_type?: SortOrder
  }

  export type credits_balanceAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type credits_balanceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    balance?: SortOrder
    credit_type?: SortOrder
  }

  export type credits_balanceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    balance?: SortOrder
    credit_type?: SortOrder
  }

  export type credits_balanceSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type subscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    stripe_subscription_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    stripe_product_id?: SortOrder
    subscription_key?: SortOrder
    cancel_at_period_end?: SortOrder
    current_period_end?: SortOrder
    current_period_start?: SortOrder
  }

  export type subscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    stripe_subscription_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    stripe_product_id?: SortOrder
    subscription_key?: SortOrder
    cancel_at_period_end?: SortOrder
    current_period_end?: SortOrder
    current_period_start?: SortOrder
  }

  export type subscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    stripe_subscription_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    stripe_product_id?: SortOrder
    subscription_key?: SortOrder
    cancel_at_period_end?: SortOrder
    current_period_end?: SortOrder
    current_period_start?: SortOrder
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    stripe_customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    prefinery_referral_code?: SortOrder
    has_migrated?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    stripe_customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    prefinery_referral_code?: SortOrder
    has_migrated?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    stripe_customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    prefinery_referral_code?: SortOrder
    has_migrated?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    stripe_price_id?: SortOrder
    stripe_product_id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrder
    credits_type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lookup_key?: SortOrder
    rank?: SortOrder
    features?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrder
    rank?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    stripe_price_id?: SortOrder
    stripe_product_id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrder
    credits_type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lookup_key?: SortOrder
    rank?: SortOrder
    features?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    stripe_price_id?: SortOrder
    stripe_product_id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrder
    credits_type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lookup_key?: SortOrder
    rank?: SortOrder
    features?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    credits_quantity?: SortOrder
    rank?: SortOrder
  }

  export type Project_template_saveListRelationFilter = {
    every?: project_template_saveWhereInput
    some?: project_template_saveWhereInput
    none?: project_template_saveWhereInput
  }

  export type project_template_saveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type project_templateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_project_history_id?: SortOrder
  }

  export type project_templateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type project_templateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_project_history_id?: SortOrder
  }

  export type project_templateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_project_history_id?: SortOrder
  }

  export type project_templateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Project_templateRelationFilter = {
    is?: project_templateWhereInput
    isNot?: project_templateWhereInput
  }

  export type project_template_saveCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    images?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project_template_id?: SortOrder
    project_history_id?: SortOrder
  }

  export type project_template_saveAvgOrderByAggregateInput = {
    id?: SortOrder
    project_template_id?: SortOrder
  }

  export type project_template_saveMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project_template_id?: SortOrder
    project_history_id?: SortOrder
  }

  export type project_template_saveMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project_template_id?: SortOrder
    project_history_id?: SortOrder
  }

  export type project_template_saveSumOrderByAggregateInput = {
    id?: SortOrder
    project_template_id?: SortOrder
  }

  export type Collection_reward_redemptionListRelationFilter = {
    every?: collection_reward_redemptionWhereInput
    some?: collection_reward_redemptionWhereInput
    none?: collection_reward_redemptionWhereInput
  }

  export type collection_reward_redemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collection_rewardCountOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    tag?: SortOrder
    credits?: SortOrder
    enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type collection_rewardAvgOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
  }

  export type collection_rewardMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    tag?: SortOrder
    credits?: SortOrder
    enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type collection_rewardMinOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    tag?: SortOrder
    credits?: SortOrder
    enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type collection_rewardSumOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
  }

  export type Collection_rewardRelationFilter = {
    is?: collection_rewardWhereInput
    isNot?: collection_rewardWhereInput
  }

  export type collection_reward_redemptionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    token_id?: SortOrder
    collection_reward_id?: SortOrder
    created_at?: SortOrder
  }

  export type collection_reward_redemptionAvgOrderByAggregateInput = {
    id?: SortOrder
    collection_reward_id?: SortOrder
  }

  export type collection_reward_redemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    token_id?: SortOrder
    collection_reward_id?: SortOrder
    created_at?: SortOrder
  }

  export type collection_reward_redemptionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    token_id?: SortOrder
    collection_reward_id?: SortOrder
    created_at?: SortOrder
  }

  export type collection_reward_redemptionSumOrderByAggregateInput = {
    id?: SortOrder
    collection_reward_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type collection_sales_receiversCountOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type collection_sales_receiversAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type collection_sales_receiversMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type collection_sales_receiversMinOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type collection_sales_receiversSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type collection_historyCountOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    current_value?: SortOrder
    new_value?: SortOrder
    created_at?: SortOrder
    collection_id?: SortOrder
  }

  export type collection_historyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type collection_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    current_value?: SortOrder
    new_value?: SortOrder
    created_at?: SortOrder
    collection_id?: SortOrder
  }

  export type collection_historyMinOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    current_value?: SortOrder
    new_value?: SortOrder
    created_at?: SortOrder
    collection_id?: SortOrder
  }

  export type collection_historySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type profileCountOrderByAggregateInput = {
    id?: SortOrder
    profile_image?: SortOrder
    profile_preference?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    profile_username?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_image?: SortOrder
    profile_preference?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    profile_username?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    id?: SortOrder
    profile_image?: SortOrder
    profile_preference?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    profile_username?: SortOrder
  }

  export type Collection_preview_versionListRelationFilter = {
    every?: collection_preview_versionWhereInput
    some?: collection_preview_versionWhereInput
    none?: collection_preview_versionWhereInput
  }

  export type collection_preview_versionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collection_previewCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
    collection_id?: SortOrder
    access_level?: SortOrder
    is_remixable?: SortOrder
    farcaster_collection?: SortOrder
  }

  export type collection_previewAvgOrderByAggregateInput = {
    id?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
  }

  export type collection_previewMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
    collection_id?: SortOrder
    access_level?: SortOrder
    is_remixable?: SortOrder
    farcaster_collection?: SortOrder
  }

  export type collection_previewMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
    collection_id?: SortOrder
    access_level?: SortOrder
    is_remixable?: SortOrder
    farcaster_collection?: SortOrder
  }

  export type collection_previewSumOrderByAggregateInput = {
    id?: SortOrder
    max_generations?: SortOrder
    total_generations?: SortOrder
  }

  export type Collection_previewRelationFilter = {
    is?: collection_previewWhereInput
    isNot?: collection_previewWhereInput
  }

  export type collection_preview_versionCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
    data?: SortOrder
    is_latest?: SortOrder
    created_at?: SortOrder
  }

  export type collection_preview_versionAvgOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
  }

  export type collection_preview_versionMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
    is_latest?: SortOrder
    created_at?: SortOrder
  }

  export type collection_preview_versionMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
    is_latest?: SortOrder
    created_at?: SortOrder
  }

  export type collection_preview_versionSumOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    collection_preview_id?: SortOrder
  }

  export type collection_sample_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    collection_id?: SortOrder
  }

  export type collection_sample_imagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type collection_sample_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    collection_id?: SortOrder
  }

  export type collection_sample_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    collection_id?: SortOrder
  }

  export type collection_sample_imagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type chatCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
  }

  export type chatMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
  }

  export type chatMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
  }

  export type ChatRelationFilter = {
    is?: chatWhereInput
    isNot?: chatWhereInput
  }

  export type Flat_fileNullableRelationFilter = {
    is?: flat_fileWhereInput | null
    isNot?: flat_fileWhereInput | null
  }

  export type chat_messageCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    chat_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type chat_messageAvgOrderByAggregateInput = {
    flat_file_id?: SortOrder
  }

  export type chat_messageMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    chat_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type chat_messageMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    chat_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type chat_messageSumOrderByAggregateInput = {
    flat_file_id?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type socket_io_attachmentsCountOrderByAggregateInput = {
    id?: SortOrder
    payload?: SortOrder
    created_at?: SortOrder
  }

  export type socket_io_attachmentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type socket_io_attachmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    payload?: SortOrder
    created_at?: SortOrder
  }

  export type socket_io_attachmentsMinOrderByAggregateInput = {
    id?: SortOrder
    payload?: SortOrder
    created_at?: SortOrder
  }

  export type socket_io_attachmentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type componentCountOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
  }

  export type componentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type componentMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
  }

  export type componentMinOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    created_at?: SortOrder
  }

  export type componentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServerNullableRelationFilter = {
    is?: serverWhereInput | null
    isNot?: serverWhereInput | null
  }

  export type Workflow_custom_nodesListRelationFilter = {
    every?: workflow_custom_nodesWhereInput
    some?: workflow_custom_nodesWhereInput
    none?: workflow_custom_nodesWhereInput
  }

  export type WorkflowModelListRelationFilter = {
    every?: WorkflowModelWhereInput
    some?: WorkflowModelWhereInput
    none?: WorkflowModelWhereInput
  }

  export type workflow_custom_nodesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type workflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    server_id?: SortOrder
    output_mime_type?: SortOrder
    display?: SortOrder
    label?: SortOrder
    order?: SortOrder
    type?: SortOrder
    est_gen_time?: SortOrder
    machine_type?: SortOrder
    min_vram?: SortOrder
  }

  export type workflowAvgOrderByAggregateInput = {
    order?: SortOrder
    min_vram?: SortOrder
  }

  export type workflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    server_id?: SortOrder
    output_mime_type?: SortOrder
    display?: SortOrder
    label?: SortOrder
    order?: SortOrder
    type?: SortOrder
    machine_type?: SortOrder
    min_vram?: SortOrder
  }

  export type workflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    server_id?: SortOrder
    output_mime_type?: SortOrder
    display?: SortOrder
    label?: SortOrder
    order?: SortOrder
    type?: SortOrder
    machine_type?: SortOrder
    min_vram?: SortOrder
  }

  export type workflowSumOrderByAggregateInput = {
    order?: SortOrder
    min_vram?: SortOrder
  }

  export type WorkflowListRelationFilter = {
    every?: workflowWhereInput
    some?: workflowWhereInput
    none?: workflowWhereInput
  }

  export type workflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serverCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type serverMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type serverMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type form_configCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type form_configMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type form_configMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type api_keyCountOrderByAggregateInput = {
    id?: SortOrder
    alias?: SortOrder
    key?: SortOrder
    workflow_name?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type api_keyMaxOrderByAggregateInput = {
    id?: SortOrder
    alias?: SortOrder
    key?: SortOrder
    workflow_name?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type api_keyMinOrderByAggregateInput = {
    id?: SortOrder
    alias?: SortOrder
    key?: SortOrder
    workflow_name?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type user_api_keysCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    key_hash?: SortOrder
    name?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type user_api_keysMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    key_hash?: SortOrder
    name?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type user_api_keysMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    key_hash?: SortOrder
    name?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type Job_historyListRelationFilter = {
    every?: job_historyWhereInput
    some?: job_historyWhereInput
    none?: job_historyWhereInput
  }

  export type job_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    data?: SortOrder
    progress?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
    job_type?: SortOrder
    priority?: SortOrder
  }

  export type jobAvgOrderByAggregateInput = {
    progress?: SortOrder
    priority?: SortOrder
  }

  export type jobMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
    job_type?: SortOrder
    priority?: SortOrder
  }

  export type jobMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
    job_type?: SortOrder
    priority?: SortOrder
  }

  export type jobSumOrderByAggregateInput = {
    progress?: SortOrder
    priority?: SortOrder
  }

  export type JobRelationFilter = {
    is?: jobWhereInput
    isNot?: jobWhereInput
  }

  export type job_historyCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    status?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    message?: SortOrder
  }

  export type job_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    message?: SortOrder
  }

  export type job_historyMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    message?: SortOrder
  }

  export type Social_linkListRelationFilter = {
    every?: social_linkWhereInput
    some?: social_linkWhereInput
    none?: social_linkWhereInput
  }

  export type social_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type miniapp_userCountOrderByAggregateInput = {
    id?: SortOrder
    farcaster_id?: SortOrder
    farcaster_username?: SortOrder
    farcaster_pfp?: SortOrder
    wallet_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    notification_token?: SortOrder
  }

  export type miniapp_userMaxOrderByAggregateInput = {
    id?: SortOrder
    farcaster_id?: SortOrder
    farcaster_username?: SortOrder
    farcaster_pfp?: SortOrder
    wallet_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    notification_token?: SortOrder
  }

  export type miniapp_userMinOrderByAggregateInput = {
    id?: SortOrder
    farcaster_id?: SortOrder
    farcaster_username?: SortOrder
    farcaster_pfp?: SortOrder
    wallet_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    notification_token?: SortOrder
  }

  export type miniapp_collection_configCountOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    price?: SortOrder
    generations_per_payment?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    max_retries?: SortOrder
  }

  export type miniapp_collection_configAvgOrderByAggregateInput = {
    price?: SortOrder
    generations_per_payment?: SortOrder
    max_retries?: SortOrder
  }

  export type miniapp_collection_configMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    price?: SortOrder
    generations_per_payment?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    max_retries?: SortOrder
  }

  export type miniapp_collection_configMinOrderByAggregateInput = {
    id?: SortOrder
    collection_id?: SortOrder
    price?: SortOrder
    generations_per_payment?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    max_retries?: SortOrder
  }

  export type miniapp_collection_configSumOrderByAggregateInput = {
    price?: SortOrder
    generations_per_payment?: SortOrder
    max_retries?: SortOrder
  }

  export type Miniapp_userRelationFilter = {
    is?: miniapp_userWhereInput
    isNot?: miniapp_userWhereInput
  }

  export type miniapp_paymentCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    amount?: SortOrder
    transaction_hash?: SortOrder
    payment_status?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type miniapp_paymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
  }

  export type miniapp_paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    amount?: SortOrder
    transaction_hash?: SortOrder
    payment_status?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type miniapp_paymentMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    amount?: SortOrder
    transaction_hash?: SortOrder
    payment_status?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type miniapp_paymentSumOrderByAggregateInput = {
    amount?: SortOrder
    generations_allowed?: SortOrder
    generations_used?: SortOrder
  }

  export type EnumGenerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GenerationStatus | EnumGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGenerationStatusFilter<$PrismaModel> | $Enums.GenerationStatus
  }

  export type Miniapp_paymentNullableRelationFilter = {
    is?: miniapp_paymentWhereInput | null
    isNot?: miniapp_paymentWhereInput | null
  }

  export type miniapp_generationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    payment_id?: SortOrder
    input_data?: SortOrder
    output_url?: SortOrder
    output_data?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_id?: SortOrder
    generated_image?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
  }

  export type miniapp_generationAvgOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type miniapp_generationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    payment_id?: SortOrder
    output_url?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_id?: SortOrder
    generated_image?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
  }

  export type miniapp_generationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    payment_id?: SortOrder
    output_url?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_id?: SortOrder
    generated_image?: SortOrder
    status?: SortOrder
    retry_count?: SortOrder
  }

  export type miniapp_generationSumOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type EnumGenerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenerationStatus | EnumGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGenerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.GenerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenerationStatusFilter<$PrismaModel>
    _max?: NestedEnumGenerationStatusFilter<$PrismaModel>
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    downloadUrl?: SortOrder
    saveTo?: SortOrder
    description?: SortOrder
    fileSize?: SortOrder
    hash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authEnvVar?: SortOrder
    isAuthReq?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    downloadUrl?: SortOrder
    saveTo?: SortOrder
    description?: SortOrder
    fileSize?: SortOrder
    hash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authEnvVar?: SortOrder
    isAuthReq?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    downloadUrl?: SortOrder
    saveTo?: SortOrder
    description?: SortOrder
    fileSize?: SortOrder
    hash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authEnvVar?: SortOrder
    isAuthReq?: SortOrder
  }

  export type ModelRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type WorkflowRelationFilter = {
    is?: workflowWhereInput
    isNot?: workflowWhereInput
  }

  export type WorkflowModelWorkflowIdModelIdCompoundUniqueInput = {
    workflowId: string
    modelId: string
  }

  export type WorkflowModelCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    modelId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowModelMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    modelId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowModelMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    modelId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
  }

  export type component_flat_file_recoverCountOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    recovered_at?: SortOrder
    issue_type?: SortOrder
  }

  export type component_flat_file_recoverAvgOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type component_flat_file_recoverMaxOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    recovered_at?: SortOrder
    issue_type?: SortOrder
  }

  export type component_flat_file_recoverMinOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
    recovered_at?: SortOrder
    issue_type?: SortOrder
  }

  export type component_flat_file_recoverSumOrderByAggregateInput = {
    id?: SortOrder
    component_id?: SortOrder
    flat_file_id?: SortOrder
  }

  export type Enumsocial_org_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.social_org_enum | Enumsocial_org_enumFieldRefInput<$PrismaModel>
    in?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsocial_org_enumFilter<$PrismaModel> | $Enums.social_org_enum
  }

  export type Miniapp_userNullableRelationFilter = {
    is?: miniapp_userWhereInput | null
    isNot?: miniapp_userWhereInput | null
  }

  export type social_linkSocial_orgIdentifierCompoundUniqueInput = {
    social_org: $Enums.social_org_enum
    identifier: string
  }

  export type social_linkCountOrderByAggregateInput = {
    id?: SortOrder
    social_org?: SortOrder
    identifier?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    miniapp_user_id?: SortOrder
  }

  export type social_linkMaxOrderByAggregateInput = {
    id?: SortOrder
    social_org?: SortOrder
    identifier?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    miniapp_user_id?: SortOrder
  }

  export type social_linkMinOrderByAggregateInput = {
    id?: SortOrder
    social_org?: SortOrder
    identifier?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    miniapp_user_id?: SortOrder
  }

  export type Enumsocial_org_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.social_org_enum | Enumsocial_org_enumFieldRefInput<$PrismaModel>
    in?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsocial_org_enumWithAggregatesFilter<$PrismaModel> | $Enums.social_org_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsocial_org_enumFilter<$PrismaModel>
    _max?: NestedEnumsocial_org_enumFilter<$PrismaModel>
  }

  export type custom_nodesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    download_url?: SortOrder
    description?: SortOrder
    is_env_required?: SortOrder
    env_conf?: SortOrder
    hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    install_settings?: SortOrder
    is_default?: SortOrder
    install_order?: SortOrder
  }

  export type custom_nodesAvgOrderByAggregateInput = {
    install_order?: SortOrder
  }

  export type custom_nodesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    download_url?: SortOrder
    description?: SortOrder
    is_env_required?: SortOrder
    hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_default?: SortOrder
    install_order?: SortOrder
  }

  export type custom_nodesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    download_url?: SortOrder
    description?: SortOrder
    is_env_required?: SortOrder
    hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_default?: SortOrder
    install_order?: SortOrder
  }

  export type custom_nodesSumOrderByAggregateInput = {
    install_order?: SortOrder
  }

  export type Custom_nodesRelationFilter = {
    is?: custom_nodesWhereInput
    isNot?: custom_nodesWhereInput
  }

  export type workflow_custom_nodesWorkflow_idCustom_node_idCompoundUniqueInput = {
    workflow_id: string
    custom_node_id: string
  }

  export type workflow_custom_nodesCountOrderByAggregateInput = {
    id?: SortOrder
    workflow_id?: SortOrder
    custom_node_id?: SortOrder
    created_at?: SortOrder
  }

  export type workflow_custom_nodesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type workflow_custom_nodesMaxOrderByAggregateInput = {
    id?: SortOrder
    workflow_id?: SortOrder
    custom_node_id?: SortOrder
    created_at?: SortOrder
  }

  export type workflow_custom_nodesMinOrderByAggregateInput = {
    id?: SortOrder
    workflow_id?: SortOrder
    custom_node_id?: SortOrder
    created_at?: SortOrder
  }

  export type workflow_custom_nodesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type social_linkCreateNestedOneWithoutCustodial_collectionsInput = {
    create?: XOR<social_linkCreateWithoutCustodial_collectionsInput, social_linkUncheckedCreateWithoutCustodial_collectionsInput>
    connectOrCreate?: social_linkCreateOrConnectWithoutCustodial_collectionsInput
    connect?: social_linkWhereUniqueInput
  }

  export type projectCreateNestedOneWithoutCollectionInput = {
    create?: XOR<projectCreateWithoutCollectionInput, projectUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: projectCreateOrConnectWithoutCollectionInput
    connect?: projectWhereUniqueInput
  }

  export type collection_historyCreateNestedManyWithoutCollectionInput = {
    create?: XOR<collection_historyCreateWithoutCollectionInput, collection_historyUncheckedCreateWithoutCollectionInput> | collection_historyCreateWithoutCollectionInput[] | collection_historyUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_historyCreateOrConnectWithoutCollectionInput | collection_historyCreateOrConnectWithoutCollectionInput[]
    createMany?: collection_historyCreateManyCollectionInputEnvelope
    connect?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
  }

  export type collection_previewCreateNestedOneWithoutCollectionInput = {
    create?: XOR<collection_previewCreateWithoutCollectionInput, collection_previewUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: collection_previewCreateOrConnectWithoutCollectionInput
    connect?: collection_previewWhereUniqueInput
  }

  export type collection_remixCreateNestedManyWithoutSource_collectionInput = {
    create?: XOR<collection_remixCreateWithoutSource_collectionInput, collection_remixUncheckedCreateWithoutSource_collectionInput> | collection_remixCreateWithoutSource_collectionInput[] | collection_remixUncheckedCreateWithoutSource_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutSource_collectionInput | collection_remixCreateOrConnectWithoutSource_collectionInput[]
    createMany?: collection_remixCreateManySource_collectionInputEnvelope
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
  }

  export type collection_remixCreateNestedManyWithoutTarget_collectionInput = {
    create?: XOR<collection_remixCreateWithoutTarget_collectionInput, collection_remixUncheckedCreateWithoutTarget_collectionInput> | collection_remixCreateWithoutTarget_collectionInput[] | collection_remixUncheckedCreateWithoutTarget_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutTarget_collectionInput | collection_remixCreateOrConnectWithoutTarget_collectionInput[]
    createMany?: collection_remixCreateManyTarget_collectionInputEnvelope
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
  }

  export type collection_sales_receiversCreateNestedManyWithoutCollectionInput = {
    create?: XOR<collection_sales_receiversCreateWithoutCollectionInput, collection_sales_receiversUncheckedCreateWithoutCollectionInput> | collection_sales_receiversCreateWithoutCollectionInput[] | collection_sales_receiversUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sales_receiversCreateOrConnectWithoutCollectionInput | collection_sales_receiversCreateOrConnectWithoutCollectionInput[]
    createMany?: collection_sales_receiversCreateManyCollectionInputEnvelope
    connect?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
  }

  export type collection_sample_imagesCreateNestedManyWithoutCollectionInput = {
    create?: XOR<collection_sample_imagesCreateWithoutCollectionInput, collection_sample_imagesUncheckedCreateWithoutCollectionInput> | collection_sample_imagesCreateWithoutCollectionInput[] | collection_sample_imagesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sample_imagesCreateOrConnectWithoutCollectionInput | collection_sample_imagesCreateOrConnectWithoutCollectionInput[]
    createMany?: collection_sample_imagesCreateManyCollectionInputEnvelope
    connect?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
  }

  export type componentCreateNestedManyWithoutCollectionInput = {
    create?: XOR<componentCreateWithoutCollectionInput, componentUncheckedCreateWithoutCollectionInput> | componentCreateWithoutCollectionInput[] | componentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: componentCreateOrConnectWithoutCollectionInput | componentCreateOrConnectWithoutCollectionInput[]
    createMany?: componentCreateManyCollectionInputEnvelope
    connect?: componentWhereUniqueInput | componentWhereUniqueInput[]
  }

  export type miniapp_collection_configCreateNestedOneWithoutCollectionInput = {
    create?: XOR<miniapp_collection_configCreateWithoutCollectionInput, miniapp_collection_configUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: miniapp_collection_configCreateOrConnectWithoutCollectionInput
    connect?: miniapp_collection_configWhereUniqueInput
  }

  export type miniapp_generationCreateNestedManyWithoutCollectionInput = {
    create?: XOR<miniapp_generationCreateWithoutCollectionInput, miniapp_generationUncheckedCreateWithoutCollectionInput> | miniapp_generationCreateWithoutCollectionInput[] | miniapp_generationUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutCollectionInput | miniapp_generationCreateOrConnectWithoutCollectionInput[]
    createMany?: miniapp_generationCreateManyCollectionInputEnvelope
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
  }

  export type miniapp_paymentCreateNestedManyWithoutCollectionInput = {
    create?: XOR<miniapp_paymentCreateWithoutCollectionInput, miniapp_paymentUncheckedCreateWithoutCollectionInput> | miniapp_paymentCreateWithoutCollectionInput[] | miniapp_paymentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutCollectionInput | miniapp_paymentCreateOrConnectWithoutCollectionInput[]
    createMany?: miniapp_paymentCreateManyCollectionInputEnvelope
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
  }

  export type collection_historyUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<collection_historyCreateWithoutCollectionInput, collection_historyUncheckedCreateWithoutCollectionInput> | collection_historyCreateWithoutCollectionInput[] | collection_historyUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_historyCreateOrConnectWithoutCollectionInput | collection_historyCreateOrConnectWithoutCollectionInput[]
    createMany?: collection_historyCreateManyCollectionInputEnvelope
    connect?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
  }

  export type collection_previewUncheckedCreateNestedOneWithoutCollectionInput = {
    create?: XOR<collection_previewCreateWithoutCollectionInput, collection_previewUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: collection_previewCreateOrConnectWithoutCollectionInput
    connect?: collection_previewWhereUniqueInput
  }

  export type collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput = {
    create?: XOR<collection_remixCreateWithoutSource_collectionInput, collection_remixUncheckedCreateWithoutSource_collectionInput> | collection_remixCreateWithoutSource_collectionInput[] | collection_remixUncheckedCreateWithoutSource_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutSource_collectionInput | collection_remixCreateOrConnectWithoutSource_collectionInput[]
    createMany?: collection_remixCreateManySource_collectionInputEnvelope
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
  }

  export type collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput = {
    create?: XOR<collection_remixCreateWithoutTarget_collectionInput, collection_remixUncheckedCreateWithoutTarget_collectionInput> | collection_remixCreateWithoutTarget_collectionInput[] | collection_remixUncheckedCreateWithoutTarget_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutTarget_collectionInput | collection_remixCreateOrConnectWithoutTarget_collectionInput[]
    createMany?: collection_remixCreateManyTarget_collectionInputEnvelope
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
  }

  export type collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<collection_sales_receiversCreateWithoutCollectionInput, collection_sales_receiversUncheckedCreateWithoutCollectionInput> | collection_sales_receiversCreateWithoutCollectionInput[] | collection_sales_receiversUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sales_receiversCreateOrConnectWithoutCollectionInput | collection_sales_receiversCreateOrConnectWithoutCollectionInput[]
    createMany?: collection_sales_receiversCreateManyCollectionInputEnvelope
    connect?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
  }

  export type collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<collection_sample_imagesCreateWithoutCollectionInput, collection_sample_imagesUncheckedCreateWithoutCollectionInput> | collection_sample_imagesCreateWithoutCollectionInput[] | collection_sample_imagesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sample_imagesCreateOrConnectWithoutCollectionInput | collection_sample_imagesCreateOrConnectWithoutCollectionInput[]
    createMany?: collection_sample_imagesCreateManyCollectionInputEnvelope
    connect?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
  }

  export type componentUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<componentCreateWithoutCollectionInput, componentUncheckedCreateWithoutCollectionInput> | componentCreateWithoutCollectionInput[] | componentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: componentCreateOrConnectWithoutCollectionInput | componentCreateOrConnectWithoutCollectionInput[]
    createMany?: componentCreateManyCollectionInputEnvelope
    connect?: componentWhereUniqueInput | componentWhereUniqueInput[]
  }

  export type miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput = {
    create?: XOR<miniapp_collection_configCreateWithoutCollectionInput, miniapp_collection_configUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: miniapp_collection_configCreateOrConnectWithoutCollectionInput
    connect?: miniapp_collection_configWhereUniqueInput
  }

  export type miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<miniapp_generationCreateWithoutCollectionInput, miniapp_generationUncheckedCreateWithoutCollectionInput> | miniapp_generationCreateWithoutCollectionInput[] | miniapp_generationUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutCollectionInput | miniapp_generationCreateOrConnectWithoutCollectionInput[]
    createMany?: miniapp_generationCreateManyCollectionInputEnvelope
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
  }

  export type miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<miniapp_paymentCreateWithoutCollectionInput, miniapp_paymentUncheckedCreateWithoutCollectionInput> | miniapp_paymentCreateWithoutCollectionInput[] | miniapp_paymentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutCollectionInput | miniapp_paymentCreateOrConnectWithoutCollectionInput[]
    createMany?: miniapp_paymentCreateManyCollectionInputEnvelope
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type social_linkUpdateOneWithoutCustodial_collectionsNestedInput = {
    create?: XOR<social_linkCreateWithoutCustodial_collectionsInput, social_linkUncheckedCreateWithoutCustodial_collectionsInput>
    connectOrCreate?: social_linkCreateOrConnectWithoutCustodial_collectionsInput
    upsert?: social_linkUpsertWithoutCustodial_collectionsInput
    disconnect?: social_linkWhereInput | boolean
    delete?: social_linkWhereInput | boolean
    connect?: social_linkWhereUniqueInput
    update?: XOR<XOR<social_linkUpdateToOneWithWhereWithoutCustodial_collectionsInput, social_linkUpdateWithoutCustodial_collectionsInput>, social_linkUncheckedUpdateWithoutCustodial_collectionsInput>
  }

  export type projectUpdateOneRequiredWithoutCollectionNestedInput = {
    create?: XOR<projectCreateWithoutCollectionInput, projectUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: projectCreateOrConnectWithoutCollectionInput
    upsert?: projectUpsertWithoutCollectionInput
    connect?: projectWhereUniqueInput
    update?: XOR<XOR<projectUpdateToOneWithWhereWithoutCollectionInput, projectUpdateWithoutCollectionInput>, projectUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_historyUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<collection_historyCreateWithoutCollectionInput, collection_historyUncheckedCreateWithoutCollectionInput> | collection_historyCreateWithoutCollectionInput[] | collection_historyUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_historyCreateOrConnectWithoutCollectionInput | collection_historyCreateOrConnectWithoutCollectionInput[]
    upsert?: collection_historyUpsertWithWhereUniqueWithoutCollectionInput | collection_historyUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: collection_historyCreateManyCollectionInputEnvelope
    set?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    disconnect?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    delete?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    connect?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    update?: collection_historyUpdateWithWhereUniqueWithoutCollectionInput | collection_historyUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: collection_historyUpdateManyWithWhereWithoutCollectionInput | collection_historyUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: collection_historyScalarWhereInput | collection_historyScalarWhereInput[]
  }

  export type collection_previewUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<collection_previewCreateWithoutCollectionInput, collection_previewUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: collection_previewCreateOrConnectWithoutCollectionInput
    upsert?: collection_previewUpsertWithoutCollectionInput
    disconnect?: collection_previewWhereInput | boolean
    delete?: collection_previewWhereInput | boolean
    connect?: collection_previewWhereUniqueInput
    update?: XOR<XOR<collection_previewUpdateToOneWithWhereWithoutCollectionInput, collection_previewUpdateWithoutCollectionInput>, collection_previewUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_remixUpdateManyWithoutSource_collectionNestedInput = {
    create?: XOR<collection_remixCreateWithoutSource_collectionInput, collection_remixUncheckedCreateWithoutSource_collectionInput> | collection_remixCreateWithoutSource_collectionInput[] | collection_remixUncheckedCreateWithoutSource_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutSource_collectionInput | collection_remixCreateOrConnectWithoutSource_collectionInput[]
    upsert?: collection_remixUpsertWithWhereUniqueWithoutSource_collectionInput | collection_remixUpsertWithWhereUniqueWithoutSource_collectionInput[]
    createMany?: collection_remixCreateManySource_collectionInputEnvelope
    set?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    disconnect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    delete?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    update?: collection_remixUpdateWithWhereUniqueWithoutSource_collectionInput | collection_remixUpdateWithWhereUniqueWithoutSource_collectionInput[]
    updateMany?: collection_remixUpdateManyWithWhereWithoutSource_collectionInput | collection_remixUpdateManyWithWhereWithoutSource_collectionInput[]
    deleteMany?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
  }

  export type collection_remixUpdateManyWithoutTarget_collectionNestedInput = {
    create?: XOR<collection_remixCreateWithoutTarget_collectionInput, collection_remixUncheckedCreateWithoutTarget_collectionInput> | collection_remixCreateWithoutTarget_collectionInput[] | collection_remixUncheckedCreateWithoutTarget_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutTarget_collectionInput | collection_remixCreateOrConnectWithoutTarget_collectionInput[]
    upsert?: collection_remixUpsertWithWhereUniqueWithoutTarget_collectionInput | collection_remixUpsertWithWhereUniqueWithoutTarget_collectionInput[]
    createMany?: collection_remixCreateManyTarget_collectionInputEnvelope
    set?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    disconnect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    delete?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    update?: collection_remixUpdateWithWhereUniqueWithoutTarget_collectionInput | collection_remixUpdateWithWhereUniqueWithoutTarget_collectionInput[]
    updateMany?: collection_remixUpdateManyWithWhereWithoutTarget_collectionInput | collection_remixUpdateManyWithWhereWithoutTarget_collectionInput[]
    deleteMany?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
  }

  export type collection_sales_receiversUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<collection_sales_receiversCreateWithoutCollectionInput, collection_sales_receiversUncheckedCreateWithoutCollectionInput> | collection_sales_receiversCreateWithoutCollectionInput[] | collection_sales_receiversUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sales_receiversCreateOrConnectWithoutCollectionInput | collection_sales_receiversCreateOrConnectWithoutCollectionInput[]
    upsert?: collection_sales_receiversUpsertWithWhereUniqueWithoutCollectionInput | collection_sales_receiversUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: collection_sales_receiversCreateManyCollectionInputEnvelope
    set?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    disconnect?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    delete?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    connect?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    update?: collection_sales_receiversUpdateWithWhereUniqueWithoutCollectionInput | collection_sales_receiversUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: collection_sales_receiversUpdateManyWithWhereWithoutCollectionInput | collection_sales_receiversUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: collection_sales_receiversScalarWhereInput | collection_sales_receiversScalarWhereInput[]
  }

  export type collection_sample_imagesUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<collection_sample_imagesCreateWithoutCollectionInput, collection_sample_imagesUncheckedCreateWithoutCollectionInput> | collection_sample_imagesCreateWithoutCollectionInput[] | collection_sample_imagesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sample_imagesCreateOrConnectWithoutCollectionInput | collection_sample_imagesCreateOrConnectWithoutCollectionInput[]
    upsert?: collection_sample_imagesUpsertWithWhereUniqueWithoutCollectionInput | collection_sample_imagesUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: collection_sample_imagesCreateManyCollectionInputEnvelope
    set?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    disconnect?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    delete?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    connect?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    update?: collection_sample_imagesUpdateWithWhereUniqueWithoutCollectionInput | collection_sample_imagesUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: collection_sample_imagesUpdateManyWithWhereWithoutCollectionInput | collection_sample_imagesUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: collection_sample_imagesScalarWhereInput | collection_sample_imagesScalarWhereInput[]
  }

  export type componentUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<componentCreateWithoutCollectionInput, componentUncheckedCreateWithoutCollectionInput> | componentCreateWithoutCollectionInput[] | componentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: componentCreateOrConnectWithoutCollectionInput | componentCreateOrConnectWithoutCollectionInput[]
    upsert?: componentUpsertWithWhereUniqueWithoutCollectionInput | componentUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: componentCreateManyCollectionInputEnvelope
    set?: componentWhereUniqueInput | componentWhereUniqueInput[]
    disconnect?: componentWhereUniqueInput | componentWhereUniqueInput[]
    delete?: componentWhereUniqueInput | componentWhereUniqueInput[]
    connect?: componentWhereUniqueInput | componentWhereUniqueInput[]
    update?: componentUpdateWithWhereUniqueWithoutCollectionInput | componentUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: componentUpdateManyWithWhereWithoutCollectionInput | componentUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: componentScalarWhereInput | componentScalarWhereInput[]
  }

  export type miniapp_collection_configUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<miniapp_collection_configCreateWithoutCollectionInput, miniapp_collection_configUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: miniapp_collection_configCreateOrConnectWithoutCollectionInput
    upsert?: miniapp_collection_configUpsertWithoutCollectionInput
    disconnect?: miniapp_collection_configWhereInput | boolean
    delete?: miniapp_collection_configWhereInput | boolean
    connect?: miniapp_collection_configWhereUniqueInput
    update?: XOR<XOR<miniapp_collection_configUpdateToOneWithWhereWithoutCollectionInput, miniapp_collection_configUpdateWithoutCollectionInput>, miniapp_collection_configUncheckedUpdateWithoutCollectionInput>
  }

  export type miniapp_generationUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<miniapp_generationCreateWithoutCollectionInput, miniapp_generationUncheckedCreateWithoutCollectionInput> | miniapp_generationCreateWithoutCollectionInput[] | miniapp_generationUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutCollectionInput | miniapp_generationCreateOrConnectWithoutCollectionInput[]
    upsert?: miniapp_generationUpsertWithWhereUniqueWithoutCollectionInput | miniapp_generationUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: miniapp_generationCreateManyCollectionInputEnvelope
    set?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    disconnect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    delete?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    update?: miniapp_generationUpdateWithWhereUniqueWithoutCollectionInput | miniapp_generationUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: miniapp_generationUpdateManyWithWhereWithoutCollectionInput | miniapp_generationUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
  }

  export type miniapp_paymentUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<miniapp_paymentCreateWithoutCollectionInput, miniapp_paymentUncheckedCreateWithoutCollectionInput> | miniapp_paymentCreateWithoutCollectionInput[] | miniapp_paymentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutCollectionInput | miniapp_paymentCreateOrConnectWithoutCollectionInput[]
    upsert?: miniapp_paymentUpsertWithWhereUniqueWithoutCollectionInput | miniapp_paymentUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: miniapp_paymentCreateManyCollectionInputEnvelope
    set?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    disconnect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    delete?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    update?: miniapp_paymentUpdateWithWhereUniqueWithoutCollectionInput | miniapp_paymentUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: miniapp_paymentUpdateManyWithWhereWithoutCollectionInput | miniapp_paymentUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: miniapp_paymentScalarWhereInput | miniapp_paymentScalarWhereInput[]
  }

  export type collection_historyUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<collection_historyCreateWithoutCollectionInput, collection_historyUncheckedCreateWithoutCollectionInput> | collection_historyCreateWithoutCollectionInput[] | collection_historyUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_historyCreateOrConnectWithoutCollectionInput | collection_historyCreateOrConnectWithoutCollectionInput[]
    upsert?: collection_historyUpsertWithWhereUniqueWithoutCollectionInput | collection_historyUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: collection_historyCreateManyCollectionInputEnvelope
    set?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    disconnect?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    delete?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    connect?: collection_historyWhereUniqueInput | collection_historyWhereUniqueInput[]
    update?: collection_historyUpdateWithWhereUniqueWithoutCollectionInput | collection_historyUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: collection_historyUpdateManyWithWhereWithoutCollectionInput | collection_historyUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: collection_historyScalarWhereInput | collection_historyScalarWhereInput[]
  }

  export type collection_previewUncheckedUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<collection_previewCreateWithoutCollectionInput, collection_previewUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: collection_previewCreateOrConnectWithoutCollectionInput
    upsert?: collection_previewUpsertWithoutCollectionInput
    disconnect?: collection_previewWhereInput | boolean
    delete?: collection_previewWhereInput | boolean
    connect?: collection_previewWhereUniqueInput
    update?: XOR<XOR<collection_previewUpdateToOneWithWhereWithoutCollectionInput, collection_previewUpdateWithoutCollectionInput>, collection_previewUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput = {
    create?: XOR<collection_remixCreateWithoutSource_collectionInput, collection_remixUncheckedCreateWithoutSource_collectionInput> | collection_remixCreateWithoutSource_collectionInput[] | collection_remixUncheckedCreateWithoutSource_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutSource_collectionInput | collection_remixCreateOrConnectWithoutSource_collectionInput[]
    upsert?: collection_remixUpsertWithWhereUniqueWithoutSource_collectionInput | collection_remixUpsertWithWhereUniqueWithoutSource_collectionInput[]
    createMany?: collection_remixCreateManySource_collectionInputEnvelope
    set?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    disconnect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    delete?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    update?: collection_remixUpdateWithWhereUniqueWithoutSource_collectionInput | collection_remixUpdateWithWhereUniqueWithoutSource_collectionInput[]
    updateMany?: collection_remixUpdateManyWithWhereWithoutSource_collectionInput | collection_remixUpdateManyWithWhereWithoutSource_collectionInput[]
    deleteMany?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
  }

  export type collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput = {
    create?: XOR<collection_remixCreateWithoutTarget_collectionInput, collection_remixUncheckedCreateWithoutTarget_collectionInput> | collection_remixCreateWithoutTarget_collectionInput[] | collection_remixUncheckedCreateWithoutTarget_collectionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutTarget_collectionInput | collection_remixCreateOrConnectWithoutTarget_collectionInput[]
    upsert?: collection_remixUpsertWithWhereUniqueWithoutTarget_collectionInput | collection_remixUpsertWithWhereUniqueWithoutTarget_collectionInput[]
    createMany?: collection_remixCreateManyTarget_collectionInputEnvelope
    set?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    disconnect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    delete?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    update?: collection_remixUpdateWithWhereUniqueWithoutTarget_collectionInput | collection_remixUpdateWithWhereUniqueWithoutTarget_collectionInput[]
    updateMany?: collection_remixUpdateManyWithWhereWithoutTarget_collectionInput | collection_remixUpdateManyWithWhereWithoutTarget_collectionInput[]
    deleteMany?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
  }

  export type collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<collection_sales_receiversCreateWithoutCollectionInput, collection_sales_receiversUncheckedCreateWithoutCollectionInput> | collection_sales_receiversCreateWithoutCollectionInput[] | collection_sales_receiversUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sales_receiversCreateOrConnectWithoutCollectionInput | collection_sales_receiversCreateOrConnectWithoutCollectionInput[]
    upsert?: collection_sales_receiversUpsertWithWhereUniqueWithoutCollectionInput | collection_sales_receiversUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: collection_sales_receiversCreateManyCollectionInputEnvelope
    set?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    disconnect?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    delete?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    connect?: collection_sales_receiversWhereUniqueInput | collection_sales_receiversWhereUniqueInput[]
    update?: collection_sales_receiversUpdateWithWhereUniqueWithoutCollectionInput | collection_sales_receiversUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: collection_sales_receiversUpdateManyWithWhereWithoutCollectionInput | collection_sales_receiversUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: collection_sales_receiversScalarWhereInput | collection_sales_receiversScalarWhereInput[]
  }

  export type collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<collection_sample_imagesCreateWithoutCollectionInput, collection_sample_imagesUncheckedCreateWithoutCollectionInput> | collection_sample_imagesCreateWithoutCollectionInput[] | collection_sample_imagesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: collection_sample_imagesCreateOrConnectWithoutCollectionInput | collection_sample_imagesCreateOrConnectWithoutCollectionInput[]
    upsert?: collection_sample_imagesUpsertWithWhereUniqueWithoutCollectionInput | collection_sample_imagesUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: collection_sample_imagesCreateManyCollectionInputEnvelope
    set?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    disconnect?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    delete?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    connect?: collection_sample_imagesWhereUniqueInput | collection_sample_imagesWhereUniqueInput[]
    update?: collection_sample_imagesUpdateWithWhereUniqueWithoutCollectionInput | collection_sample_imagesUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: collection_sample_imagesUpdateManyWithWhereWithoutCollectionInput | collection_sample_imagesUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: collection_sample_imagesScalarWhereInput | collection_sample_imagesScalarWhereInput[]
  }

  export type componentUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<componentCreateWithoutCollectionInput, componentUncheckedCreateWithoutCollectionInput> | componentCreateWithoutCollectionInput[] | componentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: componentCreateOrConnectWithoutCollectionInput | componentCreateOrConnectWithoutCollectionInput[]
    upsert?: componentUpsertWithWhereUniqueWithoutCollectionInput | componentUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: componentCreateManyCollectionInputEnvelope
    set?: componentWhereUniqueInput | componentWhereUniqueInput[]
    disconnect?: componentWhereUniqueInput | componentWhereUniqueInput[]
    delete?: componentWhereUniqueInput | componentWhereUniqueInput[]
    connect?: componentWhereUniqueInput | componentWhereUniqueInput[]
    update?: componentUpdateWithWhereUniqueWithoutCollectionInput | componentUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: componentUpdateManyWithWhereWithoutCollectionInput | componentUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: componentScalarWhereInput | componentScalarWhereInput[]
  }

  export type miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<miniapp_collection_configCreateWithoutCollectionInput, miniapp_collection_configUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: miniapp_collection_configCreateOrConnectWithoutCollectionInput
    upsert?: miniapp_collection_configUpsertWithoutCollectionInput
    disconnect?: miniapp_collection_configWhereInput | boolean
    delete?: miniapp_collection_configWhereInput | boolean
    connect?: miniapp_collection_configWhereUniqueInput
    update?: XOR<XOR<miniapp_collection_configUpdateToOneWithWhereWithoutCollectionInput, miniapp_collection_configUpdateWithoutCollectionInput>, miniapp_collection_configUncheckedUpdateWithoutCollectionInput>
  }

  export type miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<miniapp_generationCreateWithoutCollectionInput, miniapp_generationUncheckedCreateWithoutCollectionInput> | miniapp_generationCreateWithoutCollectionInput[] | miniapp_generationUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutCollectionInput | miniapp_generationCreateOrConnectWithoutCollectionInput[]
    upsert?: miniapp_generationUpsertWithWhereUniqueWithoutCollectionInput | miniapp_generationUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: miniapp_generationCreateManyCollectionInputEnvelope
    set?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    disconnect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    delete?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    update?: miniapp_generationUpdateWithWhereUniqueWithoutCollectionInput | miniapp_generationUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: miniapp_generationUpdateManyWithWhereWithoutCollectionInput | miniapp_generationUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
  }

  export type miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<miniapp_paymentCreateWithoutCollectionInput, miniapp_paymentUncheckedCreateWithoutCollectionInput> | miniapp_paymentCreateWithoutCollectionInput[] | miniapp_paymentUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutCollectionInput | miniapp_paymentCreateOrConnectWithoutCollectionInput[]
    upsert?: miniapp_paymentUpsertWithWhereUniqueWithoutCollectionInput | miniapp_paymentUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: miniapp_paymentCreateManyCollectionInputEnvelope
    set?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    disconnect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    delete?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    update?: miniapp_paymentUpdateWithWhereUniqueWithoutCollectionInput | miniapp_paymentUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: miniapp_paymentUpdateManyWithWhereWithoutCollectionInput | miniapp_paymentUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: miniapp_paymentScalarWhereInput | miniapp_paymentScalarWhereInput[]
  }

  export type collection_preview_versionCreateNestedOneWithoutCollection_remixInput = {
    create?: XOR<collection_preview_versionCreateWithoutCollection_remixInput, collection_preview_versionUncheckedCreateWithoutCollection_remixInput>
    connectOrCreate?: collection_preview_versionCreateOrConnectWithoutCollection_remixInput
    connect?: collection_preview_versionWhereUniqueInput
  }

  export type collectionCreateNestedOneWithoutSource_remixInput = {
    create?: XOR<collectionCreateWithoutSource_remixInput, collectionUncheckedCreateWithoutSource_remixInput>
    connectOrCreate?: collectionCreateOrConnectWithoutSource_remixInput
    connect?: collectionWhereUniqueInput
  }

  export type collectionCreateNestedOneWithoutTarget_remixInput = {
    create?: XOR<collectionCreateWithoutTarget_remixInput, collectionUncheckedCreateWithoutTarget_remixInput>
    connectOrCreate?: collectionCreateOrConnectWithoutTarget_remixInput
    connect?: collectionWhereUniqueInput
  }

  export type collection_preview_versionUpdateOneWithoutCollection_remixNestedInput = {
    create?: XOR<collection_preview_versionCreateWithoutCollection_remixInput, collection_preview_versionUncheckedCreateWithoutCollection_remixInput>
    connectOrCreate?: collection_preview_versionCreateOrConnectWithoutCollection_remixInput
    upsert?: collection_preview_versionUpsertWithoutCollection_remixInput
    disconnect?: collection_preview_versionWhereInput | boolean
    delete?: collection_preview_versionWhereInput | boolean
    connect?: collection_preview_versionWhereUniqueInput
    update?: XOR<XOR<collection_preview_versionUpdateToOneWithWhereWithoutCollection_remixInput, collection_preview_versionUpdateWithoutCollection_remixInput>, collection_preview_versionUncheckedUpdateWithoutCollection_remixInput>
  }

  export type collectionUpdateOneRequiredWithoutSource_remixNestedInput = {
    create?: XOR<collectionCreateWithoutSource_remixInput, collectionUncheckedCreateWithoutSource_remixInput>
    connectOrCreate?: collectionCreateOrConnectWithoutSource_remixInput
    upsert?: collectionUpsertWithoutSource_remixInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutSource_remixInput, collectionUpdateWithoutSource_remixInput>, collectionUncheckedUpdateWithoutSource_remixInput>
  }

  export type collectionUpdateOneRequiredWithoutTarget_remixNestedInput = {
    create?: XOR<collectionCreateWithoutTarget_remixInput, collectionUncheckedCreateWithoutTarget_remixInput>
    connectOrCreate?: collectionCreateOrConnectWithoutTarget_remixInput
    upsert?: collectionUpsertWithoutTarget_remixInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutTarget_remixInput, collectionUpdateWithoutTarget_remixInput>, collectionUncheckedUpdateWithoutTarget_remixInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type flat_fileCreatetagsInput = {
    set: string[]
  }

  export type chat_messageCreateNestedManyWithoutFlat_fileInput = {
    create?: XOR<chat_messageCreateWithoutFlat_fileInput, chat_messageUncheckedCreateWithoutFlat_fileInput> | chat_messageCreateWithoutFlat_fileInput[] | chat_messageUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutFlat_fileInput | chat_messageCreateOrConnectWithoutFlat_fileInput[]
    createMany?: chat_messageCreateManyFlat_fileInputEnvelope
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
  }

  export type component_flat_fileCreateNestedManyWithoutFlat_fileInput = {
    create?: XOR<component_flat_fileCreateWithoutFlat_fileInput, component_flat_fileUncheckedCreateWithoutFlat_fileInput> | component_flat_fileCreateWithoutFlat_fileInput[] | component_flat_fileUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutFlat_fileInput | component_flat_fileCreateOrConnectWithoutFlat_fileInput[]
    createMany?: component_flat_fileCreateManyFlat_fileInputEnvelope
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
  }

  export type chat_messageUncheckedCreateNestedManyWithoutFlat_fileInput = {
    create?: XOR<chat_messageCreateWithoutFlat_fileInput, chat_messageUncheckedCreateWithoutFlat_fileInput> | chat_messageCreateWithoutFlat_fileInput[] | chat_messageUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutFlat_fileInput | chat_messageCreateOrConnectWithoutFlat_fileInput[]
    createMany?: chat_messageCreateManyFlat_fileInputEnvelope
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
  }

  export type component_flat_fileUncheckedCreateNestedManyWithoutFlat_fileInput = {
    create?: XOR<component_flat_fileCreateWithoutFlat_fileInput, component_flat_fileUncheckedCreateWithoutFlat_fileInput> | component_flat_fileCreateWithoutFlat_fileInput[] | component_flat_fileUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutFlat_fileInput | component_flat_fileCreateOrConnectWithoutFlat_fileInput[]
    createMany?: component_flat_fileCreateManyFlat_fileInputEnvelope
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
  }

  export type flat_fileUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type chat_messageUpdateManyWithoutFlat_fileNestedInput = {
    create?: XOR<chat_messageCreateWithoutFlat_fileInput, chat_messageUncheckedCreateWithoutFlat_fileInput> | chat_messageCreateWithoutFlat_fileInput[] | chat_messageUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutFlat_fileInput | chat_messageCreateOrConnectWithoutFlat_fileInput[]
    upsert?: chat_messageUpsertWithWhereUniqueWithoutFlat_fileInput | chat_messageUpsertWithWhereUniqueWithoutFlat_fileInput[]
    createMany?: chat_messageCreateManyFlat_fileInputEnvelope
    set?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    disconnect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    delete?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    update?: chat_messageUpdateWithWhereUniqueWithoutFlat_fileInput | chat_messageUpdateWithWhereUniqueWithoutFlat_fileInput[]
    updateMany?: chat_messageUpdateManyWithWhereWithoutFlat_fileInput | chat_messageUpdateManyWithWhereWithoutFlat_fileInput[]
    deleteMany?: chat_messageScalarWhereInput | chat_messageScalarWhereInput[]
  }

  export type component_flat_fileUpdateManyWithoutFlat_fileNestedInput = {
    create?: XOR<component_flat_fileCreateWithoutFlat_fileInput, component_flat_fileUncheckedCreateWithoutFlat_fileInput> | component_flat_fileCreateWithoutFlat_fileInput[] | component_flat_fileUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutFlat_fileInput | component_flat_fileCreateOrConnectWithoutFlat_fileInput[]
    upsert?: component_flat_fileUpsertWithWhereUniqueWithoutFlat_fileInput | component_flat_fileUpsertWithWhereUniqueWithoutFlat_fileInput[]
    createMany?: component_flat_fileCreateManyFlat_fileInputEnvelope
    set?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    disconnect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    delete?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    update?: component_flat_fileUpdateWithWhereUniqueWithoutFlat_fileInput | component_flat_fileUpdateWithWhereUniqueWithoutFlat_fileInput[]
    updateMany?: component_flat_fileUpdateManyWithWhereWithoutFlat_fileInput | component_flat_fileUpdateManyWithWhereWithoutFlat_fileInput[]
    deleteMany?: component_flat_fileScalarWhereInput | component_flat_fileScalarWhereInput[]
  }

  export type chat_messageUncheckedUpdateManyWithoutFlat_fileNestedInput = {
    create?: XOR<chat_messageCreateWithoutFlat_fileInput, chat_messageUncheckedCreateWithoutFlat_fileInput> | chat_messageCreateWithoutFlat_fileInput[] | chat_messageUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutFlat_fileInput | chat_messageCreateOrConnectWithoutFlat_fileInput[]
    upsert?: chat_messageUpsertWithWhereUniqueWithoutFlat_fileInput | chat_messageUpsertWithWhereUniqueWithoutFlat_fileInput[]
    createMany?: chat_messageCreateManyFlat_fileInputEnvelope
    set?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    disconnect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    delete?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    update?: chat_messageUpdateWithWhereUniqueWithoutFlat_fileInput | chat_messageUpdateWithWhereUniqueWithoutFlat_fileInput[]
    updateMany?: chat_messageUpdateManyWithWhereWithoutFlat_fileInput | chat_messageUpdateManyWithWhereWithoutFlat_fileInput[]
    deleteMany?: chat_messageScalarWhereInput | chat_messageScalarWhereInput[]
  }

  export type component_flat_fileUncheckedUpdateManyWithoutFlat_fileNestedInput = {
    create?: XOR<component_flat_fileCreateWithoutFlat_fileInput, component_flat_fileUncheckedCreateWithoutFlat_fileInput> | component_flat_fileCreateWithoutFlat_fileInput[] | component_flat_fileUncheckedCreateWithoutFlat_fileInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutFlat_fileInput | component_flat_fileCreateOrConnectWithoutFlat_fileInput[]
    upsert?: component_flat_fileUpsertWithWhereUniqueWithoutFlat_fileInput | component_flat_fileUpsertWithWhereUniqueWithoutFlat_fileInput[]
    createMany?: component_flat_fileCreateManyFlat_fileInputEnvelope
    set?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    disconnect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    delete?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    update?: component_flat_fileUpdateWithWhereUniqueWithoutFlat_fileInput | component_flat_fileUpdateWithWhereUniqueWithoutFlat_fileInput[]
    updateMany?: component_flat_fileUpdateManyWithWhereWithoutFlat_fileInput | component_flat_fileUpdateManyWithWhereWithoutFlat_fileInput[]
    deleteMany?: component_flat_fileScalarWhereInput | component_flat_fileScalarWhereInput[]
  }

  export type componentCreateNestedOneWithoutComponent_flat_filesInput = {
    create?: XOR<componentCreateWithoutComponent_flat_filesInput, componentUncheckedCreateWithoutComponent_flat_filesInput>
    connectOrCreate?: componentCreateOrConnectWithoutComponent_flat_filesInput
    connect?: componentWhereUniqueInput
  }

  export type flat_fileCreateNestedOneWithoutComponent_flat_filesInput = {
    create?: XOR<flat_fileCreateWithoutComponent_flat_filesInput, flat_fileUncheckedCreateWithoutComponent_flat_filesInput>
    connectOrCreate?: flat_fileCreateOrConnectWithoutComponent_flat_filesInput
    connect?: flat_fileWhereUniqueInput
  }

  export type componentUpdateOneRequiredWithoutComponent_flat_filesNestedInput = {
    create?: XOR<componentCreateWithoutComponent_flat_filesInput, componentUncheckedCreateWithoutComponent_flat_filesInput>
    connectOrCreate?: componentCreateOrConnectWithoutComponent_flat_filesInput
    upsert?: componentUpsertWithoutComponent_flat_filesInput
    connect?: componentWhereUniqueInput
    update?: XOR<XOR<componentUpdateToOneWithWhereWithoutComponent_flat_filesInput, componentUpdateWithoutComponent_flat_filesInput>, componentUncheckedUpdateWithoutComponent_flat_filesInput>
  }

  export type flat_fileUpdateOneRequiredWithoutComponent_flat_filesNestedInput = {
    create?: XOR<flat_fileCreateWithoutComponent_flat_filesInput, flat_fileUncheckedCreateWithoutComponent_flat_filesInput>
    connectOrCreate?: flat_fileCreateOrConnectWithoutComponent_flat_filesInput
    upsert?: flat_fileUpsertWithoutComponent_flat_filesInput
    connect?: flat_fileWhereUniqueInput
    update?: XOR<XOR<flat_fileUpdateToOneWithWhereWithoutComponent_flat_filesInput, flat_fileUpdateWithoutComponent_flat_filesInput>, flat_fileUncheckedUpdateWithoutComponent_flat_filesInput>
  }

  export type collectionCreateNestedManyWithoutProjectInput = {
    create?: XOR<collectionCreateWithoutProjectInput, collectionUncheckedCreateWithoutProjectInput> | collectionCreateWithoutProjectInput[] | collectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutProjectInput | collectionCreateOrConnectWithoutProjectInput[]
    createMany?: collectionCreateManyProjectInputEnvelope
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
  }

  export type collectionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<collectionCreateWithoutProjectInput, collectionUncheckedCreateWithoutProjectInput> | collectionCreateWithoutProjectInput[] | collectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutProjectInput | collectionCreateOrConnectWithoutProjectInput[]
    createMany?: collectionCreateManyProjectInputEnvelope
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
  }

  export type collectionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<collectionCreateWithoutProjectInput, collectionUncheckedCreateWithoutProjectInput> | collectionCreateWithoutProjectInput[] | collectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutProjectInput | collectionCreateOrConnectWithoutProjectInput[]
    upsert?: collectionUpsertWithWhereUniqueWithoutProjectInput | collectionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: collectionCreateManyProjectInputEnvelope
    set?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    disconnect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    delete?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    update?: collectionUpdateWithWhereUniqueWithoutProjectInput | collectionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: collectionUpdateManyWithWhereWithoutProjectInput | collectionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: collectionScalarWhereInput | collectionScalarWhereInput[]
  }

  export type collectionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<collectionCreateWithoutProjectInput, collectionUncheckedCreateWithoutProjectInput> | collectionCreateWithoutProjectInput[] | collectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutProjectInput | collectionCreateOrConnectWithoutProjectInput[]
    upsert?: collectionUpsertWithWhereUniqueWithoutProjectInput | collectionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: collectionCreateManyProjectInputEnvelope
    set?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    disconnect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    delete?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    update?: collectionUpdateWithWhereUniqueWithoutProjectInput | collectionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: collectionUpdateManyWithWhereWithoutProjectInput | collectionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: collectionScalarWhereInput | collectionScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type project_template_saveCreateNestedManyWithoutProject_templateInput = {
    create?: XOR<project_template_saveCreateWithoutProject_templateInput, project_template_saveUncheckedCreateWithoutProject_templateInput> | project_template_saveCreateWithoutProject_templateInput[] | project_template_saveUncheckedCreateWithoutProject_templateInput[]
    connectOrCreate?: project_template_saveCreateOrConnectWithoutProject_templateInput | project_template_saveCreateOrConnectWithoutProject_templateInput[]
    createMany?: project_template_saveCreateManyProject_templateInputEnvelope
    connect?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
  }

  export type project_template_saveUncheckedCreateNestedManyWithoutProject_templateInput = {
    create?: XOR<project_template_saveCreateWithoutProject_templateInput, project_template_saveUncheckedCreateWithoutProject_templateInput> | project_template_saveCreateWithoutProject_templateInput[] | project_template_saveUncheckedCreateWithoutProject_templateInput[]
    connectOrCreate?: project_template_saveCreateOrConnectWithoutProject_templateInput | project_template_saveCreateOrConnectWithoutProject_templateInput[]
    createMany?: project_template_saveCreateManyProject_templateInputEnvelope
    connect?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
  }

  export type project_template_saveUpdateManyWithoutProject_templateNestedInput = {
    create?: XOR<project_template_saveCreateWithoutProject_templateInput, project_template_saveUncheckedCreateWithoutProject_templateInput> | project_template_saveCreateWithoutProject_templateInput[] | project_template_saveUncheckedCreateWithoutProject_templateInput[]
    connectOrCreate?: project_template_saveCreateOrConnectWithoutProject_templateInput | project_template_saveCreateOrConnectWithoutProject_templateInput[]
    upsert?: project_template_saveUpsertWithWhereUniqueWithoutProject_templateInput | project_template_saveUpsertWithWhereUniqueWithoutProject_templateInput[]
    createMany?: project_template_saveCreateManyProject_templateInputEnvelope
    set?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    disconnect?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    delete?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    connect?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    update?: project_template_saveUpdateWithWhereUniqueWithoutProject_templateInput | project_template_saveUpdateWithWhereUniqueWithoutProject_templateInput[]
    updateMany?: project_template_saveUpdateManyWithWhereWithoutProject_templateInput | project_template_saveUpdateManyWithWhereWithoutProject_templateInput[]
    deleteMany?: project_template_saveScalarWhereInput | project_template_saveScalarWhereInput[]
  }

  export type project_template_saveUncheckedUpdateManyWithoutProject_templateNestedInput = {
    create?: XOR<project_template_saveCreateWithoutProject_templateInput, project_template_saveUncheckedCreateWithoutProject_templateInput> | project_template_saveCreateWithoutProject_templateInput[] | project_template_saveUncheckedCreateWithoutProject_templateInput[]
    connectOrCreate?: project_template_saveCreateOrConnectWithoutProject_templateInput | project_template_saveCreateOrConnectWithoutProject_templateInput[]
    upsert?: project_template_saveUpsertWithWhereUniqueWithoutProject_templateInput | project_template_saveUpsertWithWhereUniqueWithoutProject_templateInput[]
    createMany?: project_template_saveCreateManyProject_templateInputEnvelope
    set?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    disconnect?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    delete?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    connect?: project_template_saveWhereUniqueInput | project_template_saveWhereUniqueInput[]
    update?: project_template_saveUpdateWithWhereUniqueWithoutProject_templateInput | project_template_saveUpdateWithWhereUniqueWithoutProject_templateInput[]
    updateMany?: project_template_saveUpdateManyWithWhereWithoutProject_templateInput | project_template_saveUpdateManyWithWhereWithoutProject_templateInput[]
    deleteMany?: project_template_saveScalarWhereInput | project_template_saveScalarWhereInput[]
  }

  export type project_templateCreateNestedOneWithoutProject_template_saveInput = {
    create?: XOR<project_templateCreateWithoutProject_template_saveInput, project_templateUncheckedCreateWithoutProject_template_saveInput>
    connectOrCreate?: project_templateCreateOrConnectWithoutProject_template_saveInput
    connect?: project_templateWhereUniqueInput
  }

  export type project_templateUpdateOneRequiredWithoutProject_template_saveNestedInput = {
    create?: XOR<project_templateCreateWithoutProject_template_saveInput, project_templateUncheckedCreateWithoutProject_template_saveInput>
    connectOrCreate?: project_templateCreateOrConnectWithoutProject_template_saveInput
    upsert?: project_templateUpsertWithoutProject_template_saveInput
    connect?: project_templateWhereUniqueInput
    update?: XOR<XOR<project_templateUpdateToOneWithWhereWithoutProject_template_saveInput, project_templateUpdateWithoutProject_template_saveInput>, project_templateUncheckedUpdateWithoutProject_template_saveInput>
  }

  export type collection_reward_redemptionCreateNestedManyWithoutCollection_rewardInput = {
    create?: XOR<collection_reward_redemptionCreateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput> | collection_reward_redemptionCreateWithoutCollection_rewardInput[] | collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput[]
    connectOrCreate?: collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput | collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput[]
    createMany?: collection_reward_redemptionCreateManyCollection_rewardInputEnvelope
    connect?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
  }

  export type collection_reward_redemptionUncheckedCreateNestedManyWithoutCollection_rewardInput = {
    create?: XOR<collection_reward_redemptionCreateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput> | collection_reward_redemptionCreateWithoutCollection_rewardInput[] | collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput[]
    connectOrCreate?: collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput | collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput[]
    createMany?: collection_reward_redemptionCreateManyCollection_rewardInputEnvelope
    connect?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
  }

  export type collection_reward_redemptionUpdateManyWithoutCollection_rewardNestedInput = {
    create?: XOR<collection_reward_redemptionCreateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput> | collection_reward_redemptionCreateWithoutCollection_rewardInput[] | collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput[]
    connectOrCreate?: collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput | collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput[]
    upsert?: collection_reward_redemptionUpsertWithWhereUniqueWithoutCollection_rewardInput | collection_reward_redemptionUpsertWithWhereUniqueWithoutCollection_rewardInput[]
    createMany?: collection_reward_redemptionCreateManyCollection_rewardInputEnvelope
    set?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    disconnect?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    delete?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    connect?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    update?: collection_reward_redemptionUpdateWithWhereUniqueWithoutCollection_rewardInput | collection_reward_redemptionUpdateWithWhereUniqueWithoutCollection_rewardInput[]
    updateMany?: collection_reward_redemptionUpdateManyWithWhereWithoutCollection_rewardInput | collection_reward_redemptionUpdateManyWithWhereWithoutCollection_rewardInput[]
    deleteMany?: collection_reward_redemptionScalarWhereInput | collection_reward_redemptionScalarWhereInput[]
  }

  export type collection_reward_redemptionUncheckedUpdateManyWithoutCollection_rewardNestedInput = {
    create?: XOR<collection_reward_redemptionCreateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput> | collection_reward_redemptionCreateWithoutCollection_rewardInput[] | collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput[]
    connectOrCreate?: collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput | collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput[]
    upsert?: collection_reward_redemptionUpsertWithWhereUniqueWithoutCollection_rewardInput | collection_reward_redemptionUpsertWithWhereUniqueWithoutCollection_rewardInput[]
    createMany?: collection_reward_redemptionCreateManyCollection_rewardInputEnvelope
    set?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    disconnect?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    delete?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    connect?: collection_reward_redemptionWhereUniqueInput | collection_reward_redemptionWhereUniqueInput[]
    update?: collection_reward_redemptionUpdateWithWhereUniqueWithoutCollection_rewardInput | collection_reward_redemptionUpdateWithWhereUniqueWithoutCollection_rewardInput[]
    updateMany?: collection_reward_redemptionUpdateManyWithWhereWithoutCollection_rewardInput | collection_reward_redemptionUpdateManyWithWhereWithoutCollection_rewardInput[]
    deleteMany?: collection_reward_redemptionScalarWhereInput | collection_reward_redemptionScalarWhereInput[]
  }

  export type collection_rewardCreateNestedOneWithoutCollection_reward_redemptionInput = {
    create?: XOR<collection_rewardCreateWithoutCollection_reward_redemptionInput, collection_rewardUncheckedCreateWithoutCollection_reward_redemptionInput>
    connectOrCreate?: collection_rewardCreateOrConnectWithoutCollection_reward_redemptionInput
    connect?: collection_rewardWhereUniqueInput
  }

  export type collection_rewardUpdateOneRequiredWithoutCollection_reward_redemptionNestedInput = {
    create?: XOR<collection_rewardCreateWithoutCollection_reward_redemptionInput, collection_rewardUncheckedCreateWithoutCollection_reward_redemptionInput>
    connectOrCreate?: collection_rewardCreateOrConnectWithoutCollection_reward_redemptionInput
    upsert?: collection_rewardUpsertWithoutCollection_reward_redemptionInput
    connect?: collection_rewardWhereUniqueInput
    update?: XOR<XOR<collection_rewardUpdateToOneWithWhereWithoutCollection_reward_redemptionInput, collection_rewardUpdateWithoutCollection_reward_redemptionInput>, collection_rewardUncheckedUpdateWithoutCollection_reward_redemptionInput>
  }

  export type collectionCreateNestedOneWithoutCollection_sales_receiversInput = {
    create?: XOR<collectionCreateWithoutCollection_sales_receiversInput, collectionUncheckedCreateWithoutCollection_sales_receiversInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_sales_receiversInput
    connect?: collectionWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type collectionUpdateOneRequiredWithoutCollection_sales_receiversNestedInput = {
    create?: XOR<collectionCreateWithoutCollection_sales_receiversInput, collectionUncheckedCreateWithoutCollection_sales_receiversInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_sales_receiversInput
    upsert?: collectionUpsertWithoutCollection_sales_receiversInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutCollection_sales_receiversInput, collectionUpdateWithoutCollection_sales_receiversInput>, collectionUncheckedUpdateWithoutCollection_sales_receiversInput>
  }

  export type collectionCreateNestedOneWithoutCollection_historyInput = {
    create?: XOR<collectionCreateWithoutCollection_historyInput, collectionUncheckedCreateWithoutCollection_historyInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_historyInput
    connect?: collectionWhereUniqueInput
  }

  export type collectionUpdateOneRequiredWithoutCollection_historyNestedInput = {
    create?: XOR<collectionCreateWithoutCollection_historyInput, collectionUncheckedCreateWithoutCollection_historyInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_historyInput
    upsert?: collectionUpsertWithoutCollection_historyInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutCollection_historyInput, collectionUpdateWithoutCollection_historyInput>, collectionUncheckedUpdateWithoutCollection_historyInput>
  }

  export type collectionCreateNestedOneWithoutCollection_previewInput = {
    create?: XOR<collectionCreateWithoutCollection_previewInput, collectionUncheckedCreateWithoutCollection_previewInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_previewInput
    connect?: collectionWhereUniqueInput
  }

  export type collection_preview_versionCreateNestedManyWithoutCollection_previewInput = {
    create?: XOR<collection_preview_versionCreateWithoutCollection_previewInput, collection_preview_versionUncheckedCreateWithoutCollection_previewInput> | collection_preview_versionCreateWithoutCollection_previewInput[] | collection_preview_versionUncheckedCreateWithoutCollection_previewInput[]
    connectOrCreate?: collection_preview_versionCreateOrConnectWithoutCollection_previewInput | collection_preview_versionCreateOrConnectWithoutCollection_previewInput[]
    createMany?: collection_preview_versionCreateManyCollection_previewInputEnvelope
    connect?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
  }

  export type collection_preview_versionUncheckedCreateNestedManyWithoutCollection_previewInput = {
    create?: XOR<collection_preview_versionCreateWithoutCollection_previewInput, collection_preview_versionUncheckedCreateWithoutCollection_previewInput> | collection_preview_versionCreateWithoutCollection_previewInput[] | collection_preview_versionUncheckedCreateWithoutCollection_previewInput[]
    connectOrCreate?: collection_preview_versionCreateOrConnectWithoutCollection_previewInput | collection_preview_versionCreateOrConnectWithoutCollection_previewInput[]
    createMany?: collection_preview_versionCreateManyCollection_previewInputEnvelope
    connect?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
  }

  export type collectionUpdateOneRequiredWithoutCollection_previewNestedInput = {
    create?: XOR<collectionCreateWithoutCollection_previewInput, collectionUncheckedCreateWithoutCollection_previewInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_previewInput
    upsert?: collectionUpsertWithoutCollection_previewInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutCollection_previewInput, collectionUpdateWithoutCollection_previewInput>, collectionUncheckedUpdateWithoutCollection_previewInput>
  }

  export type collection_preview_versionUpdateManyWithoutCollection_previewNestedInput = {
    create?: XOR<collection_preview_versionCreateWithoutCollection_previewInput, collection_preview_versionUncheckedCreateWithoutCollection_previewInput> | collection_preview_versionCreateWithoutCollection_previewInput[] | collection_preview_versionUncheckedCreateWithoutCollection_previewInput[]
    connectOrCreate?: collection_preview_versionCreateOrConnectWithoutCollection_previewInput | collection_preview_versionCreateOrConnectWithoutCollection_previewInput[]
    upsert?: collection_preview_versionUpsertWithWhereUniqueWithoutCollection_previewInput | collection_preview_versionUpsertWithWhereUniqueWithoutCollection_previewInput[]
    createMany?: collection_preview_versionCreateManyCollection_previewInputEnvelope
    set?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    disconnect?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    delete?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    connect?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    update?: collection_preview_versionUpdateWithWhereUniqueWithoutCollection_previewInput | collection_preview_versionUpdateWithWhereUniqueWithoutCollection_previewInput[]
    updateMany?: collection_preview_versionUpdateManyWithWhereWithoutCollection_previewInput | collection_preview_versionUpdateManyWithWhereWithoutCollection_previewInput[]
    deleteMany?: collection_preview_versionScalarWhereInput | collection_preview_versionScalarWhereInput[]
  }

  export type collection_preview_versionUncheckedUpdateManyWithoutCollection_previewNestedInput = {
    create?: XOR<collection_preview_versionCreateWithoutCollection_previewInput, collection_preview_versionUncheckedCreateWithoutCollection_previewInput> | collection_preview_versionCreateWithoutCollection_previewInput[] | collection_preview_versionUncheckedCreateWithoutCollection_previewInput[]
    connectOrCreate?: collection_preview_versionCreateOrConnectWithoutCollection_previewInput | collection_preview_versionCreateOrConnectWithoutCollection_previewInput[]
    upsert?: collection_preview_versionUpsertWithWhereUniqueWithoutCollection_previewInput | collection_preview_versionUpsertWithWhereUniqueWithoutCollection_previewInput[]
    createMany?: collection_preview_versionCreateManyCollection_previewInputEnvelope
    set?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    disconnect?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    delete?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    connect?: collection_preview_versionWhereUniqueInput | collection_preview_versionWhereUniqueInput[]
    update?: collection_preview_versionUpdateWithWhereUniqueWithoutCollection_previewInput | collection_preview_versionUpdateWithWhereUniqueWithoutCollection_previewInput[]
    updateMany?: collection_preview_versionUpdateManyWithWhereWithoutCollection_previewInput | collection_preview_versionUpdateManyWithWhereWithoutCollection_previewInput[]
    deleteMany?: collection_preview_versionScalarWhereInput | collection_preview_versionScalarWhereInput[]
  }

  export type collection_previewCreateNestedOneWithoutCollection_preview_versionInput = {
    create?: XOR<collection_previewCreateWithoutCollection_preview_versionInput, collection_previewUncheckedCreateWithoutCollection_preview_versionInput>
    connectOrCreate?: collection_previewCreateOrConnectWithoutCollection_preview_versionInput
    connect?: collection_previewWhereUniqueInput
  }

  export type collection_remixCreateNestedManyWithoutCollection_preview_versionInput = {
    create?: XOR<collection_remixCreateWithoutCollection_preview_versionInput, collection_remixUncheckedCreateWithoutCollection_preview_versionInput> | collection_remixCreateWithoutCollection_preview_versionInput[] | collection_remixUncheckedCreateWithoutCollection_preview_versionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutCollection_preview_versionInput | collection_remixCreateOrConnectWithoutCollection_preview_versionInput[]
    createMany?: collection_remixCreateManyCollection_preview_versionInputEnvelope
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
  }

  export type collection_remixUncheckedCreateNestedManyWithoutCollection_preview_versionInput = {
    create?: XOR<collection_remixCreateWithoutCollection_preview_versionInput, collection_remixUncheckedCreateWithoutCollection_preview_versionInput> | collection_remixCreateWithoutCollection_preview_versionInput[] | collection_remixUncheckedCreateWithoutCollection_preview_versionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutCollection_preview_versionInput | collection_remixCreateOrConnectWithoutCollection_preview_versionInput[]
    createMany?: collection_remixCreateManyCollection_preview_versionInputEnvelope
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
  }

  export type collection_previewUpdateOneRequiredWithoutCollection_preview_versionNestedInput = {
    create?: XOR<collection_previewCreateWithoutCollection_preview_versionInput, collection_previewUncheckedCreateWithoutCollection_preview_versionInput>
    connectOrCreate?: collection_previewCreateOrConnectWithoutCollection_preview_versionInput
    upsert?: collection_previewUpsertWithoutCollection_preview_versionInput
    connect?: collection_previewWhereUniqueInput
    update?: XOR<XOR<collection_previewUpdateToOneWithWhereWithoutCollection_preview_versionInput, collection_previewUpdateWithoutCollection_preview_versionInput>, collection_previewUncheckedUpdateWithoutCollection_preview_versionInput>
  }

  export type collection_remixUpdateManyWithoutCollection_preview_versionNestedInput = {
    create?: XOR<collection_remixCreateWithoutCollection_preview_versionInput, collection_remixUncheckedCreateWithoutCollection_preview_versionInput> | collection_remixCreateWithoutCollection_preview_versionInput[] | collection_remixUncheckedCreateWithoutCollection_preview_versionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutCollection_preview_versionInput | collection_remixCreateOrConnectWithoutCollection_preview_versionInput[]
    upsert?: collection_remixUpsertWithWhereUniqueWithoutCollection_preview_versionInput | collection_remixUpsertWithWhereUniqueWithoutCollection_preview_versionInput[]
    createMany?: collection_remixCreateManyCollection_preview_versionInputEnvelope
    set?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    disconnect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    delete?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    update?: collection_remixUpdateWithWhereUniqueWithoutCollection_preview_versionInput | collection_remixUpdateWithWhereUniqueWithoutCollection_preview_versionInput[]
    updateMany?: collection_remixUpdateManyWithWhereWithoutCollection_preview_versionInput | collection_remixUpdateManyWithWhereWithoutCollection_preview_versionInput[]
    deleteMany?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
  }

  export type collection_remixUncheckedUpdateManyWithoutCollection_preview_versionNestedInput = {
    create?: XOR<collection_remixCreateWithoutCollection_preview_versionInput, collection_remixUncheckedCreateWithoutCollection_preview_versionInput> | collection_remixCreateWithoutCollection_preview_versionInput[] | collection_remixUncheckedCreateWithoutCollection_preview_versionInput[]
    connectOrCreate?: collection_remixCreateOrConnectWithoutCollection_preview_versionInput | collection_remixCreateOrConnectWithoutCollection_preview_versionInput[]
    upsert?: collection_remixUpsertWithWhereUniqueWithoutCollection_preview_versionInput | collection_remixUpsertWithWhereUniqueWithoutCollection_preview_versionInput[]
    createMany?: collection_remixCreateManyCollection_preview_versionInputEnvelope
    set?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    disconnect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    delete?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    connect?: collection_remixWhereUniqueInput | collection_remixWhereUniqueInput[]
    update?: collection_remixUpdateWithWhereUniqueWithoutCollection_preview_versionInput | collection_remixUpdateWithWhereUniqueWithoutCollection_preview_versionInput[]
    updateMany?: collection_remixUpdateManyWithWhereWithoutCollection_preview_versionInput | collection_remixUpdateManyWithWhereWithoutCollection_preview_versionInput[]
    deleteMany?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
  }

  export type collectionCreateNestedOneWithoutCollection_sample_imagesInput = {
    create?: XOR<collectionCreateWithoutCollection_sample_imagesInput, collectionUncheckedCreateWithoutCollection_sample_imagesInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_sample_imagesInput
    connect?: collectionWhereUniqueInput
  }

  export type collectionUpdateOneRequiredWithoutCollection_sample_imagesNestedInput = {
    create?: XOR<collectionCreateWithoutCollection_sample_imagesInput, collectionUncheckedCreateWithoutCollection_sample_imagesInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_sample_imagesInput
    upsert?: collectionUpsertWithoutCollection_sample_imagesInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutCollection_sample_imagesInput, collectionUpdateWithoutCollection_sample_imagesInput>, collectionUncheckedUpdateWithoutCollection_sample_imagesInput>
  }

  export type chat_messageCreateNestedManyWithoutChatInput = {
    create?: XOR<chat_messageCreateWithoutChatInput, chat_messageUncheckedCreateWithoutChatInput> | chat_messageCreateWithoutChatInput[] | chat_messageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutChatInput | chat_messageCreateOrConnectWithoutChatInput[]
    createMany?: chat_messageCreateManyChatInputEnvelope
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
  }

  export type chat_messageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<chat_messageCreateWithoutChatInput, chat_messageUncheckedCreateWithoutChatInput> | chat_messageCreateWithoutChatInput[] | chat_messageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutChatInput | chat_messageCreateOrConnectWithoutChatInput[]
    createMany?: chat_messageCreateManyChatInputEnvelope
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
  }

  export type chat_messageUpdateManyWithoutChatNestedInput = {
    create?: XOR<chat_messageCreateWithoutChatInput, chat_messageUncheckedCreateWithoutChatInput> | chat_messageCreateWithoutChatInput[] | chat_messageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutChatInput | chat_messageCreateOrConnectWithoutChatInput[]
    upsert?: chat_messageUpsertWithWhereUniqueWithoutChatInput | chat_messageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: chat_messageCreateManyChatInputEnvelope
    set?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    disconnect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    delete?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    update?: chat_messageUpdateWithWhereUniqueWithoutChatInput | chat_messageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: chat_messageUpdateManyWithWhereWithoutChatInput | chat_messageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: chat_messageScalarWhereInput | chat_messageScalarWhereInput[]
  }

  export type chat_messageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<chat_messageCreateWithoutChatInput, chat_messageUncheckedCreateWithoutChatInput> | chat_messageCreateWithoutChatInput[] | chat_messageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: chat_messageCreateOrConnectWithoutChatInput | chat_messageCreateOrConnectWithoutChatInput[]
    upsert?: chat_messageUpsertWithWhereUniqueWithoutChatInput | chat_messageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: chat_messageCreateManyChatInputEnvelope
    set?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    disconnect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    delete?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    connect?: chat_messageWhereUniqueInput | chat_messageWhereUniqueInput[]
    update?: chat_messageUpdateWithWhereUniqueWithoutChatInput | chat_messageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: chat_messageUpdateManyWithWhereWithoutChatInput | chat_messageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: chat_messageScalarWhereInput | chat_messageScalarWhereInput[]
  }

  export type chatCreateNestedOneWithoutChat_messageInput = {
    create?: XOR<chatCreateWithoutChat_messageInput, chatUncheckedCreateWithoutChat_messageInput>
    connectOrCreate?: chatCreateOrConnectWithoutChat_messageInput
    connect?: chatWhereUniqueInput
  }

  export type flat_fileCreateNestedOneWithoutChat_messageInput = {
    create?: XOR<flat_fileCreateWithoutChat_messageInput, flat_fileUncheckedCreateWithoutChat_messageInput>
    connectOrCreate?: flat_fileCreateOrConnectWithoutChat_messageInput
    connect?: flat_fileWhereUniqueInput
  }

  export type chatUpdateOneRequiredWithoutChat_messageNestedInput = {
    create?: XOR<chatCreateWithoutChat_messageInput, chatUncheckedCreateWithoutChat_messageInput>
    connectOrCreate?: chatCreateOrConnectWithoutChat_messageInput
    upsert?: chatUpsertWithoutChat_messageInput
    connect?: chatWhereUniqueInput
    update?: XOR<XOR<chatUpdateToOneWithWhereWithoutChat_messageInput, chatUpdateWithoutChat_messageInput>, chatUncheckedUpdateWithoutChat_messageInput>
  }

  export type flat_fileUpdateOneWithoutChat_messageNestedInput = {
    create?: XOR<flat_fileCreateWithoutChat_messageInput, flat_fileUncheckedCreateWithoutChat_messageInput>
    connectOrCreate?: flat_fileCreateOrConnectWithoutChat_messageInput
    upsert?: flat_fileUpsertWithoutChat_messageInput
    disconnect?: flat_fileWhereInput | boolean
    delete?: flat_fileWhereInput | boolean
    connect?: flat_fileWhereUniqueInput
    update?: XOR<XOR<flat_fileUpdateToOneWithWhereWithoutChat_messageInput, flat_fileUpdateWithoutChat_messageInput>, flat_fileUncheckedUpdateWithoutChat_messageInput>
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type collectionCreateNestedOneWithoutCollection_nodeInput = {
    create?: XOR<collectionCreateWithoutCollection_nodeInput, collectionUncheckedCreateWithoutCollection_nodeInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_nodeInput
    connect?: collectionWhereUniqueInput
  }

  export type component_flat_fileCreateNestedManyWithoutComponentInput = {
    create?: XOR<component_flat_fileCreateWithoutComponentInput, component_flat_fileUncheckedCreateWithoutComponentInput> | component_flat_fileCreateWithoutComponentInput[] | component_flat_fileUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutComponentInput | component_flat_fileCreateOrConnectWithoutComponentInput[]
    createMany?: component_flat_fileCreateManyComponentInputEnvelope
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
  }

  export type component_flat_fileUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<component_flat_fileCreateWithoutComponentInput, component_flat_fileUncheckedCreateWithoutComponentInput> | component_flat_fileCreateWithoutComponentInput[] | component_flat_fileUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutComponentInput | component_flat_fileCreateOrConnectWithoutComponentInput[]
    createMany?: component_flat_fileCreateManyComponentInputEnvelope
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
  }

  export type collectionUpdateOneRequiredWithoutCollection_nodeNestedInput = {
    create?: XOR<collectionCreateWithoutCollection_nodeInput, collectionUncheckedCreateWithoutCollection_nodeInput>
    connectOrCreate?: collectionCreateOrConnectWithoutCollection_nodeInput
    upsert?: collectionUpsertWithoutCollection_nodeInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutCollection_nodeInput, collectionUpdateWithoutCollection_nodeInput>, collectionUncheckedUpdateWithoutCollection_nodeInput>
  }

  export type component_flat_fileUpdateManyWithoutComponentNestedInput = {
    create?: XOR<component_flat_fileCreateWithoutComponentInput, component_flat_fileUncheckedCreateWithoutComponentInput> | component_flat_fileCreateWithoutComponentInput[] | component_flat_fileUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutComponentInput | component_flat_fileCreateOrConnectWithoutComponentInput[]
    upsert?: component_flat_fileUpsertWithWhereUniqueWithoutComponentInput | component_flat_fileUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: component_flat_fileCreateManyComponentInputEnvelope
    set?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    disconnect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    delete?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    update?: component_flat_fileUpdateWithWhereUniqueWithoutComponentInput | component_flat_fileUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: component_flat_fileUpdateManyWithWhereWithoutComponentInput | component_flat_fileUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: component_flat_fileScalarWhereInput | component_flat_fileScalarWhereInput[]
  }

  export type component_flat_fileUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<component_flat_fileCreateWithoutComponentInput, component_flat_fileUncheckedCreateWithoutComponentInput> | component_flat_fileCreateWithoutComponentInput[] | component_flat_fileUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: component_flat_fileCreateOrConnectWithoutComponentInput | component_flat_fileCreateOrConnectWithoutComponentInput[]
    upsert?: component_flat_fileUpsertWithWhereUniqueWithoutComponentInput | component_flat_fileUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: component_flat_fileCreateManyComponentInputEnvelope
    set?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    disconnect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    delete?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    connect?: component_flat_fileWhereUniqueInput | component_flat_fileWhereUniqueInput[]
    update?: component_flat_fileUpdateWithWhereUniqueWithoutComponentInput | component_flat_fileUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: component_flat_fileUpdateManyWithWhereWithoutComponentInput | component_flat_fileUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: component_flat_fileScalarWhereInput | component_flat_fileScalarWhereInput[]
  }

  export type serverCreateNestedOneWithoutWorkflowInput = {
    create?: XOR<serverCreateWithoutWorkflowInput, serverUncheckedCreateWithoutWorkflowInput>
    connectOrCreate?: serverCreateOrConnectWithoutWorkflowInput
    connect?: serverWhereUniqueInput
  }

  export type workflow_custom_nodesCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutWorkflowInput, workflow_custom_nodesUncheckedCreateWithoutWorkflowInput> | workflow_custom_nodesCreateWithoutWorkflowInput[] | workflow_custom_nodesUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutWorkflowInput | workflow_custom_nodesCreateOrConnectWithoutWorkflowInput[]
    createMany?: workflow_custom_nodesCreateManyWorkflowInputEnvelope
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
  }

  export type WorkflowModelCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowModelCreateWithoutWorkflowInput, WorkflowModelUncheckedCreateWithoutWorkflowInput> | WorkflowModelCreateWithoutWorkflowInput[] | WorkflowModelUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutWorkflowInput | WorkflowModelCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowModelCreateManyWorkflowInputEnvelope
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
  }

  export type workflow_custom_nodesUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutWorkflowInput, workflow_custom_nodesUncheckedCreateWithoutWorkflowInput> | workflow_custom_nodesCreateWithoutWorkflowInput[] | workflow_custom_nodesUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutWorkflowInput | workflow_custom_nodesCreateOrConnectWithoutWorkflowInput[]
    createMany?: workflow_custom_nodesCreateManyWorkflowInputEnvelope
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
  }

  export type WorkflowModelUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowModelCreateWithoutWorkflowInput, WorkflowModelUncheckedCreateWithoutWorkflowInput> | WorkflowModelCreateWithoutWorkflowInput[] | WorkflowModelUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutWorkflowInput | WorkflowModelCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowModelCreateManyWorkflowInputEnvelope
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
  }

  export type serverUpdateOneWithoutWorkflowNestedInput = {
    create?: XOR<serverCreateWithoutWorkflowInput, serverUncheckedCreateWithoutWorkflowInput>
    connectOrCreate?: serverCreateOrConnectWithoutWorkflowInput
    upsert?: serverUpsertWithoutWorkflowInput
    disconnect?: serverWhereInput | boolean
    delete?: serverWhereInput | boolean
    connect?: serverWhereUniqueInput
    update?: XOR<XOR<serverUpdateToOneWithWhereWithoutWorkflowInput, serverUpdateWithoutWorkflowInput>, serverUncheckedUpdateWithoutWorkflowInput>
  }

  export type workflow_custom_nodesUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutWorkflowInput, workflow_custom_nodesUncheckedCreateWithoutWorkflowInput> | workflow_custom_nodesCreateWithoutWorkflowInput[] | workflow_custom_nodesUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutWorkflowInput | workflow_custom_nodesCreateOrConnectWithoutWorkflowInput[]
    upsert?: workflow_custom_nodesUpsertWithWhereUniqueWithoutWorkflowInput | workflow_custom_nodesUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: workflow_custom_nodesCreateManyWorkflowInputEnvelope
    set?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    disconnect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    delete?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    update?: workflow_custom_nodesUpdateWithWhereUniqueWithoutWorkflowInput | workflow_custom_nodesUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: workflow_custom_nodesUpdateManyWithWhereWithoutWorkflowInput | workflow_custom_nodesUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: workflow_custom_nodesScalarWhereInput | workflow_custom_nodesScalarWhereInput[]
  }

  export type WorkflowModelUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowModelCreateWithoutWorkflowInput, WorkflowModelUncheckedCreateWithoutWorkflowInput> | WorkflowModelCreateWithoutWorkflowInput[] | WorkflowModelUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutWorkflowInput | WorkflowModelCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowModelUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowModelUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowModelCreateManyWorkflowInputEnvelope
    set?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    disconnect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    delete?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    update?: WorkflowModelUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowModelUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowModelUpdateManyWithWhereWithoutWorkflowInput | WorkflowModelUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowModelScalarWhereInput | WorkflowModelScalarWhereInput[]
  }

  export type workflow_custom_nodesUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutWorkflowInput, workflow_custom_nodesUncheckedCreateWithoutWorkflowInput> | workflow_custom_nodesCreateWithoutWorkflowInput[] | workflow_custom_nodesUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutWorkflowInput | workflow_custom_nodesCreateOrConnectWithoutWorkflowInput[]
    upsert?: workflow_custom_nodesUpsertWithWhereUniqueWithoutWorkflowInput | workflow_custom_nodesUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: workflow_custom_nodesCreateManyWorkflowInputEnvelope
    set?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    disconnect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    delete?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    update?: workflow_custom_nodesUpdateWithWhereUniqueWithoutWorkflowInput | workflow_custom_nodesUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: workflow_custom_nodesUpdateManyWithWhereWithoutWorkflowInput | workflow_custom_nodesUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: workflow_custom_nodesScalarWhereInput | workflow_custom_nodesScalarWhereInput[]
  }

  export type WorkflowModelUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowModelCreateWithoutWorkflowInput, WorkflowModelUncheckedCreateWithoutWorkflowInput> | WorkflowModelCreateWithoutWorkflowInput[] | WorkflowModelUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutWorkflowInput | WorkflowModelCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowModelUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowModelUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowModelCreateManyWorkflowInputEnvelope
    set?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    disconnect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    delete?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    update?: WorkflowModelUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowModelUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowModelUpdateManyWithWhereWithoutWorkflowInput | WorkflowModelUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowModelScalarWhereInput | WorkflowModelScalarWhereInput[]
  }

  export type workflowCreateNestedManyWithoutServerInput = {
    create?: XOR<workflowCreateWithoutServerInput, workflowUncheckedCreateWithoutServerInput> | workflowCreateWithoutServerInput[] | workflowUncheckedCreateWithoutServerInput[]
    connectOrCreate?: workflowCreateOrConnectWithoutServerInput | workflowCreateOrConnectWithoutServerInput[]
    createMany?: workflowCreateManyServerInputEnvelope
    connect?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
  }

  export type workflowUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<workflowCreateWithoutServerInput, workflowUncheckedCreateWithoutServerInput> | workflowCreateWithoutServerInput[] | workflowUncheckedCreateWithoutServerInput[]
    connectOrCreate?: workflowCreateOrConnectWithoutServerInput | workflowCreateOrConnectWithoutServerInput[]
    createMany?: workflowCreateManyServerInputEnvelope
    connect?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
  }

  export type workflowUpdateManyWithoutServerNestedInput = {
    create?: XOR<workflowCreateWithoutServerInput, workflowUncheckedCreateWithoutServerInput> | workflowCreateWithoutServerInput[] | workflowUncheckedCreateWithoutServerInput[]
    connectOrCreate?: workflowCreateOrConnectWithoutServerInput | workflowCreateOrConnectWithoutServerInput[]
    upsert?: workflowUpsertWithWhereUniqueWithoutServerInput | workflowUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: workflowCreateManyServerInputEnvelope
    set?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    disconnect?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    delete?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    connect?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    update?: workflowUpdateWithWhereUniqueWithoutServerInput | workflowUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: workflowUpdateManyWithWhereWithoutServerInput | workflowUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: workflowScalarWhereInput | workflowScalarWhereInput[]
  }

  export type workflowUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<workflowCreateWithoutServerInput, workflowUncheckedCreateWithoutServerInput> | workflowCreateWithoutServerInput[] | workflowUncheckedCreateWithoutServerInput[]
    connectOrCreate?: workflowCreateOrConnectWithoutServerInput | workflowCreateOrConnectWithoutServerInput[]
    upsert?: workflowUpsertWithWhereUniqueWithoutServerInput | workflowUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: workflowCreateManyServerInputEnvelope
    set?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    disconnect?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    delete?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    connect?: workflowWhereUniqueInput | workflowWhereUniqueInput[]
    update?: workflowUpdateWithWhereUniqueWithoutServerInput | workflowUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: workflowUpdateManyWithWhereWithoutServerInput | workflowUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: workflowScalarWhereInput | workflowScalarWhereInput[]
  }

  export type job_historyCreateNestedManyWithoutJobInput = {
    create?: XOR<job_historyCreateWithoutJobInput, job_historyUncheckedCreateWithoutJobInput> | job_historyCreateWithoutJobInput[] | job_historyUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_historyCreateOrConnectWithoutJobInput | job_historyCreateOrConnectWithoutJobInput[]
    createMany?: job_historyCreateManyJobInputEnvelope
    connect?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
  }

  export type job_historyUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_historyCreateWithoutJobInput, job_historyUncheckedCreateWithoutJobInput> | job_historyCreateWithoutJobInput[] | job_historyUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_historyCreateOrConnectWithoutJobInput | job_historyCreateOrConnectWithoutJobInput[]
    createMany?: job_historyCreateManyJobInputEnvelope
    connect?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
  }

  export type job_historyUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_historyCreateWithoutJobInput, job_historyUncheckedCreateWithoutJobInput> | job_historyCreateWithoutJobInput[] | job_historyUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_historyCreateOrConnectWithoutJobInput | job_historyCreateOrConnectWithoutJobInput[]
    upsert?: job_historyUpsertWithWhereUniqueWithoutJobInput | job_historyUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_historyCreateManyJobInputEnvelope
    set?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    disconnect?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    delete?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    connect?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    update?: job_historyUpdateWithWhereUniqueWithoutJobInput | job_historyUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_historyUpdateManyWithWhereWithoutJobInput | job_historyUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_historyScalarWhereInput | job_historyScalarWhereInput[]
  }

  export type job_historyUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_historyCreateWithoutJobInput, job_historyUncheckedCreateWithoutJobInput> | job_historyCreateWithoutJobInput[] | job_historyUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_historyCreateOrConnectWithoutJobInput | job_historyCreateOrConnectWithoutJobInput[]
    upsert?: job_historyUpsertWithWhereUniqueWithoutJobInput | job_historyUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_historyCreateManyJobInputEnvelope
    set?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    disconnect?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    delete?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    connect?: job_historyWhereUniqueInput | job_historyWhereUniqueInput[]
    update?: job_historyUpdateWithWhereUniqueWithoutJobInput | job_historyUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_historyUpdateManyWithWhereWithoutJobInput | job_historyUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_historyScalarWhereInput | job_historyScalarWhereInput[]
  }

  export type jobCreateNestedOneWithoutJob_historyInput = {
    create?: XOR<jobCreateWithoutJob_historyInput, jobUncheckedCreateWithoutJob_historyInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_historyInput
    connect?: jobWhereUniqueInput
  }

  export type jobUpdateOneRequiredWithoutJob_historyNestedInput = {
    create?: XOR<jobCreateWithoutJob_historyInput, jobUncheckedCreateWithoutJob_historyInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_historyInput
    upsert?: jobUpsertWithoutJob_historyInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_historyInput, jobUpdateWithoutJob_historyInput>, jobUncheckedUpdateWithoutJob_historyInput>
  }

  export type miniapp_generationCreateNestedManyWithoutMiniapp_userInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_userInput, miniapp_generationUncheckedCreateWithoutMiniapp_userInput> | miniapp_generationCreateWithoutMiniapp_userInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_userInput | miniapp_generationCreateOrConnectWithoutMiniapp_userInput[]
    createMany?: miniapp_generationCreateManyMiniapp_userInputEnvelope
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
  }

  export type miniapp_paymentCreateNestedManyWithoutMiniapp_userInput = {
    create?: XOR<miniapp_paymentCreateWithoutMiniapp_userInput, miniapp_paymentUncheckedCreateWithoutMiniapp_userInput> | miniapp_paymentCreateWithoutMiniapp_userInput[] | miniapp_paymentUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutMiniapp_userInput | miniapp_paymentCreateOrConnectWithoutMiniapp_userInput[]
    createMany?: miniapp_paymentCreateManyMiniapp_userInputEnvelope
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
  }

  export type social_linkCreateNestedManyWithoutMiniapp_userInput = {
    create?: XOR<social_linkCreateWithoutMiniapp_userInput, social_linkUncheckedCreateWithoutMiniapp_userInput> | social_linkCreateWithoutMiniapp_userInput[] | social_linkUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: social_linkCreateOrConnectWithoutMiniapp_userInput | social_linkCreateOrConnectWithoutMiniapp_userInput[]
    createMany?: social_linkCreateManyMiniapp_userInputEnvelope
    connect?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
  }

  export type miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_userInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_userInput, miniapp_generationUncheckedCreateWithoutMiniapp_userInput> | miniapp_generationCreateWithoutMiniapp_userInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_userInput | miniapp_generationCreateOrConnectWithoutMiniapp_userInput[]
    createMany?: miniapp_generationCreateManyMiniapp_userInputEnvelope
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
  }

  export type miniapp_paymentUncheckedCreateNestedManyWithoutMiniapp_userInput = {
    create?: XOR<miniapp_paymentCreateWithoutMiniapp_userInput, miniapp_paymentUncheckedCreateWithoutMiniapp_userInput> | miniapp_paymentCreateWithoutMiniapp_userInput[] | miniapp_paymentUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutMiniapp_userInput | miniapp_paymentCreateOrConnectWithoutMiniapp_userInput[]
    createMany?: miniapp_paymentCreateManyMiniapp_userInputEnvelope
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
  }

  export type social_linkUncheckedCreateNestedManyWithoutMiniapp_userInput = {
    create?: XOR<social_linkCreateWithoutMiniapp_userInput, social_linkUncheckedCreateWithoutMiniapp_userInput> | social_linkCreateWithoutMiniapp_userInput[] | social_linkUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: social_linkCreateOrConnectWithoutMiniapp_userInput | social_linkCreateOrConnectWithoutMiniapp_userInput[]
    createMany?: social_linkCreateManyMiniapp_userInputEnvelope
    connect?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
  }

  export type miniapp_generationUpdateManyWithoutMiniapp_userNestedInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_userInput, miniapp_generationUncheckedCreateWithoutMiniapp_userInput> | miniapp_generationCreateWithoutMiniapp_userInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_userInput | miniapp_generationCreateOrConnectWithoutMiniapp_userInput[]
    upsert?: miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_userInput | miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_userInput[]
    createMany?: miniapp_generationCreateManyMiniapp_userInputEnvelope
    set?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    disconnect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    delete?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    update?: miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_userInput | miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_userInput[]
    updateMany?: miniapp_generationUpdateManyWithWhereWithoutMiniapp_userInput | miniapp_generationUpdateManyWithWhereWithoutMiniapp_userInput[]
    deleteMany?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
  }

  export type miniapp_paymentUpdateManyWithoutMiniapp_userNestedInput = {
    create?: XOR<miniapp_paymentCreateWithoutMiniapp_userInput, miniapp_paymentUncheckedCreateWithoutMiniapp_userInput> | miniapp_paymentCreateWithoutMiniapp_userInput[] | miniapp_paymentUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutMiniapp_userInput | miniapp_paymentCreateOrConnectWithoutMiniapp_userInput[]
    upsert?: miniapp_paymentUpsertWithWhereUniqueWithoutMiniapp_userInput | miniapp_paymentUpsertWithWhereUniqueWithoutMiniapp_userInput[]
    createMany?: miniapp_paymentCreateManyMiniapp_userInputEnvelope
    set?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    disconnect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    delete?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    update?: miniapp_paymentUpdateWithWhereUniqueWithoutMiniapp_userInput | miniapp_paymentUpdateWithWhereUniqueWithoutMiniapp_userInput[]
    updateMany?: miniapp_paymentUpdateManyWithWhereWithoutMiniapp_userInput | miniapp_paymentUpdateManyWithWhereWithoutMiniapp_userInput[]
    deleteMany?: miniapp_paymentScalarWhereInput | miniapp_paymentScalarWhereInput[]
  }

  export type social_linkUpdateManyWithoutMiniapp_userNestedInput = {
    create?: XOR<social_linkCreateWithoutMiniapp_userInput, social_linkUncheckedCreateWithoutMiniapp_userInput> | social_linkCreateWithoutMiniapp_userInput[] | social_linkUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: social_linkCreateOrConnectWithoutMiniapp_userInput | social_linkCreateOrConnectWithoutMiniapp_userInput[]
    upsert?: social_linkUpsertWithWhereUniqueWithoutMiniapp_userInput | social_linkUpsertWithWhereUniqueWithoutMiniapp_userInput[]
    createMany?: social_linkCreateManyMiniapp_userInputEnvelope
    set?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    disconnect?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    delete?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    connect?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    update?: social_linkUpdateWithWhereUniqueWithoutMiniapp_userInput | social_linkUpdateWithWhereUniqueWithoutMiniapp_userInput[]
    updateMany?: social_linkUpdateManyWithWhereWithoutMiniapp_userInput | social_linkUpdateManyWithWhereWithoutMiniapp_userInput[]
    deleteMany?: social_linkScalarWhereInput | social_linkScalarWhereInput[]
  }

  export type miniapp_generationUncheckedUpdateManyWithoutMiniapp_userNestedInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_userInput, miniapp_generationUncheckedCreateWithoutMiniapp_userInput> | miniapp_generationCreateWithoutMiniapp_userInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_userInput | miniapp_generationCreateOrConnectWithoutMiniapp_userInput[]
    upsert?: miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_userInput | miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_userInput[]
    createMany?: miniapp_generationCreateManyMiniapp_userInputEnvelope
    set?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    disconnect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    delete?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    update?: miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_userInput | miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_userInput[]
    updateMany?: miniapp_generationUpdateManyWithWhereWithoutMiniapp_userInput | miniapp_generationUpdateManyWithWhereWithoutMiniapp_userInput[]
    deleteMany?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
  }

  export type miniapp_paymentUncheckedUpdateManyWithoutMiniapp_userNestedInput = {
    create?: XOR<miniapp_paymentCreateWithoutMiniapp_userInput, miniapp_paymentUncheckedCreateWithoutMiniapp_userInput> | miniapp_paymentCreateWithoutMiniapp_userInput[] | miniapp_paymentUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutMiniapp_userInput | miniapp_paymentCreateOrConnectWithoutMiniapp_userInput[]
    upsert?: miniapp_paymentUpsertWithWhereUniqueWithoutMiniapp_userInput | miniapp_paymentUpsertWithWhereUniqueWithoutMiniapp_userInput[]
    createMany?: miniapp_paymentCreateManyMiniapp_userInputEnvelope
    set?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    disconnect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    delete?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    connect?: miniapp_paymentWhereUniqueInput | miniapp_paymentWhereUniqueInput[]
    update?: miniapp_paymentUpdateWithWhereUniqueWithoutMiniapp_userInput | miniapp_paymentUpdateWithWhereUniqueWithoutMiniapp_userInput[]
    updateMany?: miniapp_paymentUpdateManyWithWhereWithoutMiniapp_userInput | miniapp_paymentUpdateManyWithWhereWithoutMiniapp_userInput[]
    deleteMany?: miniapp_paymentScalarWhereInput | miniapp_paymentScalarWhereInput[]
  }

  export type social_linkUncheckedUpdateManyWithoutMiniapp_userNestedInput = {
    create?: XOR<social_linkCreateWithoutMiniapp_userInput, social_linkUncheckedCreateWithoutMiniapp_userInput> | social_linkCreateWithoutMiniapp_userInput[] | social_linkUncheckedCreateWithoutMiniapp_userInput[]
    connectOrCreate?: social_linkCreateOrConnectWithoutMiniapp_userInput | social_linkCreateOrConnectWithoutMiniapp_userInput[]
    upsert?: social_linkUpsertWithWhereUniqueWithoutMiniapp_userInput | social_linkUpsertWithWhereUniqueWithoutMiniapp_userInput[]
    createMany?: social_linkCreateManyMiniapp_userInputEnvelope
    set?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    disconnect?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    delete?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    connect?: social_linkWhereUniqueInput | social_linkWhereUniqueInput[]
    update?: social_linkUpdateWithWhereUniqueWithoutMiniapp_userInput | social_linkUpdateWithWhereUniqueWithoutMiniapp_userInput[]
    updateMany?: social_linkUpdateManyWithWhereWithoutMiniapp_userInput | social_linkUpdateManyWithWhereWithoutMiniapp_userInput[]
    deleteMany?: social_linkScalarWhereInput | social_linkScalarWhereInput[]
  }

  export type collectionCreateNestedOneWithoutMiniapp_collection_configInput = {
    create?: XOR<collectionCreateWithoutMiniapp_collection_configInput, collectionUncheckedCreateWithoutMiniapp_collection_configInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMiniapp_collection_configInput
    connect?: collectionWhereUniqueInput
  }

  export type collectionUpdateOneRequiredWithoutMiniapp_collection_configNestedInput = {
    create?: XOR<collectionCreateWithoutMiniapp_collection_configInput, collectionUncheckedCreateWithoutMiniapp_collection_configInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMiniapp_collection_configInput
    upsert?: collectionUpsertWithoutMiniapp_collection_configInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutMiniapp_collection_configInput, collectionUpdateWithoutMiniapp_collection_configInput>, collectionUncheckedUpdateWithoutMiniapp_collection_configInput>
  }

  export type miniapp_generationCreateNestedManyWithoutMiniapp_paymentInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_paymentInput, miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput> | miniapp_generationCreateWithoutMiniapp_paymentInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput | miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput[]
    createMany?: miniapp_generationCreateManyMiniapp_paymentInputEnvelope
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
  }

  export type collectionCreateNestedOneWithoutMiniapp_paymentInput = {
    create?: XOR<collectionCreateWithoutMiniapp_paymentInput, collectionUncheckedCreateWithoutMiniapp_paymentInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMiniapp_paymentInput
    connect?: collectionWhereUniqueInput
  }

  export type miniapp_userCreateNestedOneWithoutMiniapp_paymentInput = {
    create?: XOR<miniapp_userCreateWithoutMiniapp_paymentInput, miniapp_userUncheckedCreateWithoutMiniapp_paymentInput>
    connectOrCreate?: miniapp_userCreateOrConnectWithoutMiniapp_paymentInput
    connect?: miniapp_userWhereUniqueInput
  }

  export type miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_paymentInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_paymentInput, miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput> | miniapp_generationCreateWithoutMiniapp_paymentInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput | miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput[]
    createMany?: miniapp_generationCreateManyMiniapp_paymentInputEnvelope
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
  }

  export type miniapp_generationUpdateManyWithoutMiniapp_paymentNestedInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_paymentInput, miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput> | miniapp_generationCreateWithoutMiniapp_paymentInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput | miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput[]
    upsert?: miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_paymentInput | miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_paymentInput[]
    createMany?: miniapp_generationCreateManyMiniapp_paymentInputEnvelope
    set?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    disconnect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    delete?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    update?: miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_paymentInput | miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_paymentInput[]
    updateMany?: miniapp_generationUpdateManyWithWhereWithoutMiniapp_paymentInput | miniapp_generationUpdateManyWithWhereWithoutMiniapp_paymentInput[]
    deleteMany?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
  }

  export type collectionUpdateOneRequiredWithoutMiniapp_paymentNestedInput = {
    create?: XOR<collectionCreateWithoutMiniapp_paymentInput, collectionUncheckedCreateWithoutMiniapp_paymentInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMiniapp_paymentInput
    upsert?: collectionUpsertWithoutMiniapp_paymentInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutMiniapp_paymentInput, collectionUpdateWithoutMiniapp_paymentInput>, collectionUncheckedUpdateWithoutMiniapp_paymentInput>
  }

  export type miniapp_userUpdateOneRequiredWithoutMiniapp_paymentNestedInput = {
    create?: XOR<miniapp_userCreateWithoutMiniapp_paymentInput, miniapp_userUncheckedCreateWithoutMiniapp_paymentInput>
    connectOrCreate?: miniapp_userCreateOrConnectWithoutMiniapp_paymentInput
    upsert?: miniapp_userUpsertWithoutMiniapp_paymentInput
    connect?: miniapp_userWhereUniqueInput
    update?: XOR<XOR<miniapp_userUpdateToOneWithWhereWithoutMiniapp_paymentInput, miniapp_userUpdateWithoutMiniapp_paymentInput>, miniapp_userUncheckedUpdateWithoutMiniapp_paymentInput>
  }

  export type miniapp_generationUncheckedUpdateManyWithoutMiniapp_paymentNestedInput = {
    create?: XOR<miniapp_generationCreateWithoutMiniapp_paymentInput, miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput> | miniapp_generationCreateWithoutMiniapp_paymentInput[] | miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput[]
    connectOrCreate?: miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput | miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput[]
    upsert?: miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_paymentInput | miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_paymentInput[]
    createMany?: miniapp_generationCreateManyMiniapp_paymentInputEnvelope
    set?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    disconnect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    delete?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    connect?: miniapp_generationWhereUniqueInput | miniapp_generationWhereUniqueInput[]
    update?: miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_paymentInput | miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_paymentInput[]
    updateMany?: miniapp_generationUpdateManyWithWhereWithoutMiniapp_paymentInput | miniapp_generationUpdateManyWithWhereWithoutMiniapp_paymentInput[]
    deleteMany?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
  }

  export type collectionCreateNestedOneWithoutMiniapp_generationInput = {
    create?: XOR<collectionCreateWithoutMiniapp_generationInput, collectionUncheckedCreateWithoutMiniapp_generationInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMiniapp_generationInput
    connect?: collectionWhereUniqueInput
  }

  export type miniapp_paymentCreateNestedOneWithoutMiniapp_generationInput = {
    create?: XOR<miniapp_paymentCreateWithoutMiniapp_generationInput, miniapp_paymentUncheckedCreateWithoutMiniapp_generationInput>
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutMiniapp_generationInput
    connect?: miniapp_paymentWhereUniqueInput
  }

  export type miniapp_userCreateNestedOneWithoutMiniapp_generationInput = {
    create?: XOR<miniapp_userCreateWithoutMiniapp_generationInput, miniapp_userUncheckedCreateWithoutMiniapp_generationInput>
    connectOrCreate?: miniapp_userCreateOrConnectWithoutMiniapp_generationInput
    connect?: miniapp_userWhereUniqueInput
  }

  export type EnumGenerationStatusFieldUpdateOperationsInput = {
    set?: $Enums.GenerationStatus
  }

  export type collectionUpdateOneRequiredWithoutMiniapp_generationNestedInput = {
    create?: XOR<collectionCreateWithoutMiniapp_generationInput, collectionUncheckedCreateWithoutMiniapp_generationInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMiniapp_generationInput
    upsert?: collectionUpsertWithoutMiniapp_generationInput
    connect?: collectionWhereUniqueInput
    update?: XOR<XOR<collectionUpdateToOneWithWhereWithoutMiniapp_generationInput, collectionUpdateWithoutMiniapp_generationInput>, collectionUncheckedUpdateWithoutMiniapp_generationInput>
  }

  export type miniapp_paymentUpdateOneWithoutMiniapp_generationNestedInput = {
    create?: XOR<miniapp_paymentCreateWithoutMiniapp_generationInput, miniapp_paymentUncheckedCreateWithoutMiniapp_generationInput>
    connectOrCreate?: miniapp_paymentCreateOrConnectWithoutMiniapp_generationInput
    upsert?: miniapp_paymentUpsertWithoutMiniapp_generationInput
    disconnect?: miniapp_paymentWhereInput | boolean
    delete?: miniapp_paymentWhereInput | boolean
    connect?: miniapp_paymentWhereUniqueInput
    update?: XOR<XOR<miniapp_paymentUpdateToOneWithWhereWithoutMiniapp_generationInput, miniapp_paymentUpdateWithoutMiniapp_generationInput>, miniapp_paymentUncheckedUpdateWithoutMiniapp_generationInput>
  }

  export type miniapp_userUpdateOneRequiredWithoutMiniapp_generationNestedInput = {
    create?: XOR<miniapp_userCreateWithoutMiniapp_generationInput, miniapp_userUncheckedCreateWithoutMiniapp_generationInput>
    connectOrCreate?: miniapp_userCreateOrConnectWithoutMiniapp_generationInput
    upsert?: miniapp_userUpsertWithoutMiniapp_generationInput
    connect?: miniapp_userWhereUniqueInput
    update?: XOR<XOR<miniapp_userUpdateToOneWithWhereWithoutMiniapp_generationInput, miniapp_userUpdateWithoutMiniapp_generationInput>, miniapp_userUncheckedUpdateWithoutMiniapp_generationInput>
  }

  export type WorkflowModelCreateNestedManyWithoutModelInput = {
    create?: XOR<WorkflowModelCreateWithoutModelInput, WorkflowModelUncheckedCreateWithoutModelInput> | WorkflowModelCreateWithoutModelInput[] | WorkflowModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutModelInput | WorkflowModelCreateOrConnectWithoutModelInput[]
    createMany?: WorkflowModelCreateManyModelInputEnvelope
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
  }

  export type WorkflowModelUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<WorkflowModelCreateWithoutModelInput, WorkflowModelUncheckedCreateWithoutModelInput> | WorkflowModelCreateWithoutModelInput[] | WorkflowModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutModelInput | WorkflowModelCreateOrConnectWithoutModelInput[]
    createMany?: WorkflowModelCreateManyModelInputEnvelope
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
  }

  export type WorkflowModelUpdateManyWithoutModelNestedInput = {
    create?: XOR<WorkflowModelCreateWithoutModelInput, WorkflowModelUncheckedCreateWithoutModelInput> | WorkflowModelCreateWithoutModelInput[] | WorkflowModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutModelInput | WorkflowModelCreateOrConnectWithoutModelInput[]
    upsert?: WorkflowModelUpsertWithWhereUniqueWithoutModelInput | WorkflowModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: WorkflowModelCreateManyModelInputEnvelope
    set?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    disconnect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    delete?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    update?: WorkflowModelUpdateWithWhereUniqueWithoutModelInput | WorkflowModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: WorkflowModelUpdateManyWithWhereWithoutModelInput | WorkflowModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: WorkflowModelScalarWhereInput | WorkflowModelScalarWhereInput[]
  }

  export type WorkflowModelUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<WorkflowModelCreateWithoutModelInput, WorkflowModelUncheckedCreateWithoutModelInput> | WorkflowModelCreateWithoutModelInput[] | WorkflowModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: WorkflowModelCreateOrConnectWithoutModelInput | WorkflowModelCreateOrConnectWithoutModelInput[]
    upsert?: WorkflowModelUpsertWithWhereUniqueWithoutModelInput | WorkflowModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: WorkflowModelCreateManyModelInputEnvelope
    set?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    disconnect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    delete?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    connect?: WorkflowModelWhereUniqueInput | WorkflowModelWhereUniqueInput[]
    update?: WorkflowModelUpdateWithWhereUniqueWithoutModelInput | WorkflowModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: WorkflowModelUpdateManyWithWhereWithoutModelInput | WorkflowModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: WorkflowModelScalarWhereInput | WorkflowModelScalarWhereInput[]
  }

  export type ModelCreateNestedOneWithoutWorkflowModelsInput = {
    create?: XOR<ModelCreateWithoutWorkflowModelsInput, ModelUncheckedCreateWithoutWorkflowModelsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutWorkflowModelsInput
    connect?: ModelWhereUniqueInput
  }

  export type workflowCreateNestedOneWithoutWorkflow_modelsInput = {
    create?: XOR<workflowCreateWithoutWorkflow_modelsInput, workflowUncheckedCreateWithoutWorkflow_modelsInput>
    connectOrCreate?: workflowCreateOrConnectWithoutWorkflow_modelsInput
    connect?: workflowWhereUniqueInput
  }

  export type ModelUpdateOneRequiredWithoutWorkflowModelsNestedInput = {
    create?: XOR<ModelCreateWithoutWorkflowModelsInput, ModelUncheckedCreateWithoutWorkflowModelsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutWorkflowModelsInput
    upsert?: ModelUpsertWithoutWorkflowModelsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutWorkflowModelsInput, ModelUpdateWithoutWorkflowModelsInput>, ModelUncheckedUpdateWithoutWorkflowModelsInput>
  }

  export type workflowUpdateOneRequiredWithoutWorkflow_modelsNestedInput = {
    create?: XOR<workflowCreateWithoutWorkflow_modelsInput, workflowUncheckedCreateWithoutWorkflow_modelsInput>
    connectOrCreate?: workflowCreateOrConnectWithoutWorkflow_modelsInput
    upsert?: workflowUpsertWithoutWorkflow_modelsInput
    connect?: workflowWhereUniqueInput
    update?: XOR<XOR<workflowUpdateToOneWithWhereWithoutWorkflow_modelsInput, workflowUpdateWithoutWorkflow_modelsInput>, workflowUncheckedUpdateWithoutWorkflow_modelsInput>
  }

  export type collectionCreateNestedManyWithoutSocial_linkInput = {
    create?: XOR<collectionCreateWithoutSocial_linkInput, collectionUncheckedCreateWithoutSocial_linkInput> | collectionCreateWithoutSocial_linkInput[] | collectionUncheckedCreateWithoutSocial_linkInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutSocial_linkInput | collectionCreateOrConnectWithoutSocial_linkInput[]
    createMany?: collectionCreateManySocial_linkInputEnvelope
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
  }

  export type miniapp_userCreateNestedOneWithoutSocial_linksInput = {
    create?: XOR<miniapp_userCreateWithoutSocial_linksInput, miniapp_userUncheckedCreateWithoutSocial_linksInput>
    connectOrCreate?: miniapp_userCreateOrConnectWithoutSocial_linksInput
    connect?: miniapp_userWhereUniqueInput
  }

  export type collectionUncheckedCreateNestedManyWithoutSocial_linkInput = {
    create?: XOR<collectionCreateWithoutSocial_linkInput, collectionUncheckedCreateWithoutSocial_linkInput> | collectionCreateWithoutSocial_linkInput[] | collectionUncheckedCreateWithoutSocial_linkInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutSocial_linkInput | collectionCreateOrConnectWithoutSocial_linkInput[]
    createMany?: collectionCreateManySocial_linkInputEnvelope
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
  }

  export type Enumsocial_org_enumFieldUpdateOperationsInput = {
    set?: $Enums.social_org_enum
  }

  export type collectionUpdateManyWithoutSocial_linkNestedInput = {
    create?: XOR<collectionCreateWithoutSocial_linkInput, collectionUncheckedCreateWithoutSocial_linkInput> | collectionCreateWithoutSocial_linkInput[] | collectionUncheckedCreateWithoutSocial_linkInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutSocial_linkInput | collectionCreateOrConnectWithoutSocial_linkInput[]
    upsert?: collectionUpsertWithWhereUniqueWithoutSocial_linkInput | collectionUpsertWithWhereUniqueWithoutSocial_linkInput[]
    createMany?: collectionCreateManySocial_linkInputEnvelope
    set?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    disconnect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    delete?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    update?: collectionUpdateWithWhereUniqueWithoutSocial_linkInput | collectionUpdateWithWhereUniqueWithoutSocial_linkInput[]
    updateMany?: collectionUpdateManyWithWhereWithoutSocial_linkInput | collectionUpdateManyWithWhereWithoutSocial_linkInput[]
    deleteMany?: collectionScalarWhereInput | collectionScalarWhereInput[]
  }

  export type miniapp_userUpdateOneWithoutSocial_linksNestedInput = {
    create?: XOR<miniapp_userCreateWithoutSocial_linksInput, miniapp_userUncheckedCreateWithoutSocial_linksInput>
    connectOrCreate?: miniapp_userCreateOrConnectWithoutSocial_linksInput
    upsert?: miniapp_userUpsertWithoutSocial_linksInput
    disconnect?: miniapp_userWhereInput | boolean
    delete?: miniapp_userWhereInput | boolean
    connect?: miniapp_userWhereUniqueInput
    update?: XOR<XOR<miniapp_userUpdateToOneWithWhereWithoutSocial_linksInput, miniapp_userUpdateWithoutSocial_linksInput>, miniapp_userUncheckedUpdateWithoutSocial_linksInput>
  }

  export type collectionUncheckedUpdateManyWithoutSocial_linkNestedInput = {
    create?: XOR<collectionCreateWithoutSocial_linkInput, collectionUncheckedCreateWithoutSocial_linkInput> | collectionCreateWithoutSocial_linkInput[] | collectionUncheckedCreateWithoutSocial_linkInput[]
    connectOrCreate?: collectionCreateOrConnectWithoutSocial_linkInput | collectionCreateOrConnectWithoutSocial_linkInput[]
    upsert?: collectionUpsertWithWhereUniqueWithoutSocial_linkInput | collectionUpsertWithWhereUniqueWithoutSocial_linkInput[]
    createMany?: collectionCreateManySocial_linkInputEnvelope
    set?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    disconnect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    delete?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    connect?: collectionWhereUniqueInput | collectionWhereUniqueInput[]
    update?: collectionUpdateWithWhereUniqueWithoutSocial_linkInput | collectionUpdateWithWhereUniqueWithoutSocial_linkInput[]
    updateMany?: collectionUpdateManyWithWhereWithoutSocial_linkInput | collectionUpdateManyWithWhereWithoutSocial_linkInput[]
    deleteMany?: collectionScalarWhereInput | collectionScalarWhereInput[]
  }

  export type workflow_custom_nodesCreateNestedManyWithoutCustom_nodesInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput> | workflow_custom_nodesCreateWithoutCustom_nodesInput[] | workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput | workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput[]
    createMany?: workflow_custom_nodesCreateManyCustom_nodesInputEnvelope
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
  }

  export type workflow_custom_nodesUncheckedCreateNestedManyWithoutCustom_nodesInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput> | workflow_custom_nodesCreateWithoutCustom_nodesInput[] | workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput | workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput[]
    createMany?: workflow_custom_nodesCreateManyCustom_nodesInputEnvelope
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
  }

  export type workflow_custom_nodesUpdateManyWithoutCustom_nodesNestedInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput> | workflow_custom_nodesCreateWithoutCustom_nodesInput[] | workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput | workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput[]
    upsert?: workflow_custom_nodesUpsertWithWhereUniqueWithoutCustom_nodesInput | workflow_custom_nodesUpsertWithWhereUniqueWithoutCustom_nodesInput[]
    createMany?: workflow_custom_nodesCreateManyCustom_nodesInputEnvelope
    set?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    disconnect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    delete?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    update?: workflow_custom_nodesUpdateWithWhereUniqueWithoutCustom_nodesInput | workflow_custom_nodesUpdateWithWhereUniqueWithoutCustom_nodesInput[]
    updateMany?: workflow_custom_nodesUpdateManyWithWhereWithoutCustom_nodesInput | workflow_custom_nodesUpdateManyWithWhereWithoutCustom_nodesInput[]
    deleteMany?: workflow_custom_nodesScalarWhereInput | workflow_custom_nodesScalarWhereInput[]
  }

  export type workflow_custom_nodesUncheckedUpdateManyWithoutCustom_nodesNestedInput = {
    create?: XOR<workflow_custom_nodesCreateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput> | workflow_custom_nodesCreateWithoutCustom_nodesInput[] | workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput[]
    connectOrCreate?: workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput | workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput[]
    upsert?: workflow_custom_nodesUpsertWithWhereUniqueWithoutCustom_nodesInput | workflow_custom_nodesUpsertWithWhereUniqueWithoutCustom_nodesInput[]
    createMany?: workflow_custom_nodesCreateManyCustom_nodesInputEnvelope
    set?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    disconnect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    delete?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    connect?: workflow_custom_nodesWhereUniqueInput | workflow_custom_nodesWhereUniqueInput[]
    update?: workflow_custom_nodesUpdateWithWhereUniqueWithoutCustom_nodesInput | workflow_custom_nodesUpdateWithWhereUniqueWithoutCustom_nodesInput[]
    updateMany?: workflow_custom_nodesUpdateManyWithWhereWithoutCustom_nodesInput | workflow_custom_nodesUpdateManyWithWhereWithoutCustom_nodesInput[]
    deleteMany?: workflow_custom_nodesScalarWhereInput | workflow_custom_nodesScalarWhereInput[]
  }

  export type custom_nodesCreateNestedOneWithoutWorkflow_custom_nodesInput = {
    create?: XOR<custom_nodesCreateWithoutWorkflow_custom_nodesInput, custom_nodesUncheckedCreateWithoutWorkflow_custom_nodesInput>
    connectOrCreate?: custom_nodesCreateOrConnectWithoutWorkflow_custom_nodesInput
    connect?: custom_nodesWhereUniqueInput
  }

  export type workflowCreateNestedOneWithoutWorkflow_custom_nodesInput = {
    create?: XOR<workflowCreateWithoutWorkflow_custom_nodesInput, workflowUncheckedCreateWithoutWorkflow_custom_nodesInput>
    connectOrCreate?: workflowCreateOrConnectWithoutWorkflow_custom_nodesInput
    connect?: workflowWhereUniqueInput
  }

  export type custom_nodesUpdateOneRequiredWithoutWorkflow_custom_nodesNestedInput = {
    create?: XOR<custom_nodesCreateWithoutWorkflow_custom_nodesInput, custom_nodesUncheckedCreateWithoutWorkflow_custom_nodesInput>
    connectOrCreate?: custom_nodesCreateOrConnectWithoutWorkflow_custom_nodesInput
    upsert?: custom_nodesUpsertWithoutWorkflow_custom_nodesInput
    connect?: custom_nodesWhereUniqueInput
    update?: XOR<XOR<custom_nodesUpdateToOneWithWhereWithoutWorkflow_custom_nodesInput, custom_nodesUpdateWithoutWorkflow_custom_nodesInput>, custom_nodesUncheckedUpdateWithoutWorkflow_custom_nodesInput>
  }

  export type workflowUpdateOneRequiredWithoutWorkflow_custom_nodesNestedInput = {
    create?: XOR<workflowCreateWithoutWorkflow_custom_nodesInput, workflowUncheckedCreateWithoutWorkflow_custom_nodesInput>
    connectOrCreate?: workflowCreateOrConnectWithoutWorkflow_custom_nodesInput
    upsert?: workflowUpsertWithoutWorkflow_custom_nodesInput
    connect?: workflowWhereUniqueInput
    update?: XOR<XOR<workflowUpdateToOneWithWhereWithoutWorkflow_custom_nodesInput, workflowUpdateWithoutWorkflow_custom_nodesInput>, workflowUncheckedUpdateWithoutWorkflow_custom_nodesInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumGenerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GenerationStatus | EnumGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGenerationStatusFilter<$PrismaModel> | $Enums.GenerationStatus
  }

  export type NestedEnumGenerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenerationStatus | EnumGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GenerationStatus[] | ListEnumGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGenerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.GenerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenerationStatusFilter<$PrismaModel>
    _max?: NestedEnumGenerationStatusFilter<$PrismaModel>
  }

  export type NestedEnumsocial_org_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.social_org_enum | Enumsocial_org_enumFieldRefInput<$PrismaModel>
    in?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsocial_org_enumFilter<$PrismaModel> | $Enums.social_org_enum
  }

  export type NestedEnumsocial_org_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.social_org_enum | Enumsocial_org_enumFieldRefInput<$PrismaModel>
    in?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.social_org_enum[] | ListEnumsocial_org_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsocial_org_enumWithAggregatesFilter<$PrismaModel> | $Enums.social_org_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsocial_org_enumFilter<$PrismaModel>
    _max?: NestedEnumsocial_org_enumFilter<$PrismaModel>
  }

  export type social_linkCreateWithoutCustodial_collectionsInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_user?: miniapp_userCreateNestedOneWithoutSocial_linksInput
  }

  export type social_linkUncheckedCreateWithoutCustodial_collectionsInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_user_id?: string | null
  }

  export type social_linkCreateOrConnectWithoutCustodial_collectionsInput = {
    where: social_linkWhereUniqueInput
    create: XOR<social_linkCreateWithoutCustodial_collectionsInput, social_linkUncheckedCreateWithoutCustodial_collectionsInput>
  }

  export type projectCreateWithoutCollectionInput = {
    id?: string
    created_at?: Date | string
    name: string
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: string | null
    version?: string | null
    archived?: boolean
    is_default?: boolean
  }

  export type projectUncheckedCreateWithoutCollectionInput = {
    id?: string
    created_at?: Date | string
    name: string
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: string | null
    version?: string | null
    archived?: boolean
    is_default?: boolean
  }

  export type projectCreateOrConnectWithoutCollectionInput = {
    where: projectWhereUniqueInput
    create: XOR<projectCreateWithoutCollectionInput, projectUncheckedCreateWithoutCollectionInput>
  }

  export type collection_historyCreateWithoutCollectionInput = {
    event: string
    current_value: string
    new_value: string
    created_at?: Date | string
  }

  export type collection_historyUncheckedCreateWithoutCollectionInput = {
    id?: number
    event: string
    current_value: string
    new_value: string
    created_at?: Date | string
  }

  export type collection_historyCreateOrConnectWithoutCollectionInput = {
    where: collection_historyWhereUniqueInput
    create: XOR<collection_historyCreateWithoutCollectionInput, collection_historyUncheckedCreateWithoutCollectionInput>
  }

  export type collection_historyCreateManyCollectionInputEnvelope = {
    data: collection_historyCreateManyCollectionInput | collection_historyCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type collection_previewCreateWithoutCollectionInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection_preview_version?: collection_preview_versionCreateNestedManyWithoutCollection_previewInput
  }

  export type collection_previewUncheckedCreateWithoutCollectionInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection_preview_version?: collection_preview_versionUncheckedCreateNestedManyWithoutCollection_previewInput
  }

  export type collection_previewCreateOrConnectWithoutCollectionInput = {
    where: collection_previewWhereUniqueInput
    create: XOR<collection_previewCreateWithoutCollectionInput, collection_previewUncheckedCreateWithoutCollectionInput>
  }

  export type collection_remixCreateWithoutSource_collectionInput = {
    id?: bigint | number
    created_at?: Date | string | null
    collection_preview_version?: collection_preview_versionCreateNestedOneWithoutCollection_remixInput
    target_collection: collectionCreateNestedOneWithoutTarget_remixInput
  }

  export type collection_remixUncheckedCreateWithoutSource_collectionInput = {
    id?: bigint | number
    target_collection_id: string
    created_at?: Date | string | null
    collection_preview_version_id?: bigint | number | null
  }

  export type collection_remixCreateOrConnectWithoutSource_collectionInput = {
    where: collection_remixWhereUniqueInput
    create: XOR<collection_remixCreateWithoutSource_collectionInput, collection_remixUncheckedCreateWithoutSource_collectionInput>
  }

  export type collection_remixCreateManySource_collectionInputEnvelope = {
    data: collection_remixCreateManySource_collectionInput | collection_remixCreateManySource_collectionInput[]
    skipDuplicates?: boolean
  }

  export type collection_remixCreateWithoutTarget_collectionInput = {
    id?: bigint | number
    created_at?: Date | string | null
    collection_preview_version?: collection_preview_versionCreateNestedOneWithoutCollection_remixInput
    source_collection: collectionCreateNestedOneWithoutSource_remixInput
  }

  export type collection_remixUncheckedCreateWithoutTarget_collectionInput = {
    id?: bigint | number
    source_collection_id: string
    created_at?: Date | string | null
    collection_preview_version_id?: bigint | number | null
  }

  export type collection_remixCreateOrConnectWithoutTarget_collectionInput = {
    where: collection_remixWhereUniqueInput
    create: XOR<collection_remixCreateWithoutTarget_collectionInput, collection_remixUncheckedCreateWithoutTarget_collectionInput>
  }

  export type collection_remixCreateManyTarget_collectionInputEnvelope = {
    data: collection_remixCreateManyTarget_collectionInput | collection_remixCreateManyTarget_collectionInput[]
    skipDuplicates?: boolean
  }

  export type collection_sales_receiversCreateWithoutCollectionInput = {
    address: string
    value: number
    type: string
  }

  export type collection_sales_receiversUncheckedCreateWithoutCollectionInput = {
    id?: number
    address: string
    value: number
    type: string
  }

  export type collection_sales_receiversCreateOrConnectWithoutCollectionInput = {
    where: collection_sales_receiversWhereUniqueInput
    create: XOR<collection_sales_receiversCreateWithoutCollectionInput, collection_sales_receiversUncheckedCreateWithoutCollectionInput>
  }

  export type collection_sales_receiversCreateManyCollectionInputEnvelope = {
    data: collection_sales_receiversCreateManyCollectionInput | collection_sales_receiversCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type collection_sample_imagesCreateWithoutCollectionInput = {
    id?: bigint | number
    url: string
  }

  export type collection_sample_imagesUncheckedCreateWithoutCollectionInput = {
    id?: bigint | number
    url: string
  }

  export type collection_sample_imagesCreateOrConnectWithoutCollectionInput = {
    where: collection_sample_imagesWhereUniqueInput
    create: XOR<collection_sample_imagesCreateWithoutCollectionInput, collection_sample_imagesUncheckedCreateWithoutCollectionInput>
  }

  export type collection_sample_imagesCreateManyCollectionInputEnvelope = {
    data: collection_sample_imagesCreateManyCollectionInput | collection_sample_imagesCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type componentCreateWithoutCollectionInput = {
    id?: bigint | number
    created_at?: Date | string | null
    component_flat_files?: component_flat_fileCreateNestedManyWithoutComponentInput
  }

  export type componentUncheckedCreateWithoutCollectionInput = {
    id?: bigint | number
    created_at?: Date | string | null
    component_flat_files?: component_flat_fileUncheckedCreateNestedManyWithoutComponentInput
  }

  export type componentCreateOrConnectWithoutCollectionInput = {
    where: componentWhereUniqueInput
    create: XOR<componentCreateWithoutCollectionInput, componentUncheckedCreateWithoutCollectionInput>
  }

  export type componentCreateManyCollectionInputEnvelope = {
    data: componentCreateManyCollectionInput | componentCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type miniapp_collection_configCreateWithoutCollectionInput = {
    id?: string
    price?: number
    generations_per_payment?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    max_retries?: number
  }

  export type miniapp_collection_configUncheckedCreateWithoutCollectionInput = {
    id?: string
    price?: number
    generations_per_payment?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    max_retries?: number
  }

  export type miniapp_collection_configCreateOrConnectWithoutCollectionInput = {
    where: miniapp_collection_configWhereUniqueInput
    create: XOR<miniapp_collection_configCreateWithoutCollectionInput, miniapp_collection_configUncheckedCreateWithoutCollectionInput>
  }

  export type miniapp_generationCreateWithoutCollectionInput = {
    id?: string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
    miniapp_payment?: miniapp_paymentCreateNestedOneWithoutMiniapp_generationInput
    miniapp_user: miniapp_userCreateNestedOneWithoutMiniapp_generationInput
  }

  export type miniapp_generationUncheckedCreateWithoutCollectionInput = {
    id?: string
    user_id: string
    payment_id?: string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_generationCreateOrConnectWithoutCollectionInput = {
    where: miniapp_generationWhereUniqueInput
    create: XOR<miniapp_generationCreateWithoutCollectionInput, miniapp_generationUncheckedCreateWithoutCollectionInput>
  }

  export type miniapp_generationCreateManyCollectionInputEnvelope = {
    data: miniapp_generationCreateManyCollectionInput | miniapp_generationCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type miniapp_paymentCreateWithoutCollectionInput = {
    id?: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutMiniapp_paymentInput
    miniapp_user: miniapp_userCreateNestedOneWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentUncheckedCreateWithoutCollectionInput = {
    id?: string
    user_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentCreateOrConnectWithoutCollectionInput = {
    where: miniapp_paymentWhereUniqueInput
    create: XOR<miniapp_paymentCreateWithoutCollectionInput, miniapp_paymentUncheckedCreateWithoutCollectionInput>
  }

  export type miniapp_paymentCreateManyCollectionInputEnvelope = {
    data: miniapp_paymentCreateManyCollectionInput | miniapp_paymentCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type social_linkUpsertWithoutCustodial_collectionsInput = {
    update: XOR<social_linkUpdateWithoutCustodial_collectionsInput, social_linkUncheckedUpdateWithoutCustodial_collectionsInput>
    create: XOR<social_linkCreateWithoutCustodial_collectionsInput, social_linkUncheckedCreateWithoutCustodial_collectionsInput>
    where?: social_linkWhereInput
  }

  export type social_linkUpdateToOneWithWhereWithoutCustodial_collectionsInput = {
    where?: social_linkWhereInput
    data: XOR<social_linkUpdateWithoutCustodial_collectionsInput, social_linkUncheckedUpdateWithoutCustodial_collectionsInput>
  }

  export type social_linkUpdateWithoutCustodial_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_user?: miniapp_userUpdateOneWithoutSocial_linksNestedInput
  }

  export type social_linkUncheckedUpdateWithoutCustodial_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type projectUpsertWithoutCollectionInput = {
    update: XOR<projectUpdateWithoutCollectionInput, projectUncheckedUpdateWithoutCollectionInput>
    create: XOR<projectCreateWithoutCollectionInput, projectUncheckedCreateWithoutCollectionInput>
    where?: projectWhereInput
  }

  export type projectUpdateToOneWithWhereWithoutCollectionInput = {
    where?: projectWhereInput
    data: XOR<projectUpdateWithoutCollectionInput, projectUncheckedUpdateWithoutCollectionInput>
  }

  export type projectUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projectUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type collection_historyUpsertWithWhereUniqueWithoutCollectionInput = {
    where: collection_historyWhereUniqueInput
    update: XOR<collection_historyUpdateWithoutCollectionInput, collection_historyUncheckedUpdateWithoutCollectionInput>
    create: XOR<collection_historyCreateWithoutCollectionInput, collection_historyUncheckedCreateWithoutCollectionInput>
  }

  export type collection_historyUpdateWithWhereUniqueWithoutCollectionInput = {
    where: collection_historyWhereUniqueInput
    data: XOR<collection_historyUpdateWithoutCollectionInput, collection_historyUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_historyUpdateManyWithWhereWithoutCollectionInput = {
    where: collection_historyScalarWhereInput
    data: XOR<collection_historyUpdateManyMutationInput, collection_historyUncheckedUpdateManyWithoutCollectionInput>
  }

  export type collection_historyScalarWhereInput = {
    AND?: collection_historyScalarWhereInput | collection_historyScalarWhereInput[]
    OR?: collection_historyScalarWhereInput[]
    NOT?: collection_historyScalarWhereInput | collection_historyScalarWhereInput[]
    id?: IntFilter<"collection_history"> | number
    event?: StringFilter<"collection_history"> | string
    current_value?: StringFilter<"collection_history"> | string
    new_value?: StringFilter<"collection_history"> | string
    created_at?: DateTimeFilter<"collection_history"> | Date | string
    collection_id?: UuidFilter<"collection_history"> | string
  }

  export type collection_previewUpsertWithoutCollectionInput = {
    update: XOR<collection_previewUpdateWithoutCollectionInput, collection_previewUncheckedUpdateWithoutCollectionInput>
    create: XOR<collection_previewCreateWithoutCollectionInput, collection_previewUncheckedCreateWithoutCollectionInput>
    where?: collection_previewWhereInput
  }

  export type collection_previewUpdateToOneWithWhereWithoutCollectionInput = {
    where?: collection_previewWhereInput
    data: XOR<collection_previewUpdateWithoutCollectionInput, collection_previewUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_previewUpdateWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
    collection_preview_version?: collection_preview_versionUpdateManyWithoutCollection_previewNestedInput
  }

  export type collection_previewUncheckedUpdateWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
    collection_preview_version?: collection_preview_versionUncheckedUpdateManyWithoutCollection_previewNestedInput
  }

  export type collection_remixUpsertWithWhereUniqueWithoutSource_collectionInput = {
    where: collection_remixWhereUniqueInput
    update: XOR<collection_remixUpdateWithoutSource_collectionInput, collection_remixUncheckedUpdateWithoutSource_collectionInput>
    create: XOR<collection_remixCreateWithoutSource_collectionInput, collection_remixUncheckedCreateWithoutSource_collectionInput>
  }

  export type collection_remixUpdateWithWhereUniqueWithoutSource_collectionInput = {
    where: collection_remixWhereUniqueInput
    data: XOR<collection_remixUpdateWithoutSource_collectionInput, collection_remixUncheckedUpdateWithoutSource_collectionInput>
  }

  export type collection_remixUpdateManyWithWhereWithoutSource_collectionInput = {
    where: collection_remixScalarWhereInput
    data: XOR<collection_remixUpdateManyMutationInput, collection_remixUncheckedUpdateManyWithoutSource_collectionInput>
  }

  export type collection_remixScalarWhereInput = {
    AND?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
    OR?: collection_remixScalarWhereInput[]
    NOT?: collection_remixScalarWhereInput | collection_remixScalarWhereInput[]
    id?: BigIntFilter<"collection_remix"> | bigint | number
    source_collection_id?: UuidFilter<"collection_remix"> | string
    target_collection_id?: UuidFilter<"collection_remix"> | string
    created_at?: DateTimeNullableFilter<"collection_remix"> | Date | string | null
    collection_preview_version_id?: BigIntNullableFilter<"collection_remix"> | bigint | number | null
  }

  export type collection_remixUpsertWithWhereUniqueWithoutTarget_collectionInput = {
    where: collection_remixWhereUniqueInput
    update: XOR<collection_remixUpdateWithoutTarget_collectionInput, collection_remixUncheckedUpdateWithoutTarget_collectionInput>
    create: XOR<collection_remixCreateWithoutTarget_collectionInput, collection_remixUncheckedCreateWithoutTarget_collectionInput>
  }

  export type collection_remixUpdateWithWhereUniqueWithoutTarget_collectionInput = {
    where: collection_remixWhereUniqueInput
    data: XOR<collection_remixUpdateWithoutTarget_collectionInput, collection_remixUncheckedUpdateWithoutTarget_collectionInput>
  }

  export type collection_remixUpdateManyWithWhereWithoutTarget_collectionInput = {
    where: collection_remixScalarWhereInput
    data: XOR<collection_remixUpdateManyMutationInput, collection_remixUncheckedUpdateManyWithoutTarget_collectionInput>
  }

  export type collection_sales_receiversUpsertWithWhereUniqueWithoutCollectionInput = {
    where: collection_sales_receiversWhereUniqueInput
    update: XOR<collection_sales_receiversUpdateWithoutCollectionInput, collection_sales_receiversUncheckedUpdateWithoutCollectionInput>
    create: XOR<collection_sales_receiversCreateWithoutCollectionInput, collection_sales_receiversUncheckedCreateWithoutCollectionInput>
  }

  export type collection_sales_receiversUpdateWithWhereUniqueWithoutCollectionInput = {
    where: collection_sales_receiversWhereUniqueInput
    data: XOR<collection_sales_receiversUpdateWithoutCollectionInput, collection_sales_receiversUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_sales_receiversUpdateManyWithWhereWithoutCollectionInput = {
    where: collection_sales_receiversScalarWhereInput
    data: XOR<collection_sales_receiversUpdateManyMutationInput, collection_sales_receiversUncheckedUpdateManyWithoutCollectionInput>
  }

  export type collection_sales_receiversScalarWhereInput = {
    AND?: collection_sales_receiversScalarWhereInput | collection_sales_receiversScalarWhereInput[]
    OR?: collection_sales_receiversScalarWhereInput[]
    NOT?: collection_sales_receiversScalarWhereInput | collection_sales_receiversScalarWhereInput[]
    id?: IntFilter<"collection_sales_receivers"> | number
    collection_id?: UuidFilter<"collection_sales_receivers"> | string
    address?: StringFilter<"collection_sales_receivers"> | string
    value?: FloatFilter<"collection_sales_receivers"> | number
    type?: StringFilter<"collection_sales_receivers"> | string
  }

  export type collection_sample_imagesUpsertWithWhereUniqueWithoutCollectionInput = {
    where: collection_sample_imagesWhereUniqueInput
    update: XOR<collection_sample_imagesUpdateWithoutCollectionInput, collection_sample_imagesUncheckedUpdateWithoutCollectionInput>
    create: XOR<collection_sample_imagesCreateWithoutCollectionInput, collection_sample_imagesUncheckedCreateWithoutCollectionInput>
  }

  export type collection_sample_imagesUpdateWithWhereUniqueWithoutCollectionInput = {
    where: collection_sample_imagesWhereUniqueInput
    data: XOR<collection_sample_imagesUpdateWithoutCollectionInput, collection_sample_imagesUncheckedUpdateWithoutCollectionInput>
  }

  export type collection_sample_imagesUpdateManyWithWhereWithoutCollectionInput = {
    where: collection_sample_imagesScalarWhereInput
    data: XOR<collection_sample_imagesUpdateManyMutationInput, collection_sample_imagesUncheckedUpdateManyWithoutCollectionInput>
  }

  export type collection_sample_imagesScalarWhereInput = {
    AND?: collection_sample_imagesScalarWhereInput | collection_sample_imagesScalarWhereInput[]
    OR?: collection_sample_imagesScalarWhereInput[]
    NOT?: collection_sample_imagesScalarWhereInput | collection_sample_imagesScalarWhereInput[]
    id?: BigIntFilter<"collection_sample_images"> | bigint | number
    url?: StringFilter<"collection_sample_images"> | string
    collection_id?: UuidFilter<"collection_sample_images"> | string
  }

  export type componentUpsertWithWhereUniqueWithoutCollectionInput = {
    where: componentWhereUniqueInput
    update: XOR<componentUpdateWithoutCollectionInput, componentUncheckedUpdateWithoutCollectionInput>
    create: XOR<componentCreateWithoutCollectionInput, componentUncheckedCreateWithoutCollectionInput>
  }

  export type componentUpdateWithWhereUniqueWithoutCollectionInput = {
    where: componentWhereUniqueInput
    data: XOR<componentUpdateWithoutCollectionInput, componentUncheckedUpdateWithoutCollectionInput>
  }

  export type componentUpdateManyWithWhereWithoutCollectionInput = {
    where: componentScalarWhereInput
    data: XOR<componentUpdateManyMutationInput, componentUncheckedUpdateManyWithoutCollectionInput>
  }

  export type componentScalarWhereInput = {
    AND?: componentScalarWhereInput | componentScalarWhereInput[]
    OR?: componentScalarWhereInput[]
    NOT?: componentScalarWhereInput | componentScalarWhereInput[]
    id?: BigIntFilter<"component"> | bigint | number
    collection_id?: UuidFilter<"component"> | string
    created_at?: DateTimeNullableFilter<"component"> | Date | string | null
  }

  export type miniapp_collection_configUpsertWithoutCollectionInput = {
    update: XOR<miniapp_collection_configUpdateWithoutCollectionInput, miniapp_collection_configUncheckedUpdateWithoutCollectionInput>
    create: XOR<miniapp_collection_configCreateWithoutCollectionInput, miniapp_collection_configUncheckedCreateWithoutCollectionInput>
    where?: miniapp_collection_configWhereInput
  }

  export type miniapp_collection_configUpdateToOneWithWhereWithoutCollectionInput = {
    where?: miniapp_collection_configWhereInput
    data: XOR<miniapp_collection_configUpdateWithoutCollectionInput, miniapp_collection_configUncheckedUpdateWithoutCollectionInput>
  }

  export type miniapp_collection_configUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    generations_per_payment?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    max_retries?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_collection_configUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    generations_per_payment?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    max_retries?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationUpsertWithWhereUniqueWithoutCollectionInput = {
    where: miniapp_generationWhereUniqueInput
    update: XOR<miniapp_generationUpdateWithoutCollectionInput, miniapp_generationUncheckedUpdateWithoutCollectionInput>
    create: XOR<miniapp_generationCreateWithoutCollectionInput, miniapp_generationUncheckedCreateWithoutCollectionInput>
  }

  export type miniapp_generationUpdateWithWhereUniqueWithoutCollectionInput = {
    where: miniapp_generationWhereUniqueInput
    data: XOR<miniapp_generationUpdateWithoutCollectionInput, miniapp_generationUncheckedUpdateWithoutCollectionInput>
  }

  export type miniapp_generationUpdateManyWithWhereWithoutCollectionInput = {
    where: miniapp_generationScalarWhereInput
    data: XOR<miniapp_generationUpdateManyMutationInput, miniapp_generationUncheckedUpdateManyWithoutCollectionInput>
  }

  export type miniapp_generationScalarWhereInput = {
    AND?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
    OR?: miniapp_generationScalarWhereInput[]
    NOT?: miniapp_generationScalarWhereInput | miniapp_generationScalarWhereInput[]
    id?: UuidFilter<"miniapp_generation"> | string
    user_id?: UuidFilter<"miniapp_generation"> | string
    collection_id?: UuidFilter<"miniapp_generation"> | string
    payment_id?: UuidNullableFilter<"miniapp_generation"> | string | null
    input_data?: JsonNullableFilter<"miniapp_generation">
    output_url?: StringNullableFilter<"miniapp_generation"> | string | null
    output_data?: JsonNullableFilter<"miniapp_generation">
    error_message?: StringNullableFilter<"miniapp_generation"> | string | null
    created_at?: DateTimeFilter<"miniapp_generation"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_generation"> | Date | string
    job_id?: StringNullableFilter<"miniapp_generation"> | string | null
    generated_image?: StringNullableFilter<"miniapp_generation"> | string | null
    status?: EnumGenerationStatusFilter<"miniapp_generation"> | $Enums.GenerationStatus
    retry_count?: IntFilter<"miniapp_generation"> | number
  }

  export type miniapp_paymentUpsertWithWhereUniqueWithoutCollectionInput = {
    where: miniapp_paymentWhereUniqueInput
    update: XOR<miniapp_paymentUpdateWithoutCollectionInput, miniapp_paymentUncheckedUpdateWithoutCollectionInput>
    create: XOR<miniapp_paymentCreateWithoutCollectionInput, miniapp_paymentUncheckedCreateWithoutCollectionInput>
  }

  export type miniapp_paymentUpdateWithWhereUniqueWithoutCollectionInput = {
    where: miniapp_paymentWhereUniqueInput
    data: XOR<miniapp_paymentUpdateWithoutCollectionInput, miniapp_paymentUncheckedUpdateWithoutCollectionInput>
  }

  export type miniapp_paymentUpdateManyWithWhereWithoutCollectionInput = {
    where: miniapp_paymentScalarWhereInput
    data: XOR<miniapp_paymentUpdateManyMutationInput, miniapp_paymentUncheckedUpdateManyWithoutCollectionInput>
  }

  export type miniapp_paymentScalarWhereInput = {
    AND?: miniapp_paymentScalarWhereInput | miniapp_paymentScalarWhereInput[]
    OR?: miniapp_paymentScalarWhereInput[]
    NOT?: miniapp_paymentScalarWhereInput | miniapp_paymentScalarWhereInput[]
    id?: UuidFilter<"miniapp_payment"> | string
    user_id?: UuidFilter<"miniapp_payment"> | string
    collection_id?: UuidFilter<"miniapp_payment"> | string
    amount?: FloatFilter<"miniapp_payment"> | number
    transaction_hash?: StringNullableFilter<"miniapp_payment"> | string | null
    payment_status?: StringFilter<"miniapp_payment"> | string
    generations_allowed?: IntFilter<"miniapp_payment"> | number
    generations_used?: IntFilter<"miniapp_payment"> | number
    created_at?: DateTimeFilter<"miniapp_payment"> | Date | string
    updated_at?: DateTimeFilter<"miniapp_payment"> | Date | string
  }

  export type collection_preview_versionCreateWithoutCollection_remixInput = {
    id?: bigint | number
    version?: number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
    collection_preview: collection_previewCreateNestedOneWithoutCollection_preview_versionInput
  }

  export type collection_preview_versionUncheckedCreateWithoutCollection_remixInput = {
    id?: bigint | number
    version?: number
    collection_preview_id: bigint | number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
  }

  export type collection_preview_versionCreateOrConnectWithoutCollection_remixInput = {
    where: collection_preview_versionWhereUniqueInput
    create: XOR<collection_preview_versionCreateWithoutCollection_remixInput, collection_preview_versionUncheckedCreateWithoutCollection_remixInput>
  }

  export type collectionCreateWithoutSource_remixInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutSource_remixInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutSource_remixInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutSource_remixInput, collectionUncheckedCreateWithoutSource_remixInput>
  }

  export type collectionCreateWithoutTarget_remixInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutTarget_remixInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutTarget_remixInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutTarget_remixInput, collectionUncheckedCreateWithoutTarget_remixInput>
  }

  export type collection_preview_versionUpsertWithoutCollection_remixInput = {
    update: XOR<collection_preview_versionUpdateWithoutCollection_remixInput, collection_preview_versionUncheckedUpdateWithoutCollection_remixInput>
    create: XOR<collection_preview_versionCreateWithoutCollection_remixInput, collection_preview_versionUncheckedCreateWithoutCollection_remixInput>
    where?: collection_preview_versionWhereInput
  }

  export type collection_preview_versionUpdateToOneWithWhereWithoutCollection_remixInput = {
    where?: collection_preview_versionWhereInput
    data: XOR<collection_preview_versionUpdateWithoutCollection_remixInput, collection_preview_versionUncheckedUpdateWithoutCollection_remixInput>
  }

  export type collection_preview_versionUpdateWithoutCollection_remixInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview?: collection_previewUpdateOneRequiredWithoutCollection_preview_versionNestedInput
  }

  export type collection_preview_versionUncheckedUpdateWithoutCollection_remixInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    collection_preview_id?: BigIntFieldUpdateOperationsInput | bigint | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collectionUpsertWithoutSource_remixInput = {
    update: XOR<collectionUpdateWithoutSource_remixInput, collectionUncheckedUpdateWithoutSource_remixInput>
    create: XOR<collectionCreateWithoutSource_remixInput, collectionUncheckedCreateWithoutSource_remixInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutSource_remixInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutSource_remixInput, collectionUncheckedUpdateWithoutSource_remixInput>
  }

  export type collectionUpdateWithoutSource_remixInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutSource_remixInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUpsertWithoutTarget_remixInput = {
    update: XOR<collectionUpdateWithoutTarget_remixInput, collectionUncheckedUpdateWithoutTarget_remixInput>
    create: XOR<collectionCreateWithoutTarget_remixInput, collectionUncheckedCreateWithoutTarget_remixInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutTarget_remixInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutTarget_remixInput, collectionUncheckedUpdateWithoutTarget_remixInput>
  }

  export type collectionUpdateWithoutTarget_remixInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutTarget_remixInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type chat_messageCreateWithoutFlat_fileInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    chat: chatCreateNestedOneWithoutChat_messageInput
  }

  export type chat_messageUncheckedCreateWithoutFlat_fileInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    chat_id: string
  }

  export type chat_messageCreateOrConnectWithoutFlat_fileInput = {
    where: chat_messageWhereUniqueInput
    create: XOR<chat_messageCreateWithoutFlat_fileInput, chat_messageUncheckedCreateWithoutFlat_fileInput>
  }

  export type chat_messageCreateManyFlat_fileInputEnvelope = {
    data: chat_messageCreateManyFlat_fileInput | chat_messageCreateManyFlat_fileInput[]
    skipDuplicates?: boolean
  }

  export type component_flat_fileCreateWithoutFlat_fileInput = {
    id?: bigint | number
    component: componentCreateNestedOneWithoutComponent_flat_filesInput
  }

  export type component_flat_fileUncheckedCreateWithoutFlat_fileInput = {
    id?: bigint | number
    component_id: bigint | number
  }

  export type component_flat_fileCreateOrConnectWithoutFlat_fileInput = {
    where: component_flat_fileWhereUniqueInput
    create: XOR<component_flat_fileCreateWithoutFlat_fileInput, component_flat_fileUncheckedCreateWithoutFlat_fileInput>
  }

  export type component_flat_fileCreateManyFlat_fileInputEnvelope = {
    data: component_flat_fileCreateManyFlat_fileInput | component_flat_fileCreateManyFlat_fileInput[]
    skipDuplicates?: boolean
  }

  export type chat_messageUpsertWithWhereUniqueWithoutFlat_fileInput = {
    where: chat_messageWhereUniqueInput
    update: XOR<chat_messageUpdateWithoutFlat_fileInput, chat_messageUncheckedUpdateWithoutFlat_fileInput>
    create: XOR<chat_messageCreateWithoutFlat_fileInput, chat_messageUncheckedCreateWithoutFlat_fileInput>
  }

  export type chat_messageUpdateWithWhereUniqueWithoutFlat_fileInput = {
    where: chat_messageWhereUniqueInput
    data: XOR<chat_messageUpdateWithoutFlat_fileInput, chat_messageUncheckedUpdateWithoutFlat_fileInput>
  }

  export type chat_messageUpdateManyWithWhereWithoutFlat_fileInput = {
    where: chat_messageScalarWhereInput
    data: XOR<chat_messageUpdateManyMutationInput, chat_messageUncheckedUpdateManyWithoutFlat_fileInput>
  }

  export type chat_messageScalarWhereInput = {
    AND?: chat_messageScalarWhereInput | chat_messageScalarWhereInput[]
    OR?: chat_messageScalarWhereInput[]
    NOT?: chat_messageScalarWhereInput | chat_messageScalarWhereInput[]
    id?: UuidFilter<"chat_message"> | string
    created_at?: DateTimeNullableFilter<"chat_message"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_message"> | Date | string | null
    user_id?: UuidFilter<"chat_message"> | string
    content?: StringFilter<"chat_message"> | string
    chat_id?: UuidFilter<"chat_message"> | string
    flat_file_id?: BigIntNullableFilter<"chat_message"> | bigint | number | null
  }

  export type component_flat_fileUpsertWithWhereUniqueWithoutFlat_fileInput = {
    where: component_flat_fileWhereUniqueInput
    update: XOR<component_flat_fileUpdateWithoutFlat_fileInput, component_flat_fileUncheckedUpdateWithoutFlat_fileInput>
    create: XOR<component_flat_fileCreateWithoutFlat_fileInput, component_flat_fileUncheckedCreateWithoutFlat_fileInput>
  }

  export type component_flat_fileUpdateWithWhereUniqueWithoutFlat_fileInput = {
    where: component_flat_fileWhereUniqueInput
    data: XOR<component_flat_fileUpdateWithoutFlat_fileInput, component_flat_fileUncheckedUpdateWithoutFlat_fileInput>
  }

  export type component_flat_fileUpdateManyWithWhereWithoutFlat_fileInput = {
    where: component_flat_fileScalarWhereInput
    data: XOR<component_flat_fileUpdateManyMutationInput, component_flat_fileUncheckedUpdateManyWithoutFlat_fileInput>
  }

  export type component_flat_fileScalarWhereInput = {
    AND?: component_flat_fileScalarWhereInput | component_flat_fileScalarWhereInput[]
    OR?: component_flat_fileScalarWhereInput[]
    NOT?: component_flat_fileScalarWhereInput | component_flat_fileScalarWhereInput[]
    id?: BigIntFilter<"component_flat_file"> | bigint | number
    component_id?: BigIntFilter<"component_flat_file"> | bigint | number
    flat_file_id?: BigIntFilter<"component_flat_file"> | bigint | number
  }

  export type componentCreateWithoutComponent_flat_filesInput = {
    id?: bigint | number
    created_at?: Date | string | null
    collection: collectionCreateNestedOneWithoutCollection_nodeInput
  }

  export type componentUncheckedCreateWithoutComponent_flat_filesInput = {
    id?: bigint | number
    collection_id: string
    created_at?: Date | string | null
  }

  export type componentCreateOrConnectWithoutComponent_flat_filesInput = {
    where: componentWhereUniqueInput
    create: XOR<componentCreateWithoutComponent_flat_filesInput, componentUncheckedCreateWithoutComponent_flat_filesInput>
  }

  export type flat_fileCreateWithoutComponent_flat_filesInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
    chat_message?: chat_messageCreateNestedManyWithoutFlat_fileInput
  }

  export type flat_fileUncheckedCreateWithoutComponent_flat_filesInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
    chat_message?: chat_messageUncheckedCreateNestedManyWithoutFlat_fileInput
  }

  export type flat_fileCreateOrConnectWithoutComponent_flat_filesInput = {
    where: flat_fileWhereUniqueInput
    create: XOR<flat_fileCreateWithoutComponent_flat_filesInput, flat_fileUncheckedCreateWithoutComponent_flat_filesInput>
  }

  export type componentUpsertWithoutComponent_flat_filesInput = {
    update: XOR<componentUpdateWithoutComponent_flat_filesInput, componentUncheckedUpdateWithoutComponent_flat_filesInput>
    create: XOR<componentCreateWithoutComponent_flat_filesInput, componentUncheckedCreateWithoutComponent_flat_filesInput>
    where?: componentWhereInput
  }

  export type componentUpdateToOneWithWhereWithoutComponent_flat_filesInput = {
    where?: componentWhereInput
    data: XOR<componentUpdateWithoutComponent_flat_filesInput, componentUncheckedUpdateWithoutComponent_flat_filesInput>
  }

  export type componentUpdateWithoutComponent_flat_filesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection?: collectionUpdateOneRequiredWithoutCollection_nodeNestedInput
  }

  export type componentUncheckedUpdateWithoutComponent_flat_filesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type flat_fileUpsertWithoutComponent_flat_filesInput = {
    update: XOR<flat_fileUpdateWithoutComponent_flat_filesInput, flat_fileUncheckedUpdateWithoutComponent_flat_filesInput>
    create: XOR<flat_fileCreateWithoutComponent_flat_filesInput, flat_fileUncheckedCreateWithoutComponent_flat_filesInput>
    where?: flat_fileWhereInput
  }

  export type flat_fileUpdateToOneWithWhereWithoutComponent_flat_filesInput = {
    where?: flat_fileWhereInput
    data: XOR<flat_fileUpdateWithoutComponent_flat_filesInput, flat_fileUncheckedUpdateWithoutComponent_flat_filesInput>
  }

  export type flat_fileUpdateWithoutComponent_flat_filesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
    chat_message?: chat_messageUpdateManyWithoutFlat_fileNestedInput
  }

  export type flat_fileUncheckedUpdateWithoutComponent_flat_filesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
    chat_message?: chat_messageUncheckedUpdateManyWithoutFlat_fileNestedInput
  }

  export type collectionCreateWithoutProjectInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutProjectInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutProjectInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutProjectInput, collectionUncheckedCreateWithoutProjectInput>
  }

  export type collectionCreateManyProjectInputEnvelope = {
    data: collectionCreateManyProjectInput | collectionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type collectionUpsertWithWhereUniqueWithoutProjectInput = {
    where: collectionWhereUniqueInput
    update: XOR<collectionUpdateWithoutProjectInput, collectionUncheckedUpdateWithoutProjectInput>
    create: XOR<collectionCreateWithoutProjectInput, collectionUncheckedCreateWithoutProjectInput>
  }

  export type collectionUpdateWithWhereUniqueWithoutProjectInput = {
    where: collectionWhereUniqueInput
    data: XOR<collectionUpdateWithoutProjectInput, collectionUncheckedUpdateWithoutProjectInput>
  }

  export type collectionUpdateManyWithWhereWithoutProjectInput = {
    where: collectionScalarWhereInput
    data: XOR<collectionUpdateManyMutationInput, collectionUncheckedUpdateManyWithoutProjectInput>
  }

  export type collectionScalarWhereInput = {
    AND?: collectionScalarWhereInput | collectionScalarWhereInput[]
    OR?: collectionScalarWhereInput[]
    NOT?: collectionScalarWhereInput | collectionScalarWhereInput[]
    id?: UuidFilter<"collection"> | string
    archived?: BoolFilter<"collection"> | boolean
    batch_max_tokens?: IntNullableFilter<"collection"> | number | null
    batch_mint_enabled?: BoolFilter<"collection"> | boolean
    blockchain?: StringNullableFilter<"collection"> | string | null
    cover_image_url?: StringNullableFilter<"collection"> | string | null
    data?: JsonNullableFilter<"collection">
    description?: StringNullableFilter<"collection"> | string | null
    editions?: IntNullableFilter<"collection"> | number | null
    encryption_enabled?: BoolNullableFilter<"collection"> | boolean | null
    images?: JsonNullableFilter<"collection">
    is_current?: BoolFilter<"collection"> | boolean
    price?: FloatNullableFilter<"collection"> | number | null
    project_id?: UuidFilter<"collection"> | string
    publish_date?: DateTimeNullableFilter<"collection"> | Date | string | null
    status?: StringFilter<"collection"> | string
    title?: StringNullableFilter<"collection"> | string | null
    updated_at?: DateTimeFilter<"collection"> | Date | string
    created_at?: DateTimeFilter<"collection"> | Date | string
    is_custodial?: BoolFilter<"collection"> | boolean
    custodied_for?: UuidNullableFilter<"collection"> | string | null
    miniapp_cover_image?: StringNullableFilter<"collection"> | string | null
  }

  export type project_template_saveCreateWithoutProject_templateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    project_history_id?: string | null
  }

  export type project_template_saveUncheckedCreateWithoutProject_templateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    project_history_id?: string | null
  }

  export type project_template_saveCreateOrConnectWithoutProject_templateInput = {
    where: project_template_saveWhereUniqueInput
    create: XOR<project_template_saveCreateWithoutProject_templateInput, project_template_saveUncheckedCreateWithoutProject_templateInput>
  }

  export type project_template_saveCreateManyProject_templateInputEnvelope = {
    data: project_template_saveCreateManyProject_templateInput | project_template_saveCreateManyProject_templateInput[]
    skipDuplicates?: boolean
  }

  export type project_template_saveUpsertWithWhereUniqueWithoutProject_templateInput = {
    where: project_template_saveWhereUniqueInput
    update: XOR<project_template_saveUpdateWithoutProject_templateInput, project_template_saveUncheckedUpdateWithoutProject_templateInput>
    create: XOR<project_template_saveCreateWithoutProject_templateInput, project_template_saveUncheckedCreateWithoutProject_templateInput>
  }

  export type project_template_saveUpdateWithWhereUniqueWithoutProject_templateInput = {
    where: project_template_saveWhereUniqueInput
    data: XOR<project_template_saveUpdateWithoutProject_templateInput, project_template_saveUncheckedUpdateWithoutProject_templateInput>
  }

  export type project_template_saveUpdateManyWithWhereWithoutProject_templateInput = {
    where: project_template_saveScalarWhereInput
    data: XOR<project_template_saveUpdateManyMutationInput, project_template_saveUncheckedUpdateManyWithoutProject_templateInput>
  }

  export type project_template_saveScalarWhereInput = {
    AND?: project_template_saveScalarWhereInput | project_template_saveScalarWhereInput[]
    OR?: project_template_saveScalarWhereInput[]
    NOT?: project_template_saveScalarWhereInput | project_template_saveScalarWhereInput[]
    id?: BigIntFilter<"project_template_save"> | bigint | number
    name?: StringFilter<"project_template_save"> | string
    data?: JsonFilter<"project_template_save">
    images?: JsonNullableFilter<"project_template_save">
    created_at?: DateTimeFilter<"project_template_save"> | Date | string
    updated_at?: DateTimeNullableFilter<"project_template_save"> | Date | string | null
    project_template_id?: BigIntFilter<"project_template_save"> | bigint | number
    project_history_id?: UuidNullableFilter<"project_template_save"> | string | null
  }

  export type project_templateCreateWithoutProject_template_saveInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    current_project_history_id?: string | null
  }

  export type project_templateUncheckedCreateWithoutProject_template_saveInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    current_project_history_id?: string | null
  }

  export type project_templateCreateOrConnectWithoutProject_template_saveInput = {
    where: project_templateWhereUniqueInput
    create: XOR<project_templateCreateWithoutProject_template_saveInput, project_templateUncheckedCreateWithoutProject_template_saveInput>
  }

  export type project_templateUpsertWithoutProject_template_saveInput = {
    update: XOR<project_templateUpdateWithoutProject_template_saveInput, project_templateUncheckedUpdateWithoutProject_template_saveInput>
    create: XOR<project_templateCreateWithoutProject_template_saveInput, project_templateUncheckedCreateWithoutProject_template_saveInput>
    where?: project_templateWhereInput
  }

  export type project_templateUpdateToOneWithWhereWithoutProject_template_saveInput = {
    where?: project_templateWhereInput
    data: XOR<project_templateUpdateWithoutProject_template_saveInput, project_templateUncheckedUpdateWithoutProject_template_saveInput>
  }

  export type project_templateUpdateWithoutProject_template_saveInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_templateUncheckedUpdateWithoutProject_template_saveInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collection_reward_redemptionCreateWithoutCollection_rewardInput = {
    user_id: string
    wallet_address: string
    token_id: string
    created_at?: Date | string
  }

  export type collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput = {
    id?: number
    user_id: string
    wallet_address: string
    token_id: string
    created_at?: Date | string
  }

  export type collection_reward_redemptionCreateOrConnectWithoutCollection_rewardInput = {
    where: collection_reward_redemptionWhereUniqueInput
    create: XOR<collection_reward_redemptionCreateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput>
  }

  export type collection_reward_redemptionCreateManyCollection_rewardInputEnvelope = {
    data: collection_reward_redemptionCreateManyCollection_rewardInput | collection_reward_redemptionCreateManyCollection_rewardInput[]
    skipDuplicates?: boolean
  }

  export type collection_reward_redemptionUpsertWithWhereUniqueWithoutCollection_rewardInput = {
    where: collection_reward_redemptionWhereUniqueInput
    update: XOR<collection_reward_redemptionUpdateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedUpdateWithoutCollection_rewardInput>
    create: XOR<collection_reward_redemptionCreateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedCreateWithoutCollection_rewardInput>
  }

  export type collection_reward_redemptionUpdateWithWhereUniqueWithoutCollection_rewardInput = {
    where: collection_reward_redemptionWhereUniqueInput
    data: XOR<collection_reward_redemptionUpdateWithoutCollection_rewardInput, collection_reward_redemptionUncheckedUpdateWithoutCollection_rewardInput>
  }

  export type collection_reward_redemptionUpdateManyWithWhereWithoutCollection_rewardInput = {
    where: collection_reward_redemptionScalarWhereInput
    data: XOR<collection_reward_redemptionUpdateManyMutationInput, collection_reward_redemptionUncheckedUpdateManyWithoutCollection_rewardInput>
  }

  export type collection_reward_redemptionScalarWhereInput = {
    AND?: collection_reward_redemptionScalarWhereInput | collection_reward_redemptionScalarWhereInput[]
    OR?: collection_reward_redemptionScalarWhereInput[]
    NOT?: collection_reward_redemptionScalarWhereInput | collection_reward_redemptionScalarWhereInput[]
    id?: IntFilter<"collection_reward_redemption"> | number
    user_id?: StringFilter<"collection_reward_redemption"> | string
    wallet_address?: StringFilter<"collection_reward_redemption"> | string
    token_id?: StringFilter<"collection_reward_redemption"> | string
    collection_reward_id?: IntFilter<"collection_reward_redemption"> | number
    created_at?: DateTimeFilter<"collection_reward_redemption"> | Date | string
  }

  export type collection_rewardCreateWithoutCollection_reward_redemptionInput = {
    collection_id: string
    tag: string
    credits: number
    enabled?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type collection_rewardUncheckedCreateWithoutCollection_reward_redemptionInput = {
    id?: number
    collection_id: string
    tag: string
    credits: number
    enabled?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type collection_rewardCreateOrConnectWithoutCollection_reward_redemptionInput = {
    where: collection_rewardWhereUniqueInput
    create: XOR<collection_rewardCreateWithoutCollection_reward_redemptionInput, collection_rewardUncheckedCreateWithoutCollection_reward_redemptionInput>
  }

  export type collection_rewardUpsertWithoutCollection_reward_redemptionInput = {
    update: XOR<collection_rewardUpdateWithoutCollection_reward_redemptionInput, collection_rewardUncheckedUpdateWithoutCollection_reward_redemptionInput>
    create: XOR<collection_rewardCreateWithoutCollection_reward_redemptionInput, collection_rewardUncheckedCreateWithoutCollection_reward_redemptionInput>
    where?: collection_rewardWhereInput
  }

  export type collection_rewardUpdateToOneWithWhereWithoutCollection_reward_redemptionInput = {
    where?: collection_rewardWhereInput
    data: XOR<collection_rewardUpdateWithoutCollection_reward_redemptionInput, collection_rewardUncheckedUpdateWithoutCollection_reward_redemptionInput>
  }

  export type collection_rewardUpdateWithoutCollection_reward_redemptionInput = {
    collection_id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_rewardUncheckedUpdateWithoutCollection_reward_redemptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collectionCreateWithoutCollection_sales_receiversInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutCollection_sales_receiversInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutCollection_sales_receiversInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutCollection_sales_receiversInput, collectionUncheckedCreateWithoutCollection_sales_receiversInput>
  }

  export type collectionUpsertWithoutCollection_sales_receiversInput = {
    update: XOR<collectionUpdateWithoutCollection_sales_receiversInput, collectionUncheckedUpdateWithoutCollection_sales_receiversInput>
    create: XOR<collectionCreateWithoutCollection_sales_receiversInput, collectionUncheckedCreateWithoutCollection_sales_receiversInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutCollection_sales_receiversInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutCollection_sales_receiversInput, collectionUncheckedUpdateWithoutCollection_sales_receiversInput>
  }

  export type collectionUpdateWithoutCollection_sales_receiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutCollection_sales_receiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionCreateWithoutCollection_historyInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutCollection_historyInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutCollection_historyInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutCollection_historyInput, collectionUncheckedCreateWithoutCollection_historyInput>
  }

  export type collectionUpsertWithoutCollection_historyInput = {
    update: XOR<collectionUpdateWithoutCollection_historyInput, collectionUncheckedUpdateWithoutCollection_historyInput>
    create: XOR<collectionCreateWithoutCollection_historyInput, collectionUncheckedCreateWithoutCollection_historyInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutCollection_historyInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutCollection_historyInput, collectionUncheckedUpdateWithoutCollection_historyInput>
  }

  export type collectionUpdateWithoutCollection_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutCollection_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionCreateWithoutCollection_previewInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutCollection_previewInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutCollection_previewInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutCollection_previewInput, collectionUncheckedCreateWithoutCollection_previewInput>
  }

  export type collection_preview_versionCreateWithoutCollection_previewInput = {
    id?: bigint | number
    version?: number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
    collection_remix?: collection_remixCreateNestedManyWithoutCollection_preview_versionInput
  }

  export type collection_preview_versionUncheckedCreateWithoutCollection_previewInput = {
    id?: bigint | number
    version?: number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
    collection_remix?: collection_remixUncheckedCreateNestedManyWithoutCollection_preview_versionInput
  }

  export type collection_preview_versionCreateOrConnectWithoutCollection_previewInput = {
    where: collection_preview_versionWhereUniqueInput
    create: XOR<collection_preview_versionCreateWithoutCollection_previewInput, collection_preview_versionUncheckedCreateWithoutCollection_previewInput>
  }

  export type collection_preview_versionCreateManyCollection_previewInputEnvelope = {
    data: collection_preview_versionCreateManyCollection_previewInput | collection_preview_versionCreateManyCollection_previewInput[]
    skipDuplicates?: boolean
  }

  export type collectionUpsertWithoutCollection_previewInput = {
    update: XOR<collectionUpdateWithoutCollection_previewInput, collectionUncheckedUpdateWithoutCollection_previewInput>
    create: XOR<collectionCreateWithoutCollection_previewInput, collectionUncheckedCreateWithoutCollection_previewInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutCollection_previewInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutCollection_previewInput, collectionUncheckedUpdateWithoutCollection_previewInput>
  }

  export type collectionUpdateWithoutCollection_previewInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutCollection_previewInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collection_preview_versionUpsertWithWhereUniqueWithoutCollection_previewInput = {
    where: collection_preview_versionWhereUniqueInput
    update: XOR<collection_preview_versionUpdateWithoutCollection_previewInput, collection_preview_versionUncheckedUpdateWithoutCollection_previewInput>
    create: XOR<collection_preview_versionCreateWithoutCollection_previewInput, collection_preview_versionUncheckedCreateWithoutCollection_previewInput>
  }

  export type collection_preview_versionUpdateWithWhereUniqueWithoutCollection_previewInput = {
    where: collection_preview_versionWhereUniqueInput
    data: XOR<collection_preview_versionUpdateWithoutCollection_previewInput, collection_preview_versionUncheckedUpdateWithoutCollection_previewInput>
  }

  export type collection_preview_versionUpdateManyWithWhereWithoutCollection_previewInput = {
    where: collection_preview_versionScalarWhereInput
    data: XOR<collection_preview_versionUpdateManyMutationInput, collection_preview_versionUncheckedUpdateManyWithoutCollection_previewInput>
  }

  export type collection_preview_versionScalarWhereInput = {
    AND?: collection_preview_versionScalarWhereInput | collection_preview_versionScalarWhereInput[]
    OR?: collection_preview_versionScalarWhereInput[]
    NOT?: collection_preview_versionScalarWhereInput | collection_preview_versionScalarWhereInput[]
    id?: BigIntFilter<"collection_preview_version"> | bigint | number
    version?: IntFilter<"collection_preview_version"> | number
    collection_preview_id?: BigIntFilter<"collection_preview_version"> | bigint | number
    data?: JsonFilter<"collection_preview_version">
    is_latest?: BoolFilter<"collection_preview_version"> | boolean
    created_at?: DateTimeNullableFilter<"collection_preview_version"> | Date | string | null
  }

  export type collection_previewCreateWithoutCollection_preview_versionInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
    collection: collectionCreateNestedOneWithoutCollection_previewInput
  }

  export type collection_previewUncheckedCreateWithoutCollection_preview_versionInput = {
    id?: bigint | number
    enabled?: boolean
    max_generations?: number
    total_generations?: number
    collection_id: string
    access_level?: string
    is_remixable?: boolean
    farcaster_collection?: boolean
  }

  export type collection_previewCreateOrConnectWithoutCollection_preview_versionInput = {
    where: collection_previewWhereUniqueInput
    create: XOR<collection_previewCreateWithoutCollection_preview_versionInput, collection_previewUncheckedCreateWithoutCollection_preview_versionInput>
  }

  export type collection_remixCreateWithoutCollection_preview_versionInput = {
    id?: bigint | number
    created_at?: Date | string | null
    source_collection: collectionCreateNestedOneWithoutSource_remixInput
    target_collection: collectionCreateNestedOneWithoutTarget_remixInput
  }

  export type collection_remixUncheckedCreateWithoutCollection_preview_versionInput = {
    id?: bigint | number
    source_collection_id: string
    target_collection_id: string
    created_at?: Date | string | null
  }

  export type collection_remixCreateOrConnectWithoutCollection_preview_versionInput = {
    where: collection_remixWhereUniqueInput
    create: XOR<collection_remixCreateWithoutCollection_preview_versionInput, collection_remixUncheckedCreateWithoutCollection_preview_versionInput>
  }

  export type collection_remixCreateManyCollection_preview_versionInputEnvelope = {
    data: collection_remixCreateManyCollection_preview_versionInput | collection_remixCreateManyCollection_preview_versionInput[]
    skipDuplicates?: boolean
  }

  export type collection_previewUpsertWithoutCollection_preview_versionInput = {
    update: XOR<collection_previewUpdateWithoutCollection_preview_versionInput, collection_previewUncheckedUpdateWithoutCollection_preview_versionInput>
    create: XOR<collection_previewCreateWithoutCollection_preview_versionInput, collection_previewUncheckedCreateWithoutCollection_preview_versionInput>
    where?: collection_previewWhereInput
  }

  export type collection_previewUpdateToOneWithWhereWithoutCollection_preview_versionInput = {
    where?: collection_previewWhereInput
    data: XOR<collection_previewUpdateWithoutCollection_preview_versionInput, collection_previewUncheckedUpdateWithoutCollection_preview_versionInput>
  }

  export type collection_previewUpdateWithoutCollection_preview_versionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
    collection?: collectionUpdateOneRequiredWithoutCollection_previewNestedInput
  }

  export type collection_previewUncheckedUpdateWithoutCollection_preview_versionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    max_generations?: IntFieldUpdateOperationsInput | number
    total_generations?: IntFieldUpdateOperationsInput | number
    collection_id?: StringFieldUpdateOperationsInput | string
    access_level?: StringFieldUpdateOperationsInput | string
    is_remixable?: BoolFieldUpdateOperationsInput | boolean
    farcaster_collection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type collection_remixUpsertWithWhereUniqueWithoutCollection_preview_versionInput = {
    where: collection_remixWhereUniqueInput
    update: XOR<collection_remixUpdateWithoutCollection_preview_versionInput, collection_remixUncheckedUpdateWithoutCollection_preview_versionInput>
    create: XOR<collection_remixCreateWithoutCollection_preview_versionInput, collection_remixUncheckedCreateWithoutCollection_preview_versionInput>
  }

  export type collection_remixUpdateWithWhereUniqueWithoutCollection_preview_versionInput = {
    where: collection_remixWhereUniqueInput
    data: XOR<collection_remixUpdateWithoutCollection_preview_versionInput, collection_remixUncheckedUpdateWithoutCollection_preview_versionInput>
  }

  export type collection_remixUpdateManyWithWhereWithoutCollection_preview_versionInput = {
    where: collection_remixScalarWhereInput
    data: XOR<collection_remixUpdateManyMutationInput, collection_remixUncheckedUpdateManyWithoutCollection_preview_versionInput>
  }

  export type collectionCreateWithoutCollection_sample_imagesInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutCollection_sample_imagesInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutCollection_sample_imagesInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutCollection_sample_imagesInput, collectionUncheckedCreateWithoutCollection_sample_imagesInput>
  }

  export type collectionUpsertWithoutCollection_sample_imagesInput = {
    update: XOR<collectionUpdateWithoutCollection_sample_imagesInput, collectionUncheckedUpdateWithoutCollection_sample_imagesInput>
    create: XOR<collectionCreateWithoutCollection_sample_imagesInput, collectionUncheckedCreateWithoutCollection_sample_imagesInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutCollection_sample_imagesInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutCollection_sample_imagesInput, collectionUncheckedUpdateWithoutCollection_sample_imagesInput>
  }

  export type collectionUpdateWithoutCollection_sample_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutCollection_sample_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type chat_messageCreateWithoutChatInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    flat_file?: flat_fileCreateNestedOneWithoutChat_messageInput
  }

  export type chat_messageUncheckedCreateWithoutChatInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    flat_file_id?: bigint | number | null
  }

  export type chat_messageCreateOrConnectWithoutChatInput = {
    where: chat_messageWhereUniqueInput
    create: XOR<chat_messageCreateWithoutChatInput, chat_messageUncheckedCreateWithoutChatInput>
  }

  export type chat_messageCreateManyChatInputEnvelope = {
    data: chat_messageCreateManyChatInput | chat_messageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type chat_messageUpsertWithWhereUniqueWithoutChatInput = {
    where: chat_messageWhereUniqueInput
    update: XOR<chat_messageUpdateWithoutChatInput, chat_messageUncheckedUpdateWithoutChatInput>
    create: XOR<chat_messageCreateWithoutChatInput, chat_messageUncheckedCreateWithoutChatInput>
  }

  export type chat_messageUpdateWithWhereUniqueWithoutChatInput = {
    where: chat_messageWhereUniqueInput
    data: XOR<chat_messageUpdateWithoutChatInput, chat_messageUncheckedUpdateWithoutChatInput>
  }

  export type chat_messageUpdateManyWithWhereWithoutChatInput = {
    where: chat_messageScalarWhereInput
    data: XOR<chat_messageUpdateManyMutationInput, chat_messageUncheckedUpdateManyWithoutChatInput>
  }

  export type chatCreateWithoutChat_messageInput = {
    id?: string
    created_at?: Date | string | null
    entity_type: string
    entity_id: string
  }

  export type chatUncheckedCreateWithoutChat_messageInput = {
    id?: string
    created_at?: Date | string | null
    entity_type: string
    entity_id: string
  }

  export type chatCreateOrConnectWithoutChat_messageInput = {
    where: chatWhereUniqueInput
    create: XOR<chatCreateWithoutChat_messageInput, chatUncheckedCreateWithoutChat_messageInput>
  }

  export type flat_fileCreateWithoutChat_messageInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
    component_flat_files?: component_flat_fileCreateNestedManyWithoutFlat_fileInput
  }

  export type flat_fileUncheckedCreateWithoutChat_messageInput = {
    id?: bigint | number
    created_at?: Date | string | null
    url?: string | null
    hidden?: boolean | null
    user_id: string
    name: string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: string | null
    rel_id?: string | null
    rel_type?: string | null
    tags?: flat_fileCreatetagsInput | string[]
    component_flat_files?: component_flat_fileUncheckedCreateNestedManyWithoutFlat_fileInput
  }

  export type flat_fileCreateOrConnectWithoutChat_messageInput = {
    where: flat_fileWhereUniqueInput
    create: XOR<flat_fileCreateWithoutChat_messageInput, flat_fileUncheckedCreateWithoutChat_messageInput>
  }

  export type chatUpsertWithoutChat_messageInput = {
    update: XOR<chatUpdateWithoutChat_messageInput, chatUncheckedUpdateWithoutChat_messageInput>
    create: XOR<chatCreateWithoutChat_messageInput, chatUncheckedCreateWithoutChat_messageInput>
    where?: chatWhereInput
  }

  export type chatUpdateToOneWithWhereWithoutChat_messageInput = {
    where?: chatWhereInput
    data: XOR<chatUpdateWithoutChat_messageInput, chatUncheckedUpdateWithoutChat_messageInput>
  }

  export type chatUpdateWithoutChat_messageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type chatUncheckedUpdateWithoutChat_messageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
  }

  export type flat_fileUpsertWithoutChat_messageInput = {
    update: XOR<flat_fileUpdateWithoutChat_messageInput, flat_fileUncheckedUpdateWithoutChat_messageInput>
    create: XOR<flat_fileCreateWithoutChat_messageInput, flat_fileUncheckedCreateWithoutChat_messageInput>
    where?: flat_fileWhereInput
  }

  export type flat_fileUpdateToOneWithWhereWithoutChat_messageInput = {
    where?: flat_fileWhereInput
    data: XOR<flat_fileUpdateWithoutChat_messageInput, flat_fileUncheckedUpdateWithoutChat_messageInput>
  }

  export type flat_fileUpdateWithoutChat_messageInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
    component_flat_files?: component_flat_fileUpdateManyWithoutFlat_fileNestedInput
  }

  export type flat_fileUncheckedUpdateWithoutChat_messageInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hidden?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gen_in_data?: NullableJsonNullValueInput | InputJsonValue
    gen_out_data?: NullableJsonNullValueInput | InputJsonValue
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    rel_id?: NullableStringFieldUpdateOperationsInput | string | null
    rel_type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: flat_fileUpdatetagsInput | string[]
    component_flat_files?: component_flat_fileUncheckedUpdateManyWithoutFlat_fileNestedInput
  }

  export type collectionCreateWithoutCollection_nodeInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutCollection_nodeInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutCollection_nodeInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutCollection_nodeInput, collectionUncheckedCreateWithoutCollection_nodeInput>
  }

  export type component_flat_fileCreateWithoutComponentInput = {
    id?: bigint | number
    flat_file: flat_fileCreateNestedOneWithoutComponent_flat_filesInput
  }

  export type component_flat_fileUncheckedCreateWithoutComponentInput = {
    id?: bigint | number
    flat_file_id: bigint | number
  }

  export type component_flat_fileCreateOrConnectWithoutComponentInput = {
    where: component_flat_fileWhereUniqueInput
    create: XOR<component_flat_fileCreateWithoutComponentInput, component_flat_fileUncheckedCreateWithoutComponentInput>
  }

  export type component_flat_fileCreateManyComponentInputEnvelope = {
    data: component_flat_fileCreateManyComponentInput | component_flat_fileCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type collectionUpsertWithoutCollection_nodeInput = {
    update: XOR<collectionUpdateWithoutCollection_nodeInput, collectionUncheckedUpdateWithoutCollection_nodeInput>
    create: XOR<collectionCreateWithoutCollection_nodeInput, collectionUncheckedCreateWithoutCollection_nodeInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutCollection_nodeInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutCollection_nodeInput, collectionUncheckedUpdateWithoutCollection_nodeInput>
  }

  export type collectionUpdateWithoutCollection_nodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutCollection_nodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type component_flat_fileUpsertWithWhereUniqueWithoutComponentInput = {
    where: component_flat_fileWhereUniqueInput
    update: XOR<component_flat_fileUpdateWithoutComponentInput, component_flat_fileUncheckedUpdateWithoutComponentInput>
    create: XOR<component_flat_fileCreateWithoutComponentInput, component_flat_fileUncheckedCreateWithoutComponentInput>
  }

  export type component_flat_fileUpdateWithWhereUniqueWithoutComponentInput = {
    where: component_flat_fileWhereUniqueInput
    data: XOR<component_flat_fileUpdateWithoutComponentInput, component_flat_fileUncheckedUpdateWithoutComponentInput>
  }

  export type component_flat_fileUpdateManyWithWhereWithoutComponentInput = {
    where: component_flat_fileScalarWhereInput
    data: XOR<component_flat_fileUpdateManyMutationInput, component_flat_fileUncheckedUpdateManyWithoutComponentInput>
  }

  export type serverCreateWithoutWorkflowInput = {
    id?: string
    name: string
    url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type serverUncheckedCreateWithoutWorkflowInput = {
    id?: string
    name: string
    url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type serverCreateOrConnectWithoutWorkflowInput = {
    where: serverWhereUniqueInput
    create: XOR<serverCreateWithoutWorkflowInput, serverUncheckedCreateWithoutWorkflowInput>
  }

  export type workflow_custom_nodesCreateWithoutWorkflowInput = {
    id?: bigint | number
    created_at?: Date | string
    custom_nodes: custom_nodesCreateNestedOneWithoutWorkflow_custom_nodesInput
  }

  export type workflow_custom_nodesUncheckedCreateWithoutWorkflowInput = {
    id?: bigint | number
    custom_node_id: string
    created_at?: Date | string
  }

  export type workflow_custom_nodesCreateOrConnectWithoutWorkflowInput = {
    where: workflow_custom_nodesWhereUniqueInput
    create: XOR<workflow_custom_nodesCreateWithoutWorkflowInput, workflow_custom_nodesUncheckedCreateWithoutWorkflowInput>
  }

  export type workflow_custom_nodesCreateManyWorkflowInputEnvelope = {
    data: workflow_custom_nodesCreateManyWorkflowInput | workflow_custom_nodesCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowModelCreateWithoutWorkflowInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    model: ModelCreateNestedOneWithoutWorkflowModelsInput
  }

  export type WorkflowModelUncheckedCreateWithoutWorkflowInput = {
    id?: string
    modelId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type WorkflowModelCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowModelWhereUniqueInput
    create: XOR<WorkflowModelCreateWithoutWorkflowInput, WorkflowModelUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowModelCreateManyWorkflowInputEnvelope = {
    data: WorkflowModelCreateManyWorkflowInput | WorkflowModelCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type serverUpsertWithoutWorkflowInput = {
    update: XOR<serverUpdateWithoutWorkflowInput, serverUncheckedUpdateWithoutWorkflowInput>
    create: XOR<serverCreateWithoutWorkflowInput, serverUncheckedCreateWithoutWorkflowInput>
    where?: serverWhereInput
  }

  export type serverUpdateToOneWithWhereWithoutWorkflowInput = {
    where?: serverWhereInput
    data: XOR<serverUpdateWithoutWorkflowInput, serverUncheckedUpdateWithoutWorkflowInput>
  }

  export type serverUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serverUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workflow_custom_nodesUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: workflow_custom_nodesWhereUniqueInput
    update: XOR<workflow_custom_nodesUpdateWithoutWorkflowInput, workflow_custom_nodesUncheckedUpdateWithoutWorkflowInput>
    create: XOR<workflow_custom_nodesCreateWithoutWorkflowInput, workflow_custom_nodesUncheckedCreateWithoutWorkflowInput>
  }

  export type workflow_custom_nodesUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: workflow_custom_nodesWhereUniqueInput
    data: XOR<workflow_custom_nodesUpdateWithoutWorkflowInput, workflow_custom_nodesUncheckedUpdateWithoutWorkflowInput>
  }

  export type workflow_custom_nodesUpdateManyWithWhereWithoutWorkflowInput = {
    where: workflow_custom_nodesScalarWhereInput
    data: XOR<workflow_custom_nodesUpdateManyMutationInput, workflow_custom_nodesUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type workflow_custom_nodesScalarWhereInput = {
    AND?: workflow_custom_nodesScalarWhereInput | workflow_custom_nodesScalarWhereInput[]
    OR?: workflow_custom_nodesScalarWhereInput[]
    NOT?: workflow_custom_nodesScalarWhereInput | workflow_custom_nodesScalarWhereInput[]
    id?: BigIntFilter<"workflow_custom_nodes"> | bigint | number
    workflow_id?: UuidFilter<"workflow_custom_nodes"> | string
    custom_node_id?: UuidFilter<"workflow_custom_nodes"> | string
    created_at?: DateTimeFilter<"workflow_custom_nodes"> | Date | string
  }

  export type WorkflowModelUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowModelWhereUniqueInput
    update: XOR<WorkflowModelUpdateWithoutWorkflowInput, WorkflowModelUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowModelCreateWithoutWorkflowInput, WorkflowModelUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowModelUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowModelWhereUniqueInput
    data: XOR<WorkflowModelUpdateWithoutWorkflowInput, WorkflowModelUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowModelUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowModelScalarWhereInput
    data: XOR<WorkflowModelUpdateManyMutationInput, WorkflowModelUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowModelScalarWhereInput = {
    AND?: WorkflowModelScalarWhereInput | WorkflowModelScalarWhereInput[]
    OR?: WorkflowModelScalarWhereInput[]
    NOT?: WorkflowModelScalarWhereInput | WorkflowModelScalarWhereInput[]
    id?: StringFilter<"WorkflowModel"> | string
    workflowId?: UuidFilter<"WorkflowModel"> | string
    modelId?: StringFilter<"WorkflowModel"> | string
    isRequired?: BoolFilter<"WorkflowModel"> | boolean
    createdAt?: DateTimeFilter<"WorkflowModel"> | Date | string
  }

  export type workflowCreateWithoutServerInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    workflow_custom_nodes?: workflow_custom_nodesCreateNestedManyWithoutWorkflowInput
    workflow_models?: WorkflowModelCreateNestedManyWithoutWorkflowInput
  }

  export type workflowUncheckedCreateWithoutServerInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedCreateNestedManyWithoutWorkflowInput
    workflow_models?: WorkflowModelUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type workflowCreateOrConnectWithoutServerInput = {
    where: workflowWhereUniqueInput
    create: XOR<workflowCreateWithoutServerInput, workflowUncheckedCreateWithoutServerInput>
  }

  export type workflowCreateManyServerInputEnvelope = {
    data: workflowCreateManyServerInput | workflowCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type workflowUpsertWithWhereUniqueWithoutServerInput = {
    where: workflowWhereUniqueInput
    update: XOR<workflowUpdateWithoutServerInput, workflowUncheckedUpdateWithoutServerInput>
    create: XOR<workflowCreateWithoutServerInput, workflowUncheckedCreateWithoutServerInput>
  }

  export type workflowUpdateWithWhereUniqueWithoutServerInput = {
    where: workflowWhereUniqueInput
    data: XOR<workflowUpdateWithoutServerInput, workflowUncheckedUpdateWithoutServerInput>
  }

  export type workflowUpdateManyWithWhereWithoutServerInput = {
    where: workflowScalarWhereInput
    data: XOR<workflowUpdateManyMutationInput, workflowUncheckedUpdateManyWithoutServerInput>
  }

  export type workflowScalarWhereInput = {
    AND?: workflowScalarWhereInput | workflowScalarWhereInput[]
    OR?: workflowScalarWhereInput[]
    NOT?: workflowScalarWhereInput | workflowScalarWhereInput[]
    id?: UuidFilter<"workflow"> | string
    name?: StringFilter<"workflow"> | string
    description?: StringNullableFilter<"workflow"> | string | null
    data?: JsonNullableFilter<"workflow">
    created_at?: DateTimeFilter<"workflow"> | Date | string
    server_id?: UuidNullableFilter<"workflow"> | string | null
    output_mime_type?: StringNullableFilter<"workflow"> | string | null
    display?: BoolNullableFilter<"workflow"> | boolean | null
    label?: StringNullableFilter<"workflow"> | string | null
    order?: IntNullableFilter<"workflow"> | number | null
    type?: StringNullableFilter<"workflow"> | string | null
    est_gen_time?: JsonNullableFilter<"workflow">
    machine_type?: StringNullableFilter<"workflow"> | string | null
    min_vram?: IntNullableFilter<"workflow"> | number | null
  }

  export type job_historyCreateWithoutJobInput = {
    id?: string
    status: string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    message?: string | null
  }

  export type job_historyUncheckedCreateWithoutJobInput = {
    id?: string
    status: string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    message?: string | null
  }

  export type job_historyCreateOrConnectWithoutJobInput = {
    where: job_historyWhereUniqueInput
    create: XOR<job_historyCreateWithoutJobInput, job_historyUncheckedCreateWithoutJobInput>
  }

  export type job_historyCreateManyJobInputEnvelope = {
    data: job_historyCreateManyJobInput | job_historyCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type job_historyUpsertWithWhereUniqueWithoutJobInput = {
    where: job_historyWhereUniqueInput
    update: XOR<job_historyUpdateWithoutJobInput, job_historyUncheckedUpdateWithoutJobInput>
    create: XOR<job_historyCreateWithoutJobInput, job_historyUncheckedCreateWithoutJobInput>
  }

  export type job_historyUpdateWithWhereUniqueWithoutJobInput = {
    where: job_historyWhereUniqueInput
    data: XOR<job_historyUpdateWithoutJobInput, job_historyUncheckedUpdateWithoutJobInput>
  }

  export type job_historyUpdateManyWithWhereWithoutJobInput = {
    where: job_historyScalarWhereInput
    data: XOR<job_historyUpdateManyMutationInput, job_historyUncheckedUpdateManyWithoutJobInput>
  }

  export type job_historyScalarWhereInput = {
    AND?: job_historyScalarWhereInput | job_historyScalarWhereInput[]
    OR?: job_historyScalarWhereInput[]
    NOT?: job_historyScalarWhereInput | job_historyScalarWhereInput[]
    id?: UuidFilter<"job_history"> | string
    job_id?: UuidFilter<"job_history"> | string
    status?: StringFilter<"job_history"> | string
    data?: JsonNullableFilter<"job_history">
    created_at?: DateTimeFilter<"job_history"> | Date | string
    message?: StringNullableFilter<"job_history"> | string | null
  }

  export type jobCreateWithoutJob_historyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: number | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    user_id: string
    job_type: string
    priority?: number
  }

  export type jobUncheckedCreateWithoutJob_historyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: number | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    user_id: string
    job_type: string
    priority?: number
  }

  export type jobCreateOrConnectWithoutJob_historyInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_historyInput, jobUncheckedCreateWithoutJob_historyInput>
  }

  export type jobUpsertWithoutJob_historyInput = {
    update: XOR<jobUpdateWithoutJob_historyInput, jobUncheckedUpdateWithoutJob_historyInput>
    create: XOR<jobCreateWithoutJob_historyInput, jobUncheckedCreateWithoutJob_historyInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_historyInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_historyInput, jobUncheckedUpdateWithoutJob_historyInput>
  }

  export type jobUpdateWithoutJob_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type jobUncheckedUpdateWithoutJob_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    job_type?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationCreateWithoutMiniapp_userInput = {
    id?: string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
    collection: collectionCreateNestedOneWithoutMiniapp_generationInput
    miniapp_payment?: miniapp_paymentCreateNestedOneWithoutMiniapp_generationInput
  }

  export type miniapp_generationUncheckedCreateWithoutMiniapp_userInput = {
    id?: string
    collection_id: string
    payment_id?: string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_generationCreateOrConnectWithoutMiniapp_userInput = {
    where: miniapp_generationWhereUniqueInput
    create: XOR<miniapp_generationCreateWithoutMiniapp_userInput, miniapp_generationUncheckedCreateWithoutMiniapp_userInput>
  }

  export type miniapp_generationCreateManyMiniapp_userInputEnvelope = {
    data: miniapp_generationCreateManyMiniapp_userInput | miniapp_generationCreateManyMiniapp_userInput[]
    skipDuplicates?: boolean
  }

  export type miniapp_paymentCreateWithoutMiniapp_userInput = {
    id?: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutMiniapp_paymentInput
    collection: collectionCreateNestedOneWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentUncheckedCreateWithoutMiniapp_userInput = {
    id?: string
    collection_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentCreateOrConnectWithoutMiniapp_userInput = {
    where: miniapp_paymentWhereUniqueInput
    create: XOR<miniapp_paymentCreateWithoutMiniapp_userInput, miniapp_paymentUncheckedCreateWithoutMiniapp_userInput>
  }

  export type miniapp_paymentCreateManyMiniapp_userInputEnvelope = {
    data: miniapp_paymentCreateManyMiniapp_userInput | miniapp_paymentCreateManyMiniapp_userInput[]
    skipDuplicates?: boolean
  }

  export type social_linkCreateWithoutMiniapp_userInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    custodial_collections?: collectionCreateNestedManyWithoutSocial_linkInput
  }

  export type social_linkUncheckedCreateWithoutMiniapp_userInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
    custodial_collections?: collectionUncheckedCreateNestedManyWithoutSocial_linkInput
  }

  export type social_linkCreateOrConnectWithoutMiniapp_userInput = {
    where: social_linkWhereUniqueInput
    create: XOR<social_linkCreateWithoutMiniapp_userInput, social_linkUncheckedCreateWithoutMiniapp_userInput>
  }

  export type social_linkCreateManyMiniapp_userInputEnvelope = {
    data: social_linkCreateManyMiniapp_userInput | social_linkCreateManyMiniapp_userInput[]
    skipDuplicates?: boolean
  }

  export type miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_userInput = {
    where: miniapp_generationWhereUniqueInput
    update: XOR<miniapp_generationUpdateWithoutMiniapp_userInput, miniapp_generationUncheckedUpdateWithoutMiniapp_userInput>
    create: XOR<miniapp_generationCreateWithoutMiniapp_userInput, miniapp_generationUncheckedCreateWithoutMiniapp_userInput>
  }

  export type miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_userInput = {
    where: miniapp_generationWhereUniqueInput
    data: XOR<miniapp_generationUpdateWithoutMiniapp_userInput, miniapp_generationUncheckedUpdateWithoutMiniapp_userInput>
  }

  export type miniapp_generationUpdateManyWithWhereWithoutMiniapp_userInput = {
    where: miniapp_generationScalarWhereInput
    data: XOR<miniapp_generationUpdateManyMutationInput, miniapp_generationUncheckedUpdateManyWithoutMiniapp_userInput>
  }

  export type miniapp_paymentUpsertWithWhereUniqueWithoutMiniapp_userInput = {
    where: miniapp_paymentWhereUniqueInput
    update: XOR<miniapp_paymentUpdateWithoutMiniapp_userInput, miniapp_paymentUncheckedUpdateWithoutMiniapp_userInput>
    create: XOR<miniapp_paymentCreateWithoutMiniapp_userInput, miniapp_paymentUncheckedCreateWithoutMiniapp_userInput>
  }

  export type miniapp_paymentUpdateWithWhereUniqueWithoutMiniapp_userInput = {
    where: miniapp_paymentWhereUniqueInput
    data: XOR<miniapp_paymentUpdateWithoutMiniapp_userInput, miniapp_paymentUncheckedUpdateWithoutMiniapp_userInput>
  }

  export type miniapp_paymentUpdateManyWithWhereWithoutMiniapp_userInput = {
    where: miniapp_paymentScalarWhereInput
    data: XOR<miniapp_paymentUpdateManyMutationInput, miniapp_paymentUncheckedUpdateManyWithoutMiniapp_userInput>
  }

  export type social_linkUpsertWithWhereUniqueWithoutMiniapp_userInput = {
    where: social_linkWhereUniqueInput
    update: XOR<social_linkUpdateWithoutMiniapp_userInput, social_linkUncheckedUpdateWithoutMiniapp_userInput>
    create: XOR<social_linkCreateWithoutMiniapp_userInput, social_linkUncheckedCreateWithoutMiniapp_userInput>
  }

  export type social_linkUpdateWithWhereUniqueWithoutMiniapp_userInput = {
    where: social_linkWhereUniqueInput
    data: XOR<social_linkUpdateWithoutMiniapp_userInput, social_linkUncheckedUpdateWithoutMiniapp_userInput>
  }

  export type social_linkUpdateManyWithWhereWithoutMiniapp_userInput = {
    where: social_linkScalarWhereInput
    data: XOR<social_linkUpdateManyMutationInput, social_linkUncheckedUpdateManyWithoutMiniapp_userInput>
  }

  export type social_linkScalarWhereInput = {
    AND?: social_linkScalarWhereInput | social_linkScalarWhereInput[]
    OR?: social_linkScalarWhereInput[]
    NOT?: social_linkScalarWhereInput | social_linkScalarWhereInput[]
    id?: UuidFilter<"social_link"> | string
    social_org?: Enumsocial_org_enumFilter<"social_link"> | $Enums.social_org_enum
    identifier?: StringFilter<"social_link"> | string
    created_at?: DateTimeFilter<"social_link"> | Date | string
    updated_at?: DateTimeFilter<"social_link"> | Date | string
    miniapp_user_id?: UuidNullableFilter<"social_link"> | string | null
  }

  export type collectionCreateWithoutMiniapp_collection_configInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutMiniapp_collection_configInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutMiniapp_collection_configInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutMiniapp_collection_configInput, collectionUncheckedCreateWithoutMiniapp_collection_configInput>
  }

  export type collectionUpsertWithoutMiniapp_collection_configInput = {
    update: XOR<collectionUpdateWithoutMiniapp_collection_configInput, collectionUncheckedUpdateWithoutMiniapp_collection_configInput>
    create: XOR<collectionCreateWithoutMiniapp_collection_configInput, collectionUncheckedCreateWithoutMiniapp_collection_configInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutMiniapp_collection_configInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutMiniapp_collection_configInput, collectionUncheckedUpdateWithoutMiniapp_collection_configInput>
  }

  export type collectionUpdateWithoutMiniapp_collection_configInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutMiniapp_collection_configInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type miniapp_generationCreateWithoutMiniapp_paymentInput = {
    id?: string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
    collection: collectionCreateNestedOneWithoutMiniapp_generationInput
    miniapp_user: miniapp_userCreateNestedOneWithoutMiniapp_generationInput
  }

  export type miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput = {
    id?: string
    user_id: string
    collection_id: string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_generationCreateOrConnectWithoutMiniapp_paymentInput = {
    where: miniapp_generationWhereUniqueInput
    create: XOR<miniapp_generationCreateWithoutMiniapp_paymentInput, miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput>
  }

  export type miniapp_generationCreateManyMiniapp_paymentInputEnvelope = {
    data: miniapp_generationCreateManyMiniapp_paymentInput | miniapp_generationCreateManyMiniapp_paymentInput[]
    skipDuplicates?: boolean
  }

  export type collectionCreateWithoutMiniapp_paymentInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutMiniapp_paymentInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutMiniapp_paymentInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutMiniapp_paymentInput, collectionUncheckedCreateWithoutMiniapp_paymentInput>
  }

  export type miniapp_userCreateWithoutMiniapp_paymentInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutMiniapp_userInput
    social_links?: social_linkCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userUncheckedCreateWithoutMiniapp_paymentInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_userInput
    social_links?: social_linkUncheckedCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userCreateOrConnectWithoutMiniapp_paymentInput = {
    where: miniapp_userWhereUniqueInput
    create: XOR<miniapp_userCreateWithoutMiniapp_paymentInput, miniapp_userUncheckedCreateWithoutMiniapp_paymentInput>
  }

  export type miniapp_generationUpsertWithWhereUniqueWithoutMiniapp_paymentInput = {
    where: miniapp_generationWhereUniqueInput
    update: XOR<miniapp_generationUpdateWithoutMiniapp_paymentInput, miniapp_generationUncheckedUpdateWithoutMiniapp_paymentInput>
    create: XOR<miniapp_generationCreateWithoutMiniapp_paymentInput, miniapp_generationUncheckedCreateWithoutMiniapp_paymentInput>
  }

  export type miniapp_generationUpdateWithWhereUniqueWithoutMiniapp_paymentInput = {
    where: miniapp_generationWhereUniqueInput
    data: XOR<miniapp_generationUpdateWithoutMiniapp_paymentInput, miniapp_generationUncheckedUpdateWithoutMiniapp_paymentInput>
  }

  export type miniapp_generationUpdateManyWithWhereWithoutMiniapp_paymentInput = {
    where: miniapp_generationScalarWhereInput
    data: XOR<miniapp_generationUpdateManyMutationInput, miniapp_generationUncheckedUpdateManyWithoutMiniapp_paymentInput>
  }

  export type collectionUpsertWithoutMiniapp_paymentInput = {
    update: XOR<collectionUpdateWithoutMiniapp_paymentInput, collectionUncheckedUpdateWithoutMiniapp_paymentInput>
    create: XOR<collectionCreateWithoutMiniapp_paymentInput, collectionUncheckedCreateWithoutMiniapp_paymentInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutMiniapp_paymentInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutMiniapp_paymentInput, collectionUncheckedUpdateWithoutMiniapp_paymentInput>
  }

  export type collectionUpdateWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type miniapp_userUpsertWithoutMiniapp_paymentInput = {
    update: XOR<miniapp_userUpdateWithoutMiniapp_paymentInput, miniapp_userUncheckedUpdateWithoutMiniapp_paymentInput>
    create: XOR<miniapp_userCreateWithoutMiniapp_paymentInput, miniapp_userUncheckedCreateWithoutMiniapp_paymentInput>
    where?: miniapp_userWhereInput
  }

  export type miniapp_userUpdateToOneWithWhereWithoutMiniapp_paymentInput = {
    where?: miniapp_userWhereInput
    data: XOR<miniapp_userUpdateWithoutMiniapp_paymentInput, miniapp_userUncheckedUpdateWithoutMiniapp_paymentInput>
  }

  export type miniapp_userUpdateWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_generation?: miniapp_generationUpdateManyWithoutMiniapp_userNestedInput
    social_links?: social_linkUpdateManyWithoutMiniapp_userNestedInput
  }

  export type miniapp_userUncheckedUpdateWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutMiniapp_userNestedInput
    social_links?: social_linkUncheckedUpdateManyWithoutMiniapp_userNestedInput
  }

  export type collectionCreateWithoutMiniapp_generationInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    social_link?: social_linkCreateNestedOneWithoutCustodial_collectionsInput
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutMiniapp_generationInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutMiniapp_generationInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutMiniapp_generationInput, collectionUncheckedCreateWithoutMiniapp_generationInput>
  }

  export type miniapp_paymentCreateWithoutMiniapp_generationInput = {
    id?: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
    collection: collectionCreateNestedOneWithoutMiniapp_paymentInput
    miniapp_user: miniapp_userCreateNestedOneWithoutMiniapp_paymentInput
  }

  export type miniapp_paymentUncheckedCreateWithoutMiniapp_generationInput = {
    id?: string
    user_id: string
    collection_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type miniapp_paymentCreateOrConnectWithoutMiniapp_generationInput = {
    where: miniapp_paymentWhereUniqueInput
    create: XOR<miniapp_paymentCreateWithoutMiniapp_generationInput, miniapp_paymentUncheckedCreateWithoutMiniapp_generationInput>
  }

  export type miniapp_userCreateWithoutMiniapp_generationInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutMiniapp_userInput
    social_links?: social_linkCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userUncheckedCreateWithoutMiniapp_generationInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutMiniapp_userInput
    social_links?: social_linkUncheckedCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userCreateOrConnectWithoutMiniapp_generationInput = {
    where: miniapp_userWhereUniqueInput
    create: XOR<miniapp_userCreateWithoutMiniapp_generationInput, miniapp_userUncheckedCreateWithoutMiniapp_generationInput>
  }

  export type collectionUpsertWithoutMiniapp_generationInput = {
    update: XOR<collectionUpdateWithoutMiniapp_generationInput, collectionUncheckedUpdateWithoutMiniapp_generationInput>
    create: XOR<collectionCreateWithoutMiniapp_generationInput, collectionUncheckedCreateWithoutMiniapp_generationInput>
    where?: collectionWhereInput
  }

  export type collectionUpdateToOneWithWhereWithoutMiniapp_generationInput = {
    where?: collectionWhereInput
    data: XOR<collectionUpdateWithoutMiniapp_generationInput, collectionUncheckedUpdateWithoutMiniapp_generationInput>
  }

  export type collectionUpdateWithoutMiniapp_generationInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutMiniapp_generationInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type miniapp_paymentUpsertWithoutMiniapp_generationInput = {
    update: XOR<miniapp_paymentUpdateWithoutMiniapp_generationInput, miniapp_paymentUncheckedUpdateWithoutMiniapp_generationInput>
    create: XOR<miniapp_paymentCreateWithoutMiniapp_generationInput, miniapp_paymentUncheckedCreateWithoutMiniapp_generationInput>
    where?: miniapp_paymentWhereInput
  }

  export type miniapp_paymentUpdateToOneWithWhereWithoutMiniapp_generationInput = {
    where?: miniapp_paymentWhereInput
    data: XOR<miniapp_paymentUpdateWithoutMiniapp_generationInput, miniapp_paymentUncheckedUpdateWithoutMiniapp_generationInput>
  }

  export type miniapp_paymentUpdateWithoutMiniapp_generationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: collectionUpdateOneRequiredWithoutMiniapp_paymentNestedInput
    miniapp_user?: miniapp_userUpdateOneRequiredWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentUncheckedUpdateWithoutMiniapp_generationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type miniapp_userUpsertWithoutMiniapp_generationInput = {
    update: XOR<miniapp_userUpdateWithoutMiniapp_generationInput, miniapp_userUncheckedUpdateWithoutMiniapp_generationInput>
    create: XOR<miniapp_userCreateWithoutMiniapp_generationInput, miniapp_userUncheckedCreateWithoutMiniapp_generationInput>
    where?: miniapp_userWhereInput
  }

  export type miniapp_userUpdateToOneWithWhereWithoutMiniapp_generationInput = {
    where?: miniapp_userWhereInput
    data: XOR<miniapp_userUpdateWithoutMiniapp_generationInput, miniapp_userUncheckedUpdateWithoutMiniapp_generationInput>
  }

  export type miniapp_userUpdateWithoutMiniapp_generationInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_payment?: miniapp_paymentUpdateManyWithoutMiniapp_userNestedInput
    social_links?: social_linkUpdateManyWithoutMiniapp_userNestedInput
  }

  export type miniapp_userUncheckedUpdateWithoutMiniapp_generationInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutMiniapp_userNestedInput
    social_links?: social_linkUncheckedUpdateManyWithoutMiniapp_userNestedInput
  }

  export type WorkflowModelCreateWithoutModelInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    workflow: workflowCreateNestedOneWithoutWorkflow_modelsInput
  }

  export type WorkflowModelUncheckedCreateWithoutModelInput = {
    id?: string
    workflowId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type WorkflowModelCreateOrConnectWithoutModelInput = {
    where: WorkflowModelWhereUniqueInput
    create: XOR<WorkflowModelCreateWithoutModelInput, WorkflowModelUncheckedCreateWithoutModelInput>
  }

  export type WorkflowModelCreateManyModelInputEnvelope = {
    data: WorkflowModelCreateManyModelInput | WorkflowModelCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowModelUpsertWithWhereUniqueWithoutModelInput = {
    where: WorkflowModelWhereUniqueInput
    update: XOR<WorkflowModelUpdateWithoutModelInput, WorkflowModelUncheckedUpdateWithoutModelInput>
    create: XOR<WorkflowModelCreateWithoutModelInput, WorkflowModelUncheckedCreateWithoutModelInput>
  }

  export type WorkflowModelUpdateWithWhereUniqueWithoutModelInput = {
    where: WorkflowModelWhereUniqueInput
    data: XOR<WorkflowModelUpdateWithoutModelInput, WorkflowModelUncheckedUpdateWithoutModelInput>
  }

  export type WorkflowModelUpdateManyWithWhereWithoutModelInput = {
    where: WorkflowModelScalarWhereInput
    data: XOR<WorkflowModelUpdateManyMutationInput, WorkflowModelUncheckedUpdateManyWithoutModelInput>
  }

  export type ModelCreateWithoutWorkflowModelsInput = {
    id?: string
    name: string
    downloadUrl: string
    saveTo: string
    description?: string | null
    fileSize?: string | null
    hash?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authEnvVar?: string | null
    isAuthReq?: boolean
  }

  export type ModelUncheckedCreateWithoutWorkflowModelsInput = {
    id?: string
    name: string
    downloadUrl: string
    saveTo: string
    description?: string | null
    fileSize?: string | null
    hash?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authEnvVar?: string | null
    isAuthReq?: boolean
  }

  export type ModelCreateOrConnectWithoutWorkflowModelsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutWorkflowModelsInput, ModelUncheckedCreateWithoutWorkflowModelsInput>
  }

  export type workflowCreateWithoutWorkflow_modelsInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    server?: serverCreateNestedOneWithoutWorkflowInput
    workflow_custom_nodes?: workflow_custom_nodesCreateNestedManyWithoutWorkflowInput
  }

  export type workflowUncheckedCreateWithoutWorkflow_modelsInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    server_id?: string | null
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type workflowCreateOrConnectWithoutWorkflow_modelsInput = {
    where: workflowWhereUniqueInput
    create: XOR<workflowCreateWithoutWorkflow_modelsInput, workflowUncheckedCreateWithoutWorkflow_modelsInput>
  }

  export type ModelUpsertWithoutWorkflowModelsInput = {
    update: XOR<ModelUpdateWithoutWorkflowModelsInput, ModelUncheckedUpdateWithoutWorkflowModelsInput>
    create: XOR<ModelCreateWithoutWorkflowModelsInput, ModelUncheckedCreateWithoutWorkflowModelsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutWorkflowModelsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutWorkflowModelsInput, ModelUncheckedUpdateWithoutWorkflowModelsInput>
  }

  export type ModelUpdateWithoutWorkflowModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    saveTo?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authEnvVar?: NullableStringFieldUpdateOperationsInput | string | null
    isAuthReq?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModelUncheckedUpdateWithoutWorkflowModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    saveTo?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authEnvVar?: NullableStringFieldUpdateOperationsInput | string | null
    isAuthReq?: BoolFieldUpdateOperationsInput | boolean
  }

  export type workflowUpsertWithoutWorkflow_modelsInput = {
    update: XOR<workflowUpdateWithoutWorkflow_modelsInput, workflowUncheckedUpdateWithoutWorkflow_modelsInput>
    create: XOR<workflowCreateWithoutWorkflow_modelsInput, workflowUncheckedCreateWithoutWorkflow_modelsInput>
    where?: workflowWhereInput
  }

  export type workflowUpdateToOneWithWhereWithoutWorkflow_modelsInput = {
    where?: workflowWhereInput
    data: XOR<workflowUpdateWithoutWorkflow_modelsInput, workflowUncheckedUpdateWithoutWorkflow_modelsInput>
  }

  export type workflowUpdateWithoutWorkflow_modelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    server?: serverUpdateOneWithoutWorkflowNestedInput
    workflow_custom_nodes?: workflow_custom_nodesUpdateManyWithoutWorkflowNestedInput
  }

  export type workflowUncheckedUpdateWithoutWorkflow_modelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    server_id?: NullableStringFieldUpdateOperationsInput | string | null
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type collectionCreateWithoutSocial_linkInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    project: projectCreateNestedOneWithoutCollectionInput
    collection_history?: collection_historyCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesCreateNestedManyWithoutCollectionInput
    collection_node?: componentCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutSocial_linkInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
    collection_history?: collection_historyUncheckedCreateNestedManyWithoutCollectionInput
    collection_preview?: collection_previewUncheckedCreateNestedOneWithoutCollectionInput
    source_remix?: collection_remixUncheckedCreateNestedManyWithoutSource_collectionInput
    target_remix?: collection_remixUncheckedCreateNestedManyWithoutTarget_collectionInput
    collection_sales_receivers?: collection_sales_receiversUncheckedCreateNestedManyWithoutCollectionInput
    collection_sample_images?: collection_sample_imagesUncheckedCreateNestedManyWithoutCollectionInput
    collection_node?: componentUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_collection_config?: miniapp_collection_configUncheckedCreateNestedOneWithoutCollectionInput
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutCollectionInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutSocial_linkInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutSocial_linkInput, collectionUncheckedCreateWithoutSocial_linkInput>
  }

  export type collectionCreateManySocial_linkInputEnvelope = {
    data: collectionCreateManySocial_linkInput | collectionCreateManySocial_linkInput[]
    skipDuplicates?: boolean
  }

  export type miniapp_userCreateWithoutSocial_linksInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_generation?: miniapp_generationCreateNestedManyWithoutMiniapp_userInput
    miniapp_payment?: miniapp_paymentCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userUncheckedCreateWithoutSocial_linksInput = {
    id?: string
    farcaster_id: string
    farcaster_username?: string | null
    farcaster_pfp?: string | null
    wallet_address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notification_token?: string | null
    miniapp_generation?: miniapp_generationUncheckedCreateNestedManyWithoutMiniapp_userInput
    miniapp_payment?: miniapp_paymentUncheckedCreateNestedManyWithoutMiniapp_userInput
  }

  export type miniapp_userCreateOrConnectWithoutSocial_linksInput = {
    where: miniapp_userWhereUniqueInput
    create: XOR<miniapp_userCreateWithoutSocial_linksInput, miniapp_userUncheckedCreateWithoutSocial_linksInput>
  }

  export type collectionUpsertWithWhereUniqueWithoutSocial_linkInput = {
    where: collectionWhereUniqueInput
    update: XOR<collectionUpdateWithoutSocial_linkInput, collectionUncheckedUpdateWithoutSocial_linkInput>
    create: XOR<collectionCreateWithoutSocial_linkInput, collectionUncheckedCreateWithoutSocial_linkInput>
  }

  export type collectionUpdateWithWhereUniqueWithoutSocial_linkInput = {
    where: collectionWhereUniqueInput
    data: XOR<collectionUpdateWithoutSocial_linkInput, collectionUncheckedUpdateWithoutSocial_linkInput>
  }

  export type collectionUpdateManyWithWhereWithoutSocial_linkInput = {
    where: collectionScalarWhereInput
    data: XOR<collectionUpdateManyMutationInput, collectionUncheckedUpdateManyWithoutSocial_linkInput>
  }

  export type miniapp_userUpsertWithoutSocial_linksInput = {
    update: XOR<miniapp_userUpdateWithoutSocial_linksInput, miniapp_userUncheckedUpdateWithoutSocial_linksInput>
    create: XOR<miniapp_userCreateWithoutSocial_linksInput, miniapp_userUncheckedCreateWithoutSocial_linksInput>
    where?: miniapp_userWhereInput
  }

  export type miniapp_userUpdateToOneWithWhereWithoutSocial_linksInput = {
    where?: miniapp_userWhereInput
    data: XOR<miniapp_userUpdateWithoutSocial_linksInput, miniapp_userUncheckedUpdateWithoutSocial_linksInput>
  }

  export type miniapp_userUpdateWithoutSocial_linksInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_generation?: miniapp_generationUpdateManyWithoutMiniapp_userNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutMiniapp_userNestedInput
  }

  export type miniapp_userUncheckedUpdateWithoutSocial_linksInput = {
    id?: StringFieldUpdateOperationsInput | string
    farcaster_id?: StringFieldUpdateOperationsInput | string
    farcaster_username?: NullableStringFieldUpdateOperationsInput | string | null
    farcaster_pfp?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutMiniapp_userNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutMiniapp_userNestedInput
  }

  export type workflow_custom_nodesCreateWithoutCustom_nodesInput = {
    id?: bigint | number
    created_at?: Date | string
    workflow: workflowCreateNestedOneWithoutWorkflow_custom_nodesInput
  }

  export type workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput = {
    id?: bigint | number
    workflow_id: string
    created_at?: Date | string
  }

  export type workflow_custom_nodesCreateOrConnectWithoutCustom_nodesInput = {
    where: workflow_custom_nodesWhereUniqueInput
    create: XOR<workflow_custom_nodesCreateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput>
  }

  export type workflow_custom_nodesCreateManyCustom_nodesInputEnvelope = {
    data: workflow_custom_nodesCreateManyCustom_nodesInput | workflow_custom_nodesCreateManyCustom_nodesInput[]
    skipDuplicates?: boolean
  }

  export type workflow_custom_nodesUpsertWithWhereUniqueWithoutCustom_nodesInput = {
    where: workflow_custom_nodesWhereUniqueInput
    update: XOR<workflow_custom_nodesUpdateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedUpdateWithoutCustom_nodesInput>
    create: XOR<workflow_custom_nodesCreateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedCreateWithoutCustom_nodesInput>
  }

  export type workflow_custom_nodesUpdateWithWhereUniqueWithoutCustom_nodesInput = {
    where: workflow_custom_nodesWhereUniqueInput
    data: XOR<workflow_custom_nodesUpdateWithoutCustom_nodesInput, workflow_custom_nodesUncheckedUpdateWithoutCustom_nodesInput>
  }

  export type workflow_custom_nodesUpdateManyWithWhereWithoutCustom_nodesInput = {
    where: workflow_custom_nodesScalarWhereInput
    data: XOR<workflow_custom_nodesUpdateManyMutationInput, workflow_custom_nodesUncheckedUpdateManyWithoutCustom_nodesInput>
  }

  export type custom_nodesCreateWithoutWorkflow_custom_nodesInput = {
    id?: string
    name: string
    download_url: string
    description?: string | null
    is_env_required?: boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean
    install_order?: number | null
  }

  export type custom_nodesUncheckedCreateWithoutWorkflow_custom_nodesInput = {
    id?: string
    name: string
    download_url: string
    description?: string | null
    is_env_required?: boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean
    install_order?: number | null
  }

  export type custom_nodesCreateOrConnectWithoutWorkflow_custom_nodesInput = {
    where: custom_nodesWhereUniqueInput
    create: XOR<custom_nodesCreateWithoutWorkflow_custom_nodesInput, custom_nodesUncheckedCreateWithoutWorkflow_custom_nodesInput>
  }

  export type workflowCreateWithoutWorkflow_custom_nodesInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    server?: serverCreateNestedOneWithoutWorkflowInput
    workflow_models?: WorkflowModelCreateNestedManyWithoutWorkflowInput
  }

  export type workflowUncheckedCreateWithoutWorkflow_custom_nodesInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    server_id?: string | null
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
    workflow_models?: WorkflowModelUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type workflowCreateOrConnectWithoutWorkflow_custom_nodesInput = {
    where: workflowWhereUniqueInput
    create: XOR<workflowCreateWithoutWorkflow_custom_nodesInput, workflowUncheckedCreateWithoutWorkflow_custom_nodesInput>
  }

  export type custom_nodesUpsertWithoutWorkflow_custom_nodesInput = {
    update: XOR<custom_nodesUpdateWithoutWorkflow_custom_nodesInput, custom_nodesUncheckedUpdateWithoutWorkflow_custom_nodesInput>
    create: XOR<custom_nodesCreateWithoutWorkflow_custom_nodesInput, custom_nodesUncheckedCreateWithoutWorkflow_custom_nodesInput>
    where?: custom_nodesWhereInput
  }

  export type custom_nodesUpdateToOneWithWhereWithoutWorkflow_custom_nodesInput = {
    where?: custom_nodesWhereInput
    data: XOR<custom_nodesUpdateWithoutWorkflow_custom_nodesInput, custom_nodesUncheckedUpdateWithoutWorkflow_custom_nodesInput>
  }

  export type custom_nodesUpdateWithoutWorkflow_custom_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    download_url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_env_required?: BoolFieldUpdateOperationsInput | boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: BoolFieldUpdateOperationsInput | boolean
    install_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type custom_nodesUncheckedUpdateWithoutWorkflow_custom_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    download_url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_env_required?: BoolFieldUpdateOperationsInput | boolean
    env_conf?: NullableJsonNullValueInput | InputJsonValue
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    install_settings?: NullableJsonNullValueInput | InputJsonValue
    is_default?: BoolFieldUpdateOperationsInput | boolean
    install_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type workflowUpsertWithoutWorkflow_custom_nodesInput = {
    update: XOR<workflowUpdateWithoutWorkflow_custom_nodesInput, workflowUncheckedUpdateWithoutWorkflow_custom_nodesInput>
    create: XOR<workflowCreateWithoutWorkflow_custom_nodesInput, workflowUncheckedCreateWithoutWorkflow_custom_nodesInput>
    where?: workflowWhereInput
  }

  export type workflowUpdateToOneWithWhereWithoutWorkflow_custom_nodesInput = {
    where?: workflowWhereInput
    data: XOR<workflowUpdateWithoutWorkflow_custom_nodesInput, workflowUncheckedUpdateWithoutWorkflow_custom_nodesInput>
  }

  export type workflowUpdateWithoutWorkflow_custom_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    server?: serverUpdateOneWithoutWorkflowNestedInput
    workflow_models?: WorkflowModelUpdateManyWithoutWorkflowNestedInput
  }

  export type workflowUncheckedUpdateWithoutWorkflow_custom_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    server_id?: NullableStringFieldUpdateOperationsInput | string | null
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_models?: WorkflowModelUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type collection_historyCreateManyCollectionInput = {
    id?: number
    event: string
    current_value: string
    new_value: string
    created_at?: Date | string
  }

  export type collection_remixCreateManySource_collectionInput = {
    id?: bigint | number
    target_collection_id: string
    created_at?: Date | string | null
    collection_preview_version_id?: bigint | number | null
  }

  export type collection_remixCreateManyTarget_collectionInput = {
    id?: bigint | number
    source_collection_id: string
    created_at?: Date | string | null
    collection_preview_version_id?: bigint | number | null
  }

  export type collection_sales_receiversCreateManyCollectionInput = {
    id?: number
    address: string
    value: number
    type: string
  }

  export type collection_sample_imagesCreateManyCollectionInput = {
    id?: bigint | number
    url: string
  }

  export type componentCreateManyCollectionInput = {
    id?: bigint | number
    created_at?: Date | string | null
  }

  export type miniapp_generationCreateManyCollectionInput = {
    id?: string
    user_id: string
    payment_id?: string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_paymentCreateManyCollectionInput = {
    id?: string
    user_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type collection_historyUpdateWithoutCollectionInput = {
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_historyUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_historyUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    current_value?: StringFieldUpdateOperationsInput | string
    new_value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_remixUpdateWithoutSource_collectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version?: collection_preview_versionUpdateOneWithoutCollection_remixNestedInput
    target_collection?: collectionUpdateOneRequiredWithoutTarget_remixNestedInput
  }

  export type collection_remixUncheckedUpdateWithoutSource_collectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collection_remixUncheckedUpdateManyWithoutSource_collectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collection_remixUpdateWithoutTarget_collectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version?: collection_preview_versionUpdateOneWithoutCollection_remixNestedInput
    source_collection?: collectionUpdateOneRequiredWithoutSource_remixNestedInput
  }

  export type collection_remixUncheckedUpdateWithoutTarget_collectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collection_remixUncheckedUpdateManyWithoutTarget_collectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_preview_version_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collection_sales_receiversUpdateWithoutCollectionInput = {
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sales_receiversUncheckedUpdateWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sales_receiversUncheckedUpdateManyWithoutCollectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sample_imagesUpdateWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sample_imagesUncheckedUpdateWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type collection_sample_imagesUncheckedUpdateManyWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type componentUpdateWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component_flat_files?: component_flat_fileUpdateManyWithoutComponentNestedInput
  }

  export type componentUncheckedUpdateWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component_flat_files?: component_flat_fileUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type componentUncheckedUpdateManyWithoutCollectionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type miniapp_generationUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
    miniapp_payment?: miniapp_paymentUpdateOneWithoutMiniapp_generationNestedInput
    miniapp_user?: miniapp_userUpdateOneRequiredWithoutMiniapp_generationNestedInput
  }

  export type miniapp_generationUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_paymentUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_generation?: miniapp_generationUpdateManyWithoutMiniapp_paymentNestedInput
    miniapp_user?: miniapp_userUpdateOneRequiredWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messageCreateManyFlat_fileInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    chat_id: string
  }

  export type component_flat_fileCreateManyFlat_fileInput = {
    id?: bigint | number
    component_id: bigint | number
  }

  export type chat_messageUpdateWithoutFlat_fileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chat?: chatUpdateOneRequiredWithoutChat_messageNestedInput
  }

  export type chat_messageUncheckedUpdateWithoutFlat_fileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
  }

  export type chat_messageUncheckedUpdateManyWithoutFlat_fileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
  }

  export type component_flat_fileUpdateWithoutFlat_fileInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component?: componentUpdateOneRequiredWithoutComponent_flat_filesNestedInput
  }

  export type component_flat_fileUncheckedUpdateWithoutFlat_fileInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type component_flat_fileUncheckedUpdateManyWithoutFlat_fileInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    component_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type collectionCreateManyProjectInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    custodied_for?: string | null
    miniapp_cover_image?: string | null
  }

  export type collectionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    social_link?: social_linkUpdateOneWithoutCustodial_collectionsNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    custodied_for?: NullableStringFieldUpdateOperationsInput | string | null
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_template_saveCreateManyProject_templateInput = {
    id?: bigint | number
    name: string
    data: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    project_history_id?: string | null
  }

  export type project_template_saveUpdateWithoutProject_templateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_template_saveUncheckedUpdateWithoutProject_templateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_template_saveUncheckedUpdateManyWithoutProject_templateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_history_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collection_reward_redemptionCreateManyCollection_rewardInput = {
    id?: number
    user_id: string
    wallet_address: string
    token_id: string
    created_at?: Date | string
  }

  export type collection_reward_redemptionUpdateWithoutCollection_rewardInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_reward_redemptionUncheckedUpdateWithoutCollection_rewardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_reward_redemptionUncheckedUpdateManyWithoutCollection_rewardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: StringFieldUpdateOperationsInput | string
    token_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collection_preview_versionCreateManyCollection_previewInput = {
    id?: bigint | number
    version?: number
    data: JsonNullValueInput | InputJsonValue
    is_latest?: boolean
    created_at?: Date | string | null
  }

  export type collection_preview_versionUpdateWithoutCollection_previewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_remix?: collection_remixUpdateManyWithoutCollection_preview_versionNestedInput
  }

  export type collection_preview_versionUncheckedUpdateWithoutCollection_previewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collection_remix?: collection_remixUncheckedUpdateManyWithoutCollection_preview_versionNestedInput
  }

  export type collection_preview_versionUncheckedUpdateManyWithoutCollection_previewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    is_latest?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_remixCreateManyCollection_preview_versionInput = {
    id?: bigint | number
    source_collection_id: string
    target_collection_id: string
    created_at?: Date | string | null
  }

  export type collection_remixUpdateWithoutCollection_preview_versionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source_collection?: collectionUpdateOneRequiredWithoutSource_remixNestedInput
    target_collection?: collectionUpdateOneRequiredWithoutTarget_remixNestedInput
  }

  export type collection_remixUncheckedUpdateWithoutCollection_preview_versionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source_collection_id?: StringFieldUpdateOperationsInput | string
    target_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type collection_remixUncheckedUpdateManyWithoutCollection_preview_versionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source_collection_id?: StringFieldUpdateOperationsInput | string
    target_collection_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messageCreateManyChatInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id: string
    content: string
    flat_file_id?: bigint | number | null
  }

  export type chat_messageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    flat_file?: flat_fileUpdateOneWithoutChat_messageNestedInput
  }

  export type chat_messageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    flat_file_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type chat_messageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    flat_file_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type component_flat_fileCreateManyComponentInput = {
    id?: bigint | number
    flat_file_id: bigint | number
  }

  export type component_flat_fileUpdateWithoutComponentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file?: flat_fileUpdateOneRequiredWithoutComponent_flat_filesNestedInput
  }

  export type component_flat_fileUncheckedUpdateWithoutComponentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type component_flat_fileUncheckedUpdateManyWithoutComponentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    flat_file_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type workflow_custom_nodesCreateManyWorkflowInput = {
    id?: bigint | number
    custom_node_id: string
    created_at?: Date | string
  }

  export type WorkflowModelCreateManyWorkflowInput = {
    id?: string
    modelId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type workflow_custom_nodesUpdateWithoutWorkflowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    custom_nodes?: custom_nodesUpdateOneRequiredWithoutWorkflow_custom_nodesNestedInput
  }

  export type workflow_custom_nodesUncheckedUpdateWithoutWorkflowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_node_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workflow_custom_nodesUncheckedUpdateManyWithoutWorkflowInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    custom_node_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowModelUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutWorkflowModelsNestedInput
  }

  export type WorkflowModelUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowModelUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workflowCreateManyServerInput = {
    id?: string
    name: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    output_mime_type?: string | null
    display?: boolean | null
    label?: string | null
    order?: number | null
    type?: string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: string | null
    min_vram?: number | null
  }

  export type workflowUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_custom_nodes?: workflow_custom_nodesUpdateManyWithoutWorkflowNestedInput
    workflow_models?: WorkflowModelUpdateManyWithoutWorkflowNestedInput
  }

  export type workflowUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
    workflow_custom_nodes?: workflow_custom_nodesUncheckedUpdateManyWithoutWorkflowNestedInput
    workflow_models?: WorkflowModelUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type workflowUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    output_mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    display?: NullableBoolFieldUpdateOperationsInput | boolean | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    est_gen_time?: NullableJsonNullValueInput | InputJsonValue
    machine_type?: NullableStringFieldUpdateOperationsInput | string | null
    min_vram?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_historyCreateManyJobInput = {
    id?: string
    status: string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    message?: string | null
  }

  export type job_historyUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type job_historyUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type job_historyUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type miniapp_generationCreateManyMiniapp_userInput = {
    id?: string
    collection_id: string
    payment_id?: string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_paymentCreateManyMiniapp_userInput = {
    id?: string
    collection_id: string
    amount: number
    transaction_hash?: string | null
    payment_status?: string
    generations_allowed: number
    generations_used?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type social_linkCreateManyMiniapp_userInput = {
    id?: string
    social_org: $Enums.social_org_enum
    identifier: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type miniapp_generationUpdateWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
    collection?: collectionUpdateOneRequiredWithoutMiniapp_generationNestedInput
    miniapp_payment?: miniapp_paymentUpdateOneWithoutMiniapp_generationNestedInput
  }

  export type miniapp_generationUncheckedUpdateWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationUncheckedUpdateManyWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_paymentUpdateWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_generation?: miniapp_generationUpdateManyWithoutMiniapp_paymentNestedInput
    collection?: collectionUpdateOneRequiredWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentUncheckedUpdateWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutMiniapp_paymentNestedInput
  }

  export type miniapp_paymentUncheckedUpdateManyWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transaction_hash?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: StringFieldUpdateOperationsInput | string
    generations_allowed?: IntFieldUpdateOperationsInput | number
    generations_used?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type social_linkUpdateWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    custodial_collections?: collectionUpdateManyWithoutSocial_linkNestedInput
  }

  export type social_linkUncheckedUpdateWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    custodial_collections?: collectionUncheckedUpdateManyWithoutSocial_linkNestedInput
  }

  export type social_linkUncheckedUpdateManyWithoutMiniapp_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    social_org?: Enumsocial_org_enumFieldUpdateOperationsInput | $Enums.social_org_enum
    identifier?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type miniapp_generationCreateManyMiniapp_paymentInput = {
    id?: string
    user_id: string
    collection_id: string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_id?: string | null
    generated_image?: string | null
    status?: $Enums.GenerationStatus
    retry_count?: number
  }

  export type miniapp_generationUpdateWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
    collection?: collectionUpdateOneRequiredWithoutMiniapp_generationNestedInput
    miniapp_user?: miniapp_userUpdateOneRequiredWithoutMiniapp_generationNestedInput
  }

  export type miniapp_generationUncheckedUpdateWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type miniapp_generationUncheckedUpdateManyWithoutMiniapp_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: StringFieldUpdateOperationsInput | string
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_url?: NullableStringFieldUpdateOperationsInput | string | null
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    generated_image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGenerationStatusFieldUpdateOperationsInput | $Enums.GenerationStatus
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type WorkflowModelCreateManyModelInput = {
    id?: string
    workflowId: string
    isRequired?: boolean
    createdAt?: Date | string
  }

  export type WorkflowModelUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: workflowUpdateOneRequiredWithoutWorkflow_modelsNestedInput
  }

  export type WorkflowModelUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowModelUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collectionCreateManySocial_linkInput = {
    id?: string
    archived?: boolean
    batch_max_tokens?: number | null
    batch_mint_enabled?: boolean
    blockchain?: string | null
    cover_image_url?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    editions?: number | null
    encryption_enabled?: boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: boolean
    price?: number | null
    project_id: string
    publish_date?: Date | string | null
    status?: string
    title?: string | null
    updated_at?: Date | string
    created_at?: Date | string
    is_custodial?: boolean
    miniapp_cover_image?: string | null
  }

  export type collectionUpdateWithoutSocial_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    project?: projectUpdateOneRequiredWithoutCollectionNestedInput
    collection_history?: collection_historyUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutSocial_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    collection_history?: collection_historyUncheckedUpdateManyWithoutCollectionNestedInput
    collection_preview?: collection_previewUncheckedUpdateOneWithoutCollectionNestedInput
    source_remix?: collection_remixUncheckedUpdateManyWithoutSource_collectionNestedInput
    target_remix?: collection_remixUncheckedUpdateManyWithoutTarget_collectionNestedInput
    collection_sales_receivers?: collection_sales_receiversUncheckedUpdateManyWithoutCollectionNestedInput
    collection_sample_images?: collection_sample_imagesUncheckedUpdateManyWithoutCollectionNestedInput
    collection_node?: componentUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_collection_config?: miniapp_collection_configUncheckedUpdateOneWithoutCollectionNestedInput
    miniapp_generation?: miniapp_generationUncheckedUpdateManyWithoutCollectionNestedInput
    miniapp_payment?: miniapp_paymentUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateManyWithoutSocial_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    batch_max_tokens?: NullableIntFieldUpdateOperationsInput | number | null
    batch_mint_enabled?: BoolFieldUpdateOperationsInput | boolean
    blockchain?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    editions?: NullableIntFieldUpdateOperationsInput | number | null
    encryption_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: NullableJsonNullValueInput | InputJsonValue
    is_current?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    publish_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_custodial?: BoolFieldUpdateOperationsInput | boolean
    miniapp_cover_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type workflow_custom_nodesCreateManyCustom_nodesInput = {
    id?: bigint | number
    workflow_id: string
    created_at?: Date | string
  }

  export type workflow_custom_nodesUpdateWithoutCustom_nodesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: workflowUpdateOneRequiredWithoutWorkflow_custom_nodesNestedInput
  }

  export type workflow_custom_nodesUncheckedUpdateWithoutCustom_nodesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    workflow_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workflow_custom_nodesUncheckedUpdateManyWithoutCustom_nodesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    workflow_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CollectionCountOutputTypeDefaultArgs instead
     */
    export type CollectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Flat_fileCountOutputTypeDefaultArgs instead
     */
    export type Flat_fileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Flat_fileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Project_templateCountOutputTypeDefaultArgs instead
     */
    export type Project_templateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Project_templateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Collection_rewardCountOutputTypeDefaultArgs instead
     */
    export type Collection_rewardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Collection_rewardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Collection_previewCountOutputTypeDefaultArgs instead
     */
    export type Collection_previewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Collection_previewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Collection_preview_versionCountOutputTypeDefaultArgs instead
     */
    export type Collection_preview_versionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Collection_preview_versionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentCountOutputTypeDefaultArgs instead
     */
    export type ComponentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowCountOutputTypeDefaultArgs instead
     */
    export type WorkflowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServerCountOutputTypeDefaultArgs instead
     */
    export type ServerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobCountOutputTypeDefaultArgs instead
     */
    export type JobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Miniapp_userCountOutputTypeDefaultArgs instead
     */
    export type Miniapp_userCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Miniapp_userCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Miniapp_paymentCountOutputTypeDefaultArgs instead
     */
    export type Miniapp_paymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Miniapp_paymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelCountOutputTypeDefaultArgs instead
     */
    export type ModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Social_linkCountOutputTypeDefaultArgs instead
     */
    export type Social_linkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Social_linkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Custom_nodesCountOutputTypeDefaultArgs instead
     */
    export type Custom_nodesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Custom_nodesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use assignmentDefaultArgs instead
     */
    export type assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = assignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collectionDefaultArgs instead
     */
    export type collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_remixDefaultArgs instead
     */
    export type collection_remixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_remixDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventDefaultArgs instead
     */
    export type eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use flat_fileDefaultArgs instead
     */
    export type flat_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = flat_fileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use component_flat_fileDefaultArgs instead
     */
    export type component_flat_fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = component_flat_fileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projectDefaultArgs instead
     */
    export type projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use project_historyDefaultArgs instead
     */
    export type project_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = project_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use roleDefaultArgs instead
     */
    export type roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = roleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use walletDefaultArgs instead
     */
    export type walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = walletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use credits_historyDefaultArgs instead
     */
    export type credits_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = credits_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use credits_balanceDefaultArgs instead
     */
    export type credits_balanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = credits_balanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subscriptionDefaultArgs instead
     */
    export type subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = subscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customerDefaultArgs instead
     */
    export type customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productDefaultArgs instead
     */
    export type productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use project_templateDefaultArgs instead
     */
    export type project_templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = project_templateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use project_template_saveDefaultArgs instead
     */
    export type project_template_saveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = project_template_saveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_rewardDefaultArgs instead
     */
    export type collection_rewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_rewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_reward_redemptionDefaultArgs instead
     */
    export type collection_reward_redemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_reward_redemptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_sales_receiversDefaultArgs instead
     */
    export type collection_sales_receiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_sales_receiversDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_historyDefaultArgs instead
     */
    export type collection_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use profileDefaultArgs instead
     */
    export type profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = profileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_previewDefaultArgs instead
     */
    export type collection_previewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_previewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_preview_versionDefaultArgs instead
     */
    export type collection_preview_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_preview_versionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collection_sample_imagesDefaultArgs instead
     */
    export type collection_sample_imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collection_sample_imagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chatDefaultArgs instead
     */
    export type chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = chatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chat_messageDefaultArgs instead
     */
    export type chat_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = chat_messageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use socket_io_attachmentsDefaultArgs instead
     */
    export type socket_io_attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = socket_io_attachmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use componentDefaultArgs instead
     */
    export type componentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = componentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use workflowDefaultArgs instead
     */
    export type workflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = workflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serverDefaultArgs instead
     */
    export type serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use form_configDefaultArgs instead
     */
    export type form_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = form_configDefaultArgs<ExtArgs>
    /**
     * @deprecated Use api_keyDefaultArgs instead
     */
    export type api_keyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = api_keyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_api_keysDefaultArgs instead
     */
    export type user_api_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_api_keysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use jobDefaultArgs instead
     */
    export type jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = jobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use job_historyDefaultArgs instead
     */
    export type job_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = job_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use miniapp_userDefaultArgs instead
     */
    export type miniapp_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = miniapp_userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use miniapp_collection_configDefaultArgs instead
     */
    export type miniapp_collection_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = miniapp_collection_configDefaultArgs<ExtArgs>
    /**
     * @deprecated Use miniapp_paymentDefaultArgs instead
     */
    export type miniapp_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = miniapp_paymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use miniapp_generationDefaultArgs instead
     */
    export type miniapp_generationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = miniapp_generationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelDefaultArgs instead
     */
    export type ModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowModelDefaultArgs instead
     */
    export type WorkflowModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use component_flat_file_recoverDefaultArgs instead
     */
    export type component_flat_file_recoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = component_flat_file_recoverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use social_linkDefaultArgs instead
     */
    export type social_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = social_linkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use custom_nodesDefaultArgs instead
     */
    export type custom_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = custom_nodesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use workflow_custom_nodesDefaultArgs instead
     */
    export type workflow_custom_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = workflow_custom_nodesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}