/**
 * Webhook Notification Service
 *
 * Delivers HTTP webhook notifications for job status changes and other events.
 * Integrates with the existing EventBroadcaster system to send notifications
 * to external systems when jobs are submitted, progress updates, complete, fail, etc.
 */

import { EventEmitter } from 'events';
import { Redis } from 'ioredis';
import { logger } from '../utils/logger.js';
import { WebhookRedisStorage } from './webhook-redis-storage.js';
import {
  MonitorEvent,
  JobSubmittedEvent,
  JobStatusChangedEvent,
  JobProgressEvent,
  JobCompletedEvent,
  JobFailedEvent,
} from '../types/monitor-events.js';
import { JobStatus } from '../types/job.js';

// Webhook configuration types
export interface WebhookEndpoint {
  id: string;
  url: string;
  secret?: string; // For HMAC signature verification
  events: WebhookEventType[];
  filters?: WebhookFilters;
  headers?: Record<string, string>;
  retry_config?: WebhookRetryConfig;
  active: boolean;
  created_at: number;
  updated_at: number;
}

export type WebhookEventType =
  | 'job_submitted' // Job submitted to queue (published by API)
  | 'update_job_progress' // Job progress updates (published by workers)
  | 'complete_job' // Job completed successfully (published by workers)
  | 'job_failed' // Job failed permanently (published by workers)
  | 'cancel_job' // Job cancelled (published by API)
  | 'worker_status' // Worker status changes
  | 'machine_status' // Machine status changes
  | 'workflow_completed' // Workflow completed (all steps finished) - generated by webhook service
  | 'workflow_submitted' // First job in workflow submitted - generated by webhook service
  | 'workflow_failed' // Workflow failed (partial or complete failure) - generated by webhook service

export interface WebhookFilters {
  job_types?: string[]; // Filter by job type (e.g., ['comfyui', 'openai'])
  job_priorities?: number[]; // Filter by priority levels
  machine_ids?: string[]; // Filter by specific machines
  worker_ids?: string[]; // Filter by specific workers
  custom_filters?: Record<string, unknown>; // Custom filter criteria
}

export interface WebhookRetryConfig {
  max_attempts: number; // Default: 3
  initial_delay_ms: number; // Default: 1000 (1 second)
  backoff_multiplier: number; // Default: 2 (exponential backoff)
  max_delay_ms: number; // Default: 30000 (30 seconds)
}

export interface WebhookPayload {
  event_type: WebhookEventType;
  event_id: string;
  timestamp: number;
  webhook_id: string;
  data: WebhookEventData;
  metadata?: {
    retry_attempt?: number;
    original_timestamp?: number;
  };
}

export interface WebhookEventData {
  job_id?: string;
  job_type?: string;
  job_status?: JobStatus;
  worker_id?: string;
  machine_id?: string;
  progress?: number;
  result?: unknown;
  error?: string;
  // Workflow fields - CRITICAL for workflow tracking
  workflow_id?: string;
  workflow_priority?: number;
  workflow_datetime?: number;
  step_number?: number;
  total_steps?: number;
  current_step?: number;
  [key: string]: unknown;
}

export interface WebhookDeliveryAttempt {
  id: string;
  webhook_id: string;
  event_id: string;
  attempt_number: number;
  timestamp: number;
  success: boolean;
  response_status?: number;
  response_body?: string;
  error_message?: string;
  next_retry_at?: number;
}

export class WebhookNotificationService extends EventEmitter {
  private webhookStorage: WebhookRedisStorage;
  private webhooksCache: Map<string, WebhookEndpoint> = new Map();
  private deliveryQueue: WebhookPayload[] = [];
  private retryQueue: Map<string, WebhookDeliveryAttempt> = new Map();
  private isProcessing = false;
  private processingInterval?: NodeJS.Timeout;
  private cacheRefreshInterval?: NodeJS.Timeout;
  private throttleCleanupInterval?: NodeJS.Timeout;
  
  // Throttling: Track last progress webhook sent per job (1 per second max)
  private lastProgressWebhookSent: Map<string, number> = new Map();
  private readonly PROGRESS_THROTTLE_MS = 1000; // 1 second

  // Workflow tracking for completion detection (independent of subscriptions)
  private workflowTracker = new Map<string, {
    steps: Map<number, string>;   // step_number -> job_id mapping
    completedSteps: Set<number>;  // completed step numbers (1-indexed)
    failedSteps: Set<number>;     // failed step numbers (1-indexed)
    totalSteps?: number;          // total steps in workflow (from job submission)
    startTime: number;
    lastUpdate: number;
    currentStep?: number;         // highest current_step seen
  }>();

  constructor(redis: Redis) {
    super();
    this.webhookStorage = new WebhookRedisStorage(redis);
    this.startProcessing();
    this.startCacheRefresh();
    this.startThrottleCleanup();
  }

  /**
   * Register a new webhook endpoint
   */
  async registerWebhook(
    config: Omit<WebhookEndpoint, 'id' | 'created_at' | 'updated_at'>
  ): Promise<WebhookEndpoint> {
    const webhook: WebhookEndpoint = {
      id: this.generateId(),
      created_at: Date.now(),
      updated_at: Date.now(),
      retry_config: {
        max_attempts: 3,
        initial_delay_ms: 1000,
        backoff_multiplier: 2,
        max_delay_ms: 30000,
        ...config.retry_config,
      },
      ...config,
    };

    await this.webhookStorage.storeWebhook(webhook);
    this.webhooksCache.set(webhook.id, webhook);

    logger.info(`Webhook registered: ${webhook.id} -> ${webhook.url}`, {
      webhook_id: webhook.id,
      events: webhook.events,
      filters: webhook.filters,
    });

    return webhook;
  }

  /**
   * Update an existing webhook
   */
  async updateWebhook(
    id: string,
    updates: Partial<WebhookEndpoint>
  ): Promise<WebhookEndpoint | null> {
    const updatedWebhook = await this.webhookStorage.updateWebhook(id, updates);
    if (updatedWebhook) {
      this.webhooksCache.set(id, updatedWebhook);
      logger.info(`Webhook updated: ${id}`, { updates });
    }
    return updatedWebhook;
  }

  /**
   * Delete a webhook
   */
  async deleteWebhook(id: string): Promise<boolean> {
    const deleted = await this.webhookStorage.deleteWebhook(id);
    if (deleted) {
      this.webhooksCache.delete(id);
      logger.info(`Webhook deleted: ${id}`);
    }
    return deleted;
  }

  /**
   * Get all webhooks
   */
  async getWebhooks(): Promise<WebhookEndpoint[]> {
    return await this.webhookStorage.getAllWebhooks();
  }

  /**
   * Get a specific webhook
   */
  async getWebhook(id: string): Promise<WebhookEndpoint | null> {
    // Try cache first
    const cached = this.webhooksCache.get(id);
    if (cached) {
      return cached;
    }

    // Fallback to Redis
    const webhook = await this.webhookStorage.getWebhook(id);
    if (webhook) {
      this.webhooksCache.set(id, webhook);
    }
    return webhook;
  }

  /**
   * Process monitor events and trigger webhooks
   */
  async processEvent(event: MonitorEvent): Promise<void> {
    // DEBUG: Log event processing (skip progress updates to reduce noise)
    if (event.type !== 'update_job_progress') {
      logger.info(`üì• [WEBHOOK DEBUG] Processing event for webhooks`, {
        event_type: event.type,
        job_id: (event as any).job_id,
        workflow_id: (event as any).workflow_id,
        timestamp: event.timestamp,
      });
    }

    const webhookEvent = this.convertMonitorEventToWebhookEvent(event);
    if (!webhookEvent) {
      logger.debug(`üì§ [WEBHOOK DEBUG] Event not supported for webhooks: ${event.type}`);
      return; // Event not supported for webhooks
    }

    // ALWAYS process workflow tracking events for workflow detection
    // even if no webhooks are subscribed to individual job events
    await this.processWorkflowTracking(event, webhookEvent);

    // THROTTLING: Check if this is a progress update and if we should throttle it
    if (webhookEvent === 'update_job_progress') {
      const jobId = (event as any).job_id as string;
      if (jobId && this.shouldThrottleProgressWebhook(jobId)) {
        logger.debug(`‚è±Ô∏è [WEBHOOK DEBUG] Throttling progress webhook for job ${jobId} (< 1 second since last)`);
        return;
      }
    }

    // Find matching webhooks for THIS specific event (only send if explicitly subscribed)
    const matchingWebhooks = this.findMatchingWebhooks(webhookEvent, event);
    
    // Only log for non-progress events to reduce noise
    if (event.type !== 'update_job_progress') {
      logger.info(`üéØ [WEBHOOK DEBUG] Found ${matchingWebhooks.length} matching webhooks for ${event.type}`);
    }

    for (const webhook of matchingWebhooks) {
      const payload = this.createWebhookPayload(webhook, webhookEvent, event);
      
      // Only log for non-progress events to reduce noise
      if (event.type !== 'update_job_progress') {
        logger.info(`üìã [WEBHOOK DEBUG] Queueing webhook delivery`, {
          webhook_id: webhook.id,
          webhook_url: webhook.url,
          event_type: webhookEvent,
          job_id: (event as any).job_id,
          workflow_id: (event as any).workflow_id,
        });
      }
      
      this.queueDelivery(payload);
    }
  }

  /**
   * Process workflow tracking for completion detection (independent of subscriptions)
   */
  private async processWorkflowTracking(event: MonitorEvent, webhookEventType: WebhookEventType): Promise<void> {
    const jobEvent = event as unknown as Record<string, unknown>;
    const workflowId = jobEvent.workflow_id as string;
    const jobId = jobEvent.job_id as string;
    const currentStep = jobEvent.current_step as number;
    const stepNumber = jobEvent.step_number as number;
    const totalSteps = jobEvent.total_steps as number;

    // DEBUG: Log extracted data for workflow events
    if (workflowId) {
      logger.info('üìã [WORKFLOW TRACKING] Processing workflow event', {
        eventType: webhookEventType,
        workflowId,
        jobId,
        currentStep,
        stepNumber,
        totalSteps,
        rawEvent: {
          type: event.type,
          workflow_id: jobEvent.workflow_id,
          job_id: jobEvent.job_id,
          current_step: jobEvent.current_step,
          step_number: jobEvent.step_number,
          total_steps: jobEvent.total_steps
        }
      });
    }

    // Only track workflow events
    if (!workflowId || !jobId) {
      return;
    }

    const now = Date.now();
    let workflow = this.workflowTracker.get(workflowId);

    // Initialize workflow tracking if not exists
    if (!workflow) {
      workflow = {
        steps: new Map(),
        completedSteps: new Set(),
        failedSteps: new Set(),
        startTime: now,
        lastUpdate: now,
      };
      this.workflowTracker.set(workflowId, workflow);
      logger.debug('Started tracking workflow', { workflowId });
    }

    // Update workflow metadata
    workflow.lastUpdate = now;
    if (totalSteps && !workflow.totalSteps) {
      workflow.totalSteps = totalSteps;
      logger.debug('Set workflow total steps', { workflowId, totalSteps });
    }
    if (currentStep && (!workflow.currentStep || currentStep > workflow.currentStep)) {
      workflow.currentStep = currentStep;
    }

    // Track step in workflow
    const effectiveStepNumber = currentStep || stepNumber || 1;
    workflow.steps.set(effectiveStepNumber, jobId);

    // Check if this is the first step being submitted (workflow_submitted event)
    if (webhookEventType === 'job_submitted' && effectiveStepNumber === 1 && workflow.steps.size === 1) {
      await this.sendWorkflowEvent('workflow_submitted', workflowId, event);
    }

    // Handle completion/failure
    const wasCompleted = workflow.completedSteps.has(effectiveStepNumber);
    const wasFailed = workflow.failedSteps.has(effectiveStepNumber);

    if (webhookEventType === 'complete_job' && !wasCompleted) {
      workflow.completedSteps.add(effectiveStepNumber);
      workflow.failedSteps.delete(effectiveStepNumber);
      logger.info('üéØ [WORKFLOW COMPLETION] Step completed', { 
        workflowId, 
        jobId,
        stepNumber: effectiveStepNumber,
        completed: workflow.completedSteps.size,
        total: workflow.totalSteps || workflow.steps.size,
        allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
        completedSteps: Array.from(workflow.completedSteps),
        failedSteps: Array.from(workflow.failedSteps)
      });
    } else if (webhookEventType === 'job_failed' && !wasFailed) {
      workflow.failedSteps.add(effectiveStepNumber);
      workflow.completedSteps.delete(effectiveStepNumber);
      logger.info('‚ùå [WORKFLOW COMPLETION] Step failed', { 
        workflowId, 
        jobId,
        stepNumber: effectiveStepNumber,
        failed: workflow.failedSteps.size,
        total: workflow.totalSteps || workflow.steps.size,
        allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
        completedSteps: Array.from(workflow.completedSteps),
        failedSteps: Array.from(workflow.failedSteps)
      });
    } else if (webhookEventType === 'complete_job' && wasCompleted) {
      logger.debug('üîÑ [WORKFLOW COMPLETION] Step already completed, skipping', { workflowId, jobId, stepNumber: effectiveStepNumber });
    }

    // Check for workflow completion
    await this.checkWorkflowCompletion(workflowId, workflow, event);
  }

  /**
   * Send workflow events to subscribed webhooks
   */
  private async sendWorkflowEvent(eventType: 'workflow_submitted' | 'workflow_completed' | 'workflow_failed', workflowId: string, triggeringEvent: MonitorEvent): Promise<void> {
    const workflowEvent = this.createWorkflowEvent(eventType, workflowId, triggeringEvent);
    
    // Find webhooks subscribed to this workflow event type
    const matchingWebhooks = this.findMatchingWebhooksForEventType(eventType);
    
    logger.info(`üéØ [WORKFLOW] Found ${matchingWebhooks.length} webhooks for ${eventType}`, { workflowId });

    for (const webhook of matchingWebhooks) {
      const payload = {
        event_type: eventType,
        event_id: this.generateId(),
        timestamp: Date.now(),
        webhook_id: webhook.id,
        data: workflowEvent,
      };
      
      logger.info(`üìã [WORKFLOW] Queueing ${eventType} webhook`, {
        webhook_id: webhook.id,
        webhook_url: webhook.url,
        workflow_id: workflowId,
      });
      
      this.queueDelivery(payload);
    }
  }

  /**
   * Create workflow event data
   */
  private createWorkflowEvent(eventType: string, workflowId: string, triggeringEvent: MonitorEvent): Record<string, unknown> {
    const jobEvent = triggeringEvent as unknown as Record<string, unknown>;
    const workflow = this.workflowTracker.get(workflowId);
    
    const baseEvent = {
      workflow_id: workflowId,
      timestamp: Date.now(),
      trigger_job_id: jobEvent.job_id,
      trigger_event_type: triggeringEvent.type,
    };

    if (eventType === 'workflow_submitted') {
      return {
        ...baseEvent,
        first_job_id: jobEvent.job_id,
        total_steps: jobEvent.total_steps,
        workflow_priority: jobEvent.workflow_priority,
        workflow_datetime: jobEvent.workflow_datetime,
        customer_id: jobEvent.customer_id,
        service_required: jobEvent.service_required,
      };
    }

    if (workflow && (eventType === 'workflow_completed' || eventType === 'workflow_failed')) {
      const isSuccess = eventType === 'workflow_completed';
      const duration = Date.now() - workflow.startTime;
      
      return {
        ...baseEvent,
        success: isSuccess,
        total_steps: workflow.totalSteps,
        completed_steps: workflow.completedSteps.size,
        failed_steps: workflow.failedSteps.size,
        duration_ms: duration,
        start_time: workflow.startTime,
        end_time: Date.now(),
        current_step: jobEvent.current_step,
        step_details: Array.from(workflow.steps.entries()).map(([stepNum, stepJobId]) => ({
          step_number: stepNum,
          job_id: stepJobId,
          completed: workflow.completedSteps.has(stepNum),
          failed: workflow.failedSteps.has(stepNum)
        }))
      };
    }

    return baseEvent;
  }

  /**
   * Find webhooks matching a specific event type
   */
  private findMatchingWebhooksForEventType(eventType: WebhookEventType): WebhookEndpoint[] {
    const allWebhooks = Array.from(this.webhooksCache.values());
    return allWebhooks.filter(webhook => 
      webhook.active && webhook.events.includes(eventType)
    );
  }

  /**
   * Check for workflow completion
   */
  private async checkWorkflowCompletion(workflowId: string, workflow: NonNullable<ReturnType<typeof this.workflowTracker.get>>, triggeringEvent: MonitorEvent): Promise<void> {
    const totalSteps = workflow.totalSteps;
    const completedSteps = workflow.completedSteps.size;
    const failedSteps = workflow.failedSteps.size;
    const finishedSteps = completedSteps + failedSteps;

    logger.info('üîç [WORKFLOW COMPLETION] Checking completion status', {
      workflowId,
      totalSteps: totalSteps || 'unknown',
      completedSteps,
      failedSteps,
      finishedSteps,
      allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
      completedStepsList: Array.from(workflow.completedSteps),
      failedStepsList: Array.from(workflow.failedSteps)
    });

    if (!totalSteps) {
      logger.debug('Workflow total steps unknown, deferring completion check', { workflowId });
      return;
    }

    if (finishedSteps === totalSteps && totalSteps > 0) {
      const isSuccess = failedSteps === 0;
      const eventType = isSuccess ? 'workflow_completed' : 'workflow_failed';
      
      logger.info('üéâ [WORKFLOW COMPLETION] Workflow completion detected!', {
        workflowId,
        totalSteps,
        completedSteps,
        failedSteps,
        success: isSuccess,
        eventType
      });

      await this.sendWorkflowEvent(eventType, workflowId, triggeringEvent);
      
      // Clean up workflow tracking
      this.workflowTracker.delete(workflowId);
      logger.debug('Cleaned up workflow tracking', { workflowId });
    } else {
      logger.debug('üöß [WORKFLOW COMPLETION] Workflow not yet complete', {
        workflowId,
        finishedSteps,
        totalSteps,
        stillNeed: totalSteps - finishedSteps
      });
    }
  }

  /**
   * Check if progress webhook should be throttled for this job
   */
  private shouldThrottleProgressWebhook(jobId: string): boolean {
    const now = Date.now();
    const lastSent = this.lastProgressWebhookSent.get(jobId);
    
    if (!lastSent || (now - lastSent) >= this.PROGRESS_THROTTLE_MS) {
      // Update the timestamp and allow the webhook
      this.lastProgressWebhookSent.set(jobId, now);
      return false; // Don't throttle
    }
    
    return true; // Throttle this webhook
  }

  /**
   * Start periodic cleanup of throttling map to prevent memory leaks
   */
  private startThrottleCleanup(): void {
    // Clean up throttling entries older than 5 minutes every minute
    this.throttleCleanupInterval = setInterval(() => {
      const now = Date.now();
      const staleThreshold = 5 * 60 * 1000; // 5 minutes
      let cleaned = 0;

      for (const [jobId, timestamp] of this.lastProgressWebhookSent.entries()) {
        if (now - timestamp > staleThreshold) {
          this.lastProgressWebhookSent.delete(jobId);
          cleaned++;
        }
      }

      if (cleaned > 0) {
        logger.debug(`Cleaned up ${cleaned} stale throttling entries`, {
          remaining: this.lastProgressWebhookSent.size
        });
      }
    }, 60 * 1000); // Run every minute
  }

  /**
   * Convert monitor event to webhook event type
   */
  private convertMonitorEventToWebhookEvent(event: MonitorEvent): WebhookEventType | null {
    switch (event.type) {
      case 'job_submitted':
        return 'job_submitted';
      case 'update_job_progress':
        return 'update_job_progress';
      case 'complete_job':
        return 'complete_job';
      case 'job_failed':
        return 'job_failed';
      case 'worker_connected':
      case 'worker_disconnected':
        return 'worker_status';
      case 'machine_startup_complete':
      case 'machine_shutdown':
        return 'machine_status';
      default:
        return null;
    }
  }

  /**
   * Find webhooks that match the event and filters
   */
  private findMatchingWebhooks(
    webhookEventType: WebhookEventType,
    event: MonitorEvent
  ): WebhookEndpoint[] {
    return Array.from(this.webhooksCache.values()).filter(webhook => {
      // Must be active
      if (!webhook.active) {
        return false;
      }

      // Must subscribe to this event type
      if (!webhook.events.includes(webhookEventType)) {
        return false;
      }

      // Apply filters
      if (webhook.filters) {
        return this.eventMatchesFilters(event, webhook.filters);
      }

      return true;
    });
  }

  /**
   * Check if event matches webhook filters
   */
  private eventMatchesFilters(event: MonitorEvent, filters: WebhookFilters): boolean {
    // Job type filter
    if (filters.job_types) {
      const jobEvent = event as JobSubmittedEvent | JobStatusChangedEvent;
      if ('job_id' in jobEvent && 'job_data' in jobEvent) {
        const jobData = jobEvent.job_data as { job_type?: string };
        if (!filters.job_types.includes(jobData.job_type || '')) {
          return false;
        }
      }
    }

    // Machine ID filter
    if (filters.machine_ids) {
      const machineEvent = event as unknown as Record<string, unknown>;
      if (
        machineEvent.machine_id &&
        !filters.machine_ids.includes(machineEvent.machine_id as string)
      ) {
        return false;
      }
    }

    // Worker ID filter
    if (filters.worker_ids) {
      const workerEvent = event as unknown as Record<string, unknown>;
      if (workerEvent.worker_id && !filters.worker_ids.includes(workerEvent.worker_id as string)) {
        return false;
      }
    }

    // Priority filter
    if (filters.job_priorities) {
      const jobEvent = event as unknown as Record<string, unknown>;
      if (
        jobEvent.priority !== undefined &&
        !filters.job_priorities.includes(jobEvent.priority as number)
      ) {
        return false;
      }
    }

    return true;
  }

  /**
   * Create webhook payload from event
   */
  private createWebhookPayload(
    webhook: WebhookEndpoint,
    eventType: WebhookEventType,
    event: MonitorEvent
  ): WebhookPayload {
    const eventData = this.extractEventData(event);

    return {
      event_type: eventType,
      event_id: this.generateId(),
      timestamp: event.timestamp,
      webhook_id: webhook.id,
      data: eventData,
    };
  }

  /**
   * Extract relevant data from monitor event
   */
  private extractEventData(event: MonitorEvent): WebhookEventData {
    const data: WebhookEventData = {};

    // Common job event properties
    const jobEvent = event as unknown as Record<string, unknown>;
    if (jobEvent.job_id) data.job_id = jobEvent.job_id as string;
    if (jobEvent.job_type) data.job_type = jobEvent.job_type as string;
    if (jobEvent.worker_id) data.worker_id = jobEvent.worker_id as string;
    if (jobEvent.machine_id) data.machine_id = jobEvent.machine_id as string;

    // IMPORTANT: Include workflow fields in webhook payload
    if (jobEvent.workflow_id) data.workflow_id = jobEvent.workflow_id as string;
    if (jobEvent.workflow_priority) data.workflow_priority = jobEvent.workflow_priority as number;
    if (jobEvent.workflow_datetime) data.workflow_datetime = jobEvent.workflow_datetime as number;
    if (jobEvent.step_number) data.step_number = jobEvent.step_number as number;
    if (jobEvent.total_steps) data.total_steps = jobEvent.total_steps as number;
    if (jobEvent.current_step) data.current_step = jobEvent.current_step as number;

    // Job submission events  
    if (event.type === 'job_submitted') {
      data.job_status = JobStatus.PENDING;
      data.priority = jobEvent.priority as number;
      data.payload = jobEvent.payload;
      data.requirements = jobEvent.requirements;
      data.customer_id = jobEvent.customer_id as string;
      data.submitted_at = jobEvent.created_at || jobEvent.timestamp;
    }

    // Status change events
    if (event.type === 'job_status_changed') {
      const statusEvent = event as JobStatusChangedEvent;
      data.job_status = statusEvent.new_status;
      data.old_status = statusEvent.old_status;
    }

    // Progress events
    if (event.type === 'update_job_progress') {
      const progressEvent = event as JobProgressEvent;
      data.progress = progressEvent.progress;
      // Note: stage is not available in JobProgressEvent, using optional property
      if ('stage' in progressEvent) {
        data.stage = (progressEvent as unknown as { stage: string }).stage;
      }
    }

    // Completion events
    if (event.type === 'complete_job') {
      const completeEvent = event as JobCompletedEvent;
      data.result = completeEvent.result;
      data.completed_at = completeEvent.completed_at;
    }

    // Failure events
    if (event.type === 'job_failed') {
      const failEvent = event as JobFailedEvent;
      data.error = failEvent.error;
      data.failed_at = failEvent.failed_at;
    }

    return data;
  }

  /**
   * Queue webhook delivery
   */
  private queueDelivery(payload: WebhookPayload): void {
    this.deliveryQueue.push(payload);
    logger.debug(`Webhook queued for delivery: ${payload.webhook_id}`, {
      event_type: payload.event_type,
      job_id: payload.data.job_id,
    });
  }

  /**
   * Start processing delivery queue
   */
  private startProcessing(): void {
    this.processingInterval = setInterval(() => {
      this.processDeliveryQueue();
    }, 1000); // Process every second
  }

  /**
   * Process webhook delivery queue
   */
  private async processDeliveryQueue(): Promise<void> {
    if (this.isProcessing || this.deliveryQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      const payload = this.deliveryQueue.shift();
      if (!payload) return;
      await this.deliverWebhook(payload);
    } catch (error) {
      logger.error('Error processing webhook delivery queue', error);
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Deliver webhook with retry logic
   */
  private async deliverWebhook(payload: WebhookPayload, attemptNumber = 1): Promise<void> {
    const webhook = await this.getWebhook(payload.webhook_id);
    if (!webhook) {
      logger.warn(`Webhook not found for delivery: ${payload.webhook_id}`);
      return;
    }

    // DEBUG: Log webhook delivery attempt
    logger.info(`üöÄ [WEBHOOK DEBUG] Sending webhook`, {
      webhook_id: webhook.id,
      webhook_url: webhook.url,
      event_type: payload.event_type,
      event_id: payload.event_id,
      attempt_number: attemptNumber,
      job_id: payload.data?.job_id,
      workflow_id: payload.data?.workflow_id,
      payload_summary: {
        type: payload.event_type,
        timestamp: payload.timestamp,
        data_keys: Object.keys(payload.data || {}),
      }
    });

    const attempt: WebhookDeliveryAttempt = {
      id: this.generateId(),
      webhook_id: webhook.id,
      event_id: payload.event_id,
      attempt_number: attemptNumber,
      timestamp: Date.now(),
      success: false,
    };

    try {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'User-Agent': 'EMP-Job-Queue-Webhook/1.0',
        'X-Webhook-Event': payload.event_type,
        'X-Webhook-ID': webhook.id,
        'X-Event-ID': payload.event_id,
        ...webhook.headers,
      };

      // Add HMAC signature if secret is configured
      if (webhook.secret) {
        const signature = await this.generateHmacSignature(payload, webhook.secret);
        headers['X-Webhook-Signature'] = signature;
      }

      // Use AbortController for timeout with native fetch
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      const response = await fetch(webhook.url, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      attempt.response_status = response.status;
      attempt.response_body = await response.text();
      attempt.success = response.ok;

      if (response.ok) {
        logger.info(`Webhook delivered successfully: ${webhook.id}`, {
          event_type: payload.event_type,
          job_id: payload.data.job_id,
          status: response.status,
        });
        this.emit('webhook.delivered', { webhook, payload, attempt });
      } else {
        throw new Error(`HTTP ${response.status}: ${attempt.response_body}`);
      }
    } catch (error) {
      attempt.error_message = error instanceof Error ? error.message : String(error);

      logger.warn(`Webhook delivery failed: ${webhook.id} (attempt ${attemptNumber})`, {
        error: attempt.error_message,
        event_type: payload.event_type,
        job_id: payload.data.job_id,
      });

      // Retry logic
      const retryConfig = webhook.retry_config || {
        max_attempts: 3,
        initial_delay_ms: 1000,
        backoff_multiplier: 2,
        max_delay_ms: 30000,
      };
      if (attemptNumber < retryConfig.max_attempts) {
        const delay = Math.min(
          retryConfig.initial_delay_ms *
            Math.pow(retryConfig.backoff_multiplier, attemptNumber - 1),
          retryConfig.max_delay_ms
        );

        attempt.next_retry_at = Date.now() + delay;
        this.retryQueue.set(attempt.id, attempt);

        setTimeout(() => {
          this.retryQueue.delete(attempt.id);
          void this.deliverWebhook(payload, attemptNumber + 1);
        }, delay);

        logger.info(`Webhook retry scheduled: ${webhook.id} in ${delay}ms`, {
          attempt: attemptNumber + 1,
          max_attempts: retryConfig.max_attempts,
        });
      } else {
        logger.error(`Webhook delivery failed permanently: ${webhook.id}`, {
          attempts: attemptNumber,
          error: attempt.error_message,
        });
        this.emit('webhook.failed', { webhook, payload, attempt });
      }
    }

    // Record attempt in Redis
    await this.webhookStorage.recordDeliveryAttempt(attempt);
    this.emit('webhook.attempt', { webhook, payload, attempt });
  }

  /**
   * Generate HMAC signature for webhook payload
   */
  private async generateHmacSignature(payload: WebhookPayload, secret: string): Promise<string> {
    const crypto = await import('crypto');
    const body = JSON.stringify(payload);
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(body);
    return `sha256=${hmac.digest('hex')}`;
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `wh_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get webhook delivery statistics
   */
  async getDeliveryStats(webhookId?: string): Promise<{
    total_deliveries: number;
    successful_deliveries: number;
    failed_deliveries: number;
    retry_queue_size: number;
    pending_deliveries: number;
    last_delivery_at?: number;
    last_success_at?: number;
    last_failure_at?: number;
  }> {
    if (webhookId) {
      const stats = await this.webhookStorage.getWebhookStats(webhookId);
      return {
        total_deliveries: stats?.total_deliveries || 0,
        successful_deliveries: stats?.successful_deliveries || 0,
        failed_deliveries: stats?.failed_deliveries || 0,
        retry_queue_size: this.retryQueue.size,
        pending_deliveries: this.deliveryQueue.length,
        last_delivery_at: stats?.last_delivery_at,
        last_success_at: stats?.last_success_at,
        last_failure_at: stats?.last_failure_at,
      };
    } else {
      // Return aggregate stats
      return {
        total_deliveries: 0,
        successful_deliveries: 0,
        failed_deliveries: 0,
        retry_queue_size: this.retryQueue.size,
        pending_deliveries: this.deliveryQueue.length,
      };
    }
  }

  /**
   * Test webhook endpoint
   */
  async testWebhook(webhookId: string): Promise<boolean> {
    const webhook = await this.getWebhook(webhookId);
    if (!webhook) {
      throw new Error(`Webhook not found: ${webhookId}`);
    }

    const baseEventId = 'test_wh_' + Date.now() + '_' + this.generateId().slice(-9);
    const timestamp = Date.now();
    let allTestsSucceeded = true;

    // Send a test event for each event type the webhook is subscribed to
    for (const eventType of webhook.events) {
      const testPayload = this.createTestPayloadForEventType(eventType, baseEventId, webhookId, timestamp);
      
      try {
        await this.deliverWebhook(testPayload);
        logger.debug(`Test event sent successfully: ${eventType}`, { webhook_id: webhookId });
      } catch (error) {
        logger.error(`Test event failed: ${eventType}`, { webhook_id: webhookId, error });
        allTestsSucceeded = false;
      }
    }

    return allTestsSucceeded;
  }

  private createTestPayloadForEventType(eventType: string, baseEventId: string, webhookId: string, timestamp: number): WebhookPayload {
    const testJobId = 'test_job_' + Date.now();
    const testWorkerId = 'test_worker_' + Math.random().toString(36).substr(2, 5);

    const basePayload = {
      event_id: `${baseEventId}_${eventType}`,
      timestamp,
      webhook_id: webhookId,
      metadata: {
        original_timestamp: timestamp,
        test_event: true,
      },
    };

    switch (eventType) {
      case 'job_submitted':
        return {
          ...basePayload,
          event_type: 'job_submitted',
          data: {
            job_id: testJobId,
            job_type: 'comfyui',
            priority: 100,
            payload: {
              test_data: 'Sample job submission for webhook testing',
              workflow: 'test_workflow.json'
            },
            requirements: {
              hardware: { gpu_memory_gb: 8 },
              models: ['test_model.safetensors']
            },
            customer_id: 'test_customer_123',
            submitted_at: new Date(timestamp).toISOString(),
            status: 'pending',
          },
        };

      case 'update_job_progress':
        return {
          ...basePayload,
          event_type: 'update_job_progress',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            progress: 45,
            progress_message: 'Processing test workflow...',
            status: 'in_progress',
            current_step: 3,
            total_steps: 5,
            estimated_completion: new Date(timestamp + 60000).toISOString(),
          },
        };

      case 'complete_job':
        return {
          ...basePayload,
          event_type: 'complete_job',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            progress: 100,
            result: { 
              output: 'Test job completed successfully',
              files: ['test_output.png'],
              duration_ms: 5000 
            },
            completed_at: new Date(timestamp).toISOString(),
            status: 'completed',
            message: 'Test job finished successfully',
          },
        };

      case 'job_failed':
        return {
          ...basePayload,
          event_type: 'job_failed',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            error: 'Test failure: Connection timeout during processing',
            failed_at: new Date(timestamp).toISOString(),
            status: 'failed',
            can_retry: false,
            retry_count: 3,
          },
        };

      case 'cancel_job':
        return {
          ...basePayload,
          event_type: 'cancel_job',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            cancelled_at: new Date(timestamp).toISOString(),
            reason: 'Test cancellation: User requested stop',
            cancelled_by: 'test_user',
          },
        };

      case 'worker_status':
        return {
          ...basePayload,
          event_type: 'worker_status',
          data: {
            worker_id: testWorkerId,
            machine_id: 'test_machine_' + Math.random().toString(36).substr(2, 5),
            status: 'busy',
            previous_status: 'idle',
            capabilities: ['comfyui', 'simulation'],
            current_job_id: testJobId,
          },
        };

      case 'machine_status':
        return {
          ...basePayload,
          event_type: 'machine_status',
          data: {
            machine_id: 'test_machine_' + Math.random().toString(36).substr(2, 5),
            status: 'ready',
            health: 'healthy',
            worker_count: 2,
            services: ['comfyui', 'simulation'],
            startup_time: 15000,
          },
        };

      default:
        // Fallback for unknown event types
        return {
          ...basePayload,
          event_type: eventType as WebhookEventType,
          data: {
            job_id: testJobId,
            test_event_type: eventType,
            message: `Test event for ${eventType}`,
          },
        };
    }
  }

  /**
   * Start periodic cache refresh from Redis
   */
  private startCacheRefresh(): void {
    this.refreshCache(); // Initial load
    this.cacheRefreshInterval = setInterval(() => {
      this.refreshCache();
    }, 30000); // Refresh every 30 seconds
  }

  /**
   * Refresh webhook cache from Redis
   */
  private async refreshCache(): Promise<void> {
    try {
      const activeWebhooks = await this.webhookStorage.getActiveWebhooks();

      // Clear and rebuild cache
      this.webhooksCache.clear();
      for (const webhook of activeWebhooks) {
        this.webhooksCache.set(webhook.id, webhook);
      }

      logger.debug(`Webhook cache refreshed: ${activeWebhooks.length} active webhooks`);
    } catch (error) {
      logger.error('Failed to refresh webhook cache:', error);
    }
  }

  /**
   * Get webhook storage instance (for direct access if needed)
   */
  getWebhookStorage(): WebhookRedisStorage {
    return this.webhookStorage;
  }

  /**
   * Get webhook delivery history
   */
  async getWebhookDeliveryHistory(webhookId: string, limit = 50) {
    return await this.webhookStorage.getWebhookDeliveryHistory(webhookId, limit);
  }

  /**
   * Get recent deliveries across all webhooks
   */
  async getRecentDeliveries(limit = 100) {
    return await this.webhookStorage.getRecentDeliveries(limit);
  }

  /**
   * Get webhook summary for dashboard
   */
  async getWebhookSummary() {
    return await this.webhookStorage.getWebhookSummary();
  }

  /**
   * Cleanup resources
   */
  destroy(): void {
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
    }
    if (this.cacheRefreshInterval) {
      clearInterval(this.cacheRefreshInterval);
    }
    if (this.throttleCleanupInterval) {
      clearInterval(this.throttleCleanupInterval);
    }
    this.webhooksCache.clear();
    this.deliveryQueue.length = 0;
    this.retryQueue.clear();
    this.lastProgressWebhookSent.clear(); // Clean up throttling map
    this.workflowTracker.clear(); // Clean up workflow tracking
  }
}
