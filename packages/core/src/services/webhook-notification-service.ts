/**
 * Webhook Notification Service
 *
 * Delivers HTTP webhook notifications for job status changes and other events.
 * Integrates with the existing EventBroadcaster system to send notifications
 * to external systems when jobs are submitted, progress updates, complete, fail, etc.
 */

import { EventEmitter } from 'events';
import { Redis } from 'ioredis';
import { logger } from '../utils/logger.js';
import { WebhookRedisStorage } from './webhook-redis-storage.js';
import {
  MonitorEvent,
  JobSubmittedEvent,
  JobStatusChangedEvent,
  JobProgressEvent,
  JobCompletedEvent,
  JobFailedEvent,
} from '../types/monitor-events.js';
import { JobStatus } from '../types/job.js';

// Webhook configuration types
export interface WebhookEndpoint {
  id: string;
  url: string;
  secret?: string; // For HMAC signature verification
  events: WebhookEventType[];
  filters?: WebhookFilters;
  headers?: Record<string, string>;
  retry_config?: WebhookRetryConfig;
  active: boolean;
  created_at: number;
  updated_at: number;
}

export type WebhookEventType =
  | 'job_submitted' // Job submitted to queue (published by API)
  | 'update_job_progress' // Job progress updates (published by workers)
  | 'complete_job' // Job completed successfully (published by workers)
  | 'job_failed' // Job failed permanently (published by workers)
  | 'cancel_job' // Job cancelled (published by API)
  | 'worker_status' // Worker status changes
  | 'machine_status' // Machine status changes
  | 'workflow_completed' // Workflow completed (all steps finished) - generated by webhook service
  | 'workflow_submitted' // First job in workflow submitted - generated by webhook service
  | 'workflow_failed'; // Workflow failed (partial or complete failure) - generated by webhook service

export interface WebhookFilters {
  job_types?: string[]; // Filter by job type (e.g., ['comfyui', 'openai'])
  job_priorities?: number[]; // Filter by priority levels
  machine_ids?: string[]; // Filter by specific machines
  worker_ids?: string[]; // Filter by specific workers
  custom_filters?: Record<string, unknown>; // Custom filter criteria
}

export interface WebhookRetryConfig {
  max_attempts: number; // Default: 3
  initial_delay_ms: number; // Default: 1000 (1 second)
  backoff_multiplier: number; // Default: 2 (exponential backoff)
  max_delay_ms: number; // Default: 30000 (30 seconds)
}

export interface WebhookPayload {
  event_type: WebhookEventType;
  event_id: string;
  timestamp: number;
  webhook_id: string;
  data: WebhookEventData;
  metadata?: {
    retry_attempt?: number;
    original_timestamp?: number;
  };
}

export interface WebhookEventData {
  job_id?: string;
  job_type?: string;
  job_status?: JobStatus;
  worker_id?: string;
  machine_id?: string;
  progress?: number;
  result?: unknown;
  error?: string;
  // Workflow fields - CRITICAL for workflow tracking
  workflow_id?: string;
  workflow_priority?: number;
  workflow_datetime?: number;
  step_number?: number;
  total_steps?: number;
  current_step?: number;
  [key: string]: unknown;
}

export interface WebhookDeliveryAttempt {
  id: string;
  webhook_id: string;
  event_id: string;
  event_type: string; // The type of webhook event (job_failed, workflow_completed, etc.)
  attempt_number: number;
  timestamp: number;
  success: boolean;
  response_status?: number;
  response_body?: string;
  error_message?: string;
  next_retry_at?: number;
}

export class WebhookNotificationService extends EventEmitter {
  private webhookStorage: WebhookRedisStorage;
  private webhooksCache: Map<string, WebhookEndpoint> = new Map();
  private deliveryQueue: WebhookPayload[] = [];
  private retryQueue: Map<string, WebhookDeliveryAttempt> = new Map();
  private isProcessing = false;
  private processingInterval?: NodeJS.Timeout;
  private cacheRefreshInterval?: NodeJS.Timeout;
  private throttleCleanupInterval?: NodeJS.Timeout;
  private empropsApiUrl: string;
  private empropsApiKey?: string;

  // Throttling: Track last progress webhook sent per job (1 per second max)
  private lastProgressWebhookSent: Map<string, number> = new Map();
  private readonly PROGRESS_THROTTLE_MS = 1000; // 1 second

  // Workflow tracking for completion detection (independent of subscriptions)
  private workflowTracker = new Map<
    string,
    {
      steps: Map<number, string>; // step_number -> job_id mapping
      completedSteps: Set<number>; // completed step numbers (1-indexed)
      failedSteps: Set<number>; // failed step numbers (1-indexed)
      stepErrors: Map<number, string>; // step_number -> error message for failed steps
      totalSteps?: number; // total steps in workflow (from job submission)
      startTime: number;
      lastUpdate: number;
      currentStep?: number; // highest current_step seen
    }
  >();

  constructor(redis: Redis) {
    super();
    this.webhookStorage = new WebhookRedisStorage(redis);
    
    // REQUIRED: EMPROPS_API_URL must be explicitly set
    if (!process.env.EMPROPS_API_URL) {
      throw new Error('EMPROPS_API_URL environment variable is required for webhook notification service');
    }
    this.empropsApiUrl = process.env.EMPROPS_API_URL;
    
    // Optional: EMPROPS_API_KEY for authenticated endpoints
    this.empropsApiKey = process.env.EMPROPS_API_KEY;
    if (!this.empropsApiKey) {
      logger.warn('‚ö†Ô∏è [WEBHOOK] EMPROPS_API_KEY not set - API calls may fail if authentication is required');
    }
    
    this.startProcessing();
    this.startCacheRefresh();
    this.startThrottleCleanup();
  }

  /**
   * Register a new webhook endpoint
   */
  async registerWebhook(
    config: Omit<WebhookEndpoint, 'id' | 'created_at' | 'updated_at'>
  ): Promise<WebhookEndpoint> {
    const webhook: WebhookEndpoint = {
      id: this.generateId(),
      created_at: Date.now(),
      updated_at: Date.now(),
      retry_config: {
        max_attempts: 3,
        initial_delay_ms: 1000,
        backoff_multiplier: 2,
        max_delay_ms: 30000,
        ...config.retry_config,
      },
      ...config,
    };

    await this.webhookStorage.storeWebhook(webhook);
    this.webhooksCache.set(webhook.id, webhook);

    logger.info(`Webhook registered: ${webhook.id} -> ${webhook.url}`, {
      webhook_id: webhook.id,
      events: webhook.events,
      filters: webhook.filters,
    });

    return webhook;
  }

  /**
   * Update an existing webhook
   */
  async updateWebhook(
    id: string,
    updates: Partial<WebhookEndpoint>
  ): Promise<WebhookEndpoint | null> {
    const updatedWebhook = await this.webhookStorage.updateWebhook(id, updates);
    if (updatedWebhook) {
      this.webhooksCache.set(id, updatedWebhook);
      logger.info(`Webhook updated: ${id}`, { updates });
    }
    return updatedWebhook;
  }

  /**
   * Delete a webhook
   */
  async deleteWebhook(id: string): Promise<boolean> {
    const deleted = await this.webhookStorage.deleteWebhook(id);
    if (deleted) {
      this.webhooksCache.delete(id);
      logger.info(`Webhook deleted: ${id}`);
    }
    return deleted;
  }

  /**
   * Get all webhooks
   */
  async getWebhooks(): Promise<WebhookEndpoint[]> {
    return await this.webhookStorage.getAllWebhooks();
  }

  /**
   * Get a specific webhook
   */
  async getWebhook(id: string): Promise<WebhookEndpoint | null> {
    // Try cache first
    const cached = this.webhooksCache.get(id);
    if (cached) {
      return cached;
    }

    // Fallback to Redis
    const webhook = await this.webhookStorage.getWebhook(id);
    if (webhook) {
      this.webhooksCache.set(id, webhook);
    }
    return webhook;
  }

  /**
   * Process monitor events and trigger webhooks
   */
  async processEvent(event: MonitorEvent): Promise<void> {
    // DEBUG: Log event processing (skip progress updates to reduce noise)
    if (event.type !== 'update_job_progress') {
      logger.info(`üì• [WEBHOOK DEBUG] Processing event for webhooks`, {
        event_type: event.type,
        job_id: (event as any).job_id,
        workflow_id: (event as any).workflow_id,
        timestamp: event.timestamp,
      });
    }

    const webhookEvent = this.convertMonitorEventToWebhookEvent(event);
    if (!webhookEvent) {
      logger.debug(`üì§ [WEBHOOK DEBUG] Event not supported for webhooks: ${event.type}`);
      return; // Event not supported for webhooks
    }

    // ALWAYS process workflow tracking events for workflow detection
    // even if no webhooks are subscribed to individual job events
    await this.processWorkflowTracking(event, webhookEvent);

    // THROTTLING: Check if this is a progress update and if we should throttle it
    if (webhookEvent === 'update_job_progress') {
      const jobId = (event as any).job_id as string;
      if (jobId && this.shouldThrottleProgressWebhook(jobId)) {
        logger.debug(
          `‚è±Ô∏è [WEBHOOK DEBUG] Throttling progress webhook for job ${jobId} (< 1 second since last)`
        );
        return;
      }
    }

    // Find matching webhooks for THIS specific event (only send if explicitly subscribed)
    const matchingWebhooks = this.findMatchingWebhooks(webhookEvent, event);

    // Only log for non-progress events to reduce noise
    if (event.type !== 'update_job_progress') {
      logger.info(
        `üéØ [WEBHOOK DEBUG] Found ${matchingWebhooks.length} matching webhooks for ${event.type}`
      );
    }

    for (const webhook of matchingWebhooks) {
      const payload = this.createWebhookPayload(webhook, webhookEvent, event);

      // Only log for non-progress events to reduce noise
      if (event.type !== 'update_job_progress') {
        logger.info(`üìã [WEBHOOK DEBUG] Queueing webhook delivery`, {
          webhook_id: webhook.id,
          webhook_url: webhook.url,
          event_type: webhookEvent,
          job_id: (event as any).job_id,
          workflow_id: (event as any).workflow_id,
        });
      }

      this.queueDelivery(payload);
    }
  }

  /**
   * Process workflow tracking for completion detection (independent of subscriptions)
   */
  private async processWorkflowTracking(
    event: MonitorEvent,
    webhookEventType: WebhookEventType
  ): Promise<void> {
    const jobEvent = event as unknown as Record<string, unknown>;
    const workflowId = jobEvent.workflow_id as string;
    const jobId = jobEvent.job_id as string;
    const currentStep = jobEvent.current_step as number;
    const stepNumber = jobEvent.step_number as number;
    const totalSteps = jobEvent.total_steps as number;

    // DEBUG: Log extracted data for workflow events
    if (workflowId) {
      logger.info('üìã [WORKFLOW TRACKING] Processing workflow event', {
        eventType: webhookEventType,
        workflowId,
        jobId,
        currentStep,
        stepNumber,
        totalSteps,
        rawEvent: {
          type: event.type,
          workflow_id: jobEvent.workflow_id,
          job_id: jobEvent.job_id,
          current_step: jobEvent.current_step,
          step_number: jobEvent.step_number,
          total_steps: jobEvent.total_steps,
        },
      });
    }

    // Only track workflow events
    if (!workflowId || !jobId) {
      return;
    }

    const now = Date.now();
    let workflow = this.workflowTracker.get(workflowId);

    // Initialize workflow tracking if not exists
    if (!workflow) {
      workflow = {
        steps: new Map(),
        completedSteps: new Set(),
        failedSteps: new Set(),
        stepErrors: new Map(),
        startTime: now,
        lastUpdate: now,
      };
      this.workflowTracker.set(workflowId, workflow);
      logger.debug('Started tracking workflow', { workflowId });
    }

    // Update workflow metadata
    workflow.lastUpdate = now;
    if (totalSteps && !workflow.totalSteps) {
      workflow.totalSteps = totalSteps;
      logger.debug('Set workflow total steps', { workflowId, totalSteps });
    }
    if (currentStep && (!workflow.currentStep || currentStep > workflow.currentStep)) {
      workflow.currentStep = currentStep;
    }

    // Track step in workflow
    const effectiveStepNumber = currentStep || stepNumber || 1;
    workflow.steps.set(effectiveStepNumber, jobId);

    // Check if this is the first step being submitted (workflow_submitted event)
    if (
      webhookEventType === 'job_submitted' &&
      effectiveStepNumber === 1 &&
      workflow.steps.size === 1
    ) {
      await this.sendWorkflowEvent('workflow_submitted', workflowId, event);
    }

    // Handle completion/failure
    const wasCompleted = workflow.completedSteps.has(effectiveStepNumber);
    const wasFailed = workflow.failedSteps.has(effectiveStepNumber);

    if (webhookEventType === 'complete_job' && !wasCompleted) {
      workflow.completedSteps.add(effectiveStepNumber);
      workflow.failedSteps.delete(effectiveStepNumber);
      logger.info('üéØ [WORKFLOW COMPLETION] Step completed', {
        workflowId,
        jobId,
        stepNumber: effectiveStepNumber,
        completed: workflow.completedSteps.size,
        total: workflow.totalSteps || workflow.steps.size,
        allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
        completedSteps: Array.from(workflow.completedSteps),
        failedSteps: Array.from(workflow.failedSteps),
      });
    } else if (webhookEventType === 'job_failed' && !wasFailed) {
      workflow.failedSteps.add(effectiveStepNumber);
      workflow.completedSteps.delete(effectiveStepNumber);
      
      // Store the error message for this step
      const errorMessage = (event as any).error || 'Unknown error';
      workflow.stepErrors.set(effectiveStepNumber, errorMessage);
      logger.info('‚ùå [WORKFLOW COMPLETION] Step failed', {
        workflowId,
        jobId,
        stepNumber: effectiveStepNumber,
        failed: workflow.failedSteps.size,
        total: workflow.totalSteps || workflow.steps.size,
        allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
        completedSteps: Array.from(workflow.completedSteps),
        failedSteps: Array.from(workflow.failedSteps),
      });
    } else if (webhookEventType === 'complete_job' && wasCompleted) {
      logger.debug('üîÑ [WORKFLOW COMPLETION] Step already completed, skipping', {
        workflowId,
        jobId,
        stepNumber: effectiveStepNumber,
      });
    }

    // Check for workflow completion
    await this.checkWorkflowCompletion(workflowId, workflow, event);
  }

  /**
   * Send workflow events to subscribed webhooks
   */
  private async sendWorkflowEvent(
    eventType: 'workflow_submitted' | 'workflow_completed' | 'workflow_failed',
    workflowId: string,
    triggeringEvent: MonitorEvent
  ): Promise<void> {
    const workflowEvent = await this.createWorkflowEvent(eventType, workflowId, triggeringEvent);

    // Find webhooks subscribed to this workflow event type
    const matchingWebhooks = this.findMatchingWebhooksForEventType(eventType);

    logger.info(`üéØ [WORKFLOW] Found ${matchingWebhooks.length} webhooks for ${eventType}`, {
      workflowId,
    });

    for (const webhook of matchingWebhooks) {
      const payload = {
        event_type: eventType,
        event_id: this.generateId(),
        timestamp: Date.now(),
        webhook_id: webhook.id,
        data: workflowEvent,
      };

      logger.info(`üìã [WORKFLOW] Queueing ${eventType} webhook`, {
        webhook_id: webhook.id,
        webhook_url: webhook.url,
        workflow_id: workflowId,
      });

      this.queueDelivery(payload);
    }
  }

  /**
   * Handle workflow completion with EMPROPS API confirmation and fallback
   */
  private async handleWorkflowCompletionWithEmpropsConfirmation(
    workflowId: string, 
    triggeringEvent: MonitorEvent
  ): Promise<void> {
    const maxRetries = 10;
    const retryDelayMs = 2000; // 2 seconds between retries
    
    logger.info('‚è≥ [WORKFLOW COMPLETION] Waiting for EMPROPS API to confirm workflow completion...');
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        logger.info(`üîç [WORKFLOW COMPLETION] Checking EMPROPS API (attempt ${attempt}/${maxRetries})`);
        
        const workflowDetails = await this.fetchWorkflowDetails(workflowId);
        const empStatus = workflowDetails?.data?.status;
        const hasOutputs = workflowDetails?.data?.data?.outputs && workflowDetails.data.data.outputs.length > 0;
        
        logger.info(`üìä [WORKFLOW COMPLETION] EMPROPS Status Check:`);
        logger.info(`   Status: ${empStatus}`);
        logger.info(`   Progress: ${workflowDetails?.data?.progress || 'unknown'}`);
        logger.info(`   Has Outputs: ${hasOutputs}`);
        
        if (empStatus === 'completed') {
          logger.info('‚úÖ [WORKFLOW COMPLETION] EMPROPS workflow confirmed complete, sending webhook with outputs');
          await this.sendWorkflowEvent('workflow_completed', workflowId, triggeringEvent);
          return;
        }
        
        if (attempt < maxRetries) {
          logger.info(`   ‚è≥ EMPROPS job still ${empStatus}, waiting ${retryDelayMs}ms before next check...`);
          await new Promise(resolve => setTimeout(resolve, retryDelayMs));
        }
        
      } catch (error) {
        // Handle 404 or other errors - could be direct workflow not tracked by EMPROPS
        if (error.message?.includes('404') || error.message?.includes('not found')) {
          logger.info('üîÑ [WORKFLOW COMPLETION] EMPROPS job not found (likely direct workflow), sending completion with available data');
          await this.sendWorkflowEvent('workflow_completed', workflowId, triggeringEvent);
          return;
        }
        
        // For other errors, log and continue retrying
        logger.warn(`‚ö†Ô∏è [WORKFLOW COMPLETION] Attempt ${attempt} failed:`, error.message);
        
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, retryDelayMs));
        }
      }
    }
    
    // Fallback: Send completion event even if EMPROPS API never confirmed
    logger.warn(`‚ö†Ô∏è [WORKFLOW COMPLETION] EMPROPS API never confirmed completion after ${maxRetries} attempts, sending webhook anyway`);
    await this.sendWorkflowEvent('workflow_completed', workflowId, triggeringEvent);
  }

  /**
   * Fetch workflow details from EMPROPS API
   */
  private async fetchWorkflowDetails(workflowId: string): Promise<any> {
    try {
      const url = `${this.empropsApiUrl}/jobs/${workflowId}`;
      logger.info(`üîç [WEBHOOK] Making EMPROPS API Request:`);
      logger.info(`   URL: ${url}`);
      logger.info(`   Method: GET`);
      logger.info(`   Workflow ID: ${workflowId}`);
      
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };
      
      // Add authorization header if API key is available
      if (this.empropsApiKey) {
        headers['Authorization'] = `Bearer ${this.empropsApiKey}`;
        logger.info(`   Auth: Using Bearer token`);
      } else {
        logger.warn(`   Auth: No API key available`);
      }
      
      const startTime = Date.now();
      const response = await fetch(url, {
        method: 'GET',
        headers,
        // 10 second timeout for API calls
        signal: AbortSignal.timeout(10000)
      });
      const responseTime = Date.now() - startTime;

      logger.info(`üì° [WEBHOOK] EMPROPS API Response:`);
      logger.info(`   Status: ${response.status} ${response.statusText}`);
      logger.info(`   Response Time: ${responseTime}ms`);
      logger.info(`   Headers: ${JSON.stringify(Object.fromEntries(response.headers.entries()))}`);

      if (!response.ok) {
        const errorBody = await response.text();
        logger.error(`‚ùå [WEBHOOK] EMPROPS API Error Response:`);
        logger.error(`   Status: ${response.status}`);
        logger.error(`   Body: ${errorBody}`);
        throw new Error(`EMPROPS API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      logger.info(`‚úÖ [WEBHOOK] Successfully fetched workflow details for ${workflowId}`);
      
      // Log the COMPLETE response without truncation
      const responseStr = JSON.stringify(data, null, 2);
      console.log(`üìã [WEBHOOK] FULL API RESPONSE:\n${responseStr}`);
      
      // Also split into chunks for structured logging
      const chunks = responseStr.match(/.{1,1000}/g) || [];
      chunks.forEach((chunk, index) => {
        logger.info(`üìã [WEBHOOK] Response chunk ${index + 1}/${chunks.length}: ${chunk}`);
      });
      
      logger.info(`   Response Data Structure:`);
      logger.info(`   - Has data: ${!!data?.data}`);
      logger.info(`   - Has data.data: ${!!data?.data?.data}`);
      logger.info(`   - Has outputs: ${!!data?.data?.data?.outputs}`);
      logger.info(`   - Output count: ${data?.data?.data?.outputs?.length || 0}`);
      logger.info(`   - Job type: ${data?.data?.job_type || 'N/A'}`);
      logger.info(`   - Workflow name: ${data?.data?.name || 'N/A'}`);
      
      // Log first output if exists (CORRECT PATH: data.data.outputs)
      if (data?.data?.data?.outputs?.length > 0) {
        const firstOutput = data.data.data.outputs[0];
        logger.info(`   - First output ID: ${firstOutput?.id || 'unknown'}`);
        
        // Check for image outputs in steps
        if (firstOutput?.steps?.length > 0) {
          firstOutput.steps.forEach((step: any, index: number) => {
            if (step?.nodeResponse?.src) {
              logger.info(`   - Step ${index + 1} output: ${step.nodeName} - ${step.nodeResponse.src}`);
            }
          });
        }
      }
      
      return data;
    } catch (error) {
      logger.error(`‚ùå [WEBHOOK] Failed to fetch workflow details for ${workflowId}:`, error);
      logger.error(`   Error Type: ${error.constructor.name}`);
      logger.error(`   Error Message: ${error.message}`);
      if (error.cause) {
        logger.error(`   Error Cause: ${error.cause}`);
      }
      return null;
    }
  }

  /**
   * Create workflow event data
   */
  private async createWorkflowEvent(
    eventType: string,
    workflowId: string,
    triggeringEvent: MonitorEvent
  ): Promise<Record<string, unknown>> {
    const jobEvent = triggeringEvent as unknown as Record<string, unknown>;
    const workflow = this.workflowTracker.get(workflowId);

    const baseEvent = {
      workflow_id: workflowId,
      timestamp: Date.now(),
      trigger_job_id: jobEvent.job_id,
      trigger_event_type: triggeringEvent.type,
    };

    if (eventType === 'workflow_submitted') {
      return {
        ...baseEvent,
        first_job_id: jobEvent.job_id,
        total_steps: jobEvent.total_steps,
        workflow_priority: jobEvent.workflow_priority,
        workflow_datetime: jobEvent.workflow_datetime,
        customer_id: jobEvent.customer_id,
        service_required: jobEvent.service_required,
      };
    }

    if (workflow && (eventType === 'workflow_completed' || eventType === 'workflow_failed')) {
      const isSuccess = eventType === 'workflow_completed';
      const duration = Date.now() - workflow.startTime;

      // Base workflow event data
      const workflowEventData: Record<string, unknown> = {
        ...baseEvent,
        success: isSuccess,
        total_steps: workflow.totalSteps,
        completed_steps: workflow.completedSteps.size,
        failed_steps: workflow.failedSteps.size,
        duration_ms: duration,
        start_time: workflow.startTime,
        end_time: Date.now(),
        current_step: jobEvent.current_step,
        step_details: Array.from(workflow.steps.entries()).map(([stepNum, stepJobId]) => {
          const hasError = workflow.stepErrors.has(stepNum);
          const errorMessage = workflow.stepErrors.get(stepNum);
          
          const stepDetail: {
            step_number: number;
            job_id: string;
            completed: boolean;
            failed: boolean;
            error?: string;
          } = {
            step_number: stepNum,
            job_id: stepJobId,
            completed: workflow.completedSteps.has(stepNum),
            failed: workflow.failedSteps.has(stepNum),
          };
          
          // Add error field if present
          if (hasError && errorMessage) {
            stepDetail.error = errorMessage;
          }
          
          return stepDetail;
        }),
      };

      // For completed workflows, try to enhance with EMPROPS API data (already fetched in confirmation)
      if (isSuccess) {
        try {
          logger.info(`üîç [WEBHOOK] Attempting to enhance workflow_completed event with EMPROPS API data for ${workflowId}`);
          const workflowDetails = await this.fetchWorkflowDetails(workflowId);
          
          if (workflowDetails?.data?.data?.outputs) {
            workflowEventData.outputs = workflowDetails.data.data.outputs;
            logger.info(`   ‚úÖ Added ${workflowDetails.data.data.outputs.length} outputs to webhook payload`);
            
            // Log the actual image URLs we're sending
            workflowDetails.data.data.outputs.forEach((output: any, index: number) => {
              if (output.steps) {
                output.steps.forEach((step: any) => {
                  if (step?.nodeResponse?.src) {
                    logger.info(`   üñºÔ∏è Output ${index + 1} - ${step.nodeName}: ${step.nodeResponse.src}`);
                  }
                });
              }
            });
            
            logger.info(`üì§ [WEBHOOK] Final enriched payload size: ${JSON.stringify(workflowEventData).length} bytes`);
          } else {
            logger.info(`   ‚ö†Ô∏è No outputs found in EMPROPS API response, sending basic workflow data`);
          }
        } catch (error) {
          // Fallback: If EMPROPS API fails (404, timeout, etc.), send basic workflow event
          logger.warn(`‚ö†Ô∏è [WEBHOOK] Could not enhance with EMPROPS API data (${error.message}), sending basic workflow completion`);
        }
      }

      return workflowEventData;
    }

    return baseEvent;
  }

  /**
   * Find webhooks matching a specific event type
   */
  private findMatchingWebhooksForEventType(eventType: WebhookEventType): WebhookEndpoint[] {
    const allWebhooks = Array.from(this.webhooksCache.values());
    return allWebhooks.filter(webhook => webhook.active && webhook.events.includes(eventType));
  }

  /**
   * Check for workflow completion
   */
  private async checkWorkflowCompletion(
    workflowId: string,
    workflow: NonNullable<ReturnType<typeof this.workflowTracker.get>>,
    triggeringEvent: MonitorEvent
  ): Promise<void> {
    const totalSteps = workflow.totalSteps;
    const completedSteps = workflow.completedSteps.size;
    const failedSteps = workflow.failedSteps.size;
    const finishedSteps = completedSteps + failedSteps;

    logger.info('üîç [WORKFLOW COMPLETION] Checking completion status', {
      workflowId,
      totalSteps: totalSteps || 'unknown',
      completedSteps,
      failedSteps,
      finishedSteps,
      allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
      completedStepsList: Array.from(workflow.completedSteps),
      failedStepsList: Array.from(workflow.failedSteps),
    });

    if (!totalSteps) {
      logger.debug('Workflow total steps unknown, deferring completion check', { workflowId });
      return;
    }

    if (finishedSteps === totalSteps && totalSteps > 0) {
      const isSuccess = failedSteps === 0;
      const eventType = isSuccess ? 'workflow_completed' : 'workflow_failed';

      logger.info('üéâ [WORKFLOW COMPLETION] Job queue steps finished!', {
        workflowId,
        totalSteps,
        completedSteps,
        failedSteps,
        success: isSuccess,
        eventType,
      });

      // For successful workflows, wait for EMPROPS API confirmation with fallback
      if (isSuccess) {
        await this.handleWorkflowCompletionWithEmpropsConfirmation(workflowId, triggeringEvent);
      } else {
        // For failed workflows, send immediately
        logger.info('‚ùå [WORKFLOW COMPLETION] Workflow failed, sending failure event immediately');
        await this.sendWorkflowEvent(eventType, workflowId, triggeringEvent);
      }

      // Clean up workflow tracking
      this.workflowTracker.delete(workflowId);
      logger.debug('Cleaned up workflow tracking', { workflowId });
    } else {
      logger.debug('üöß [WORKFLOW COMPLETION] Workflow not yet complete', {
        workflowId,
        finishedSteps,
        totalSteps,
        stillNeed: totalSteps - finishedSteps,
      });
    }
  }

  /**
   * Check if progress webhook should be throttled for this job
   */
  private shouldThrottleProgressWebhook(jobId: string): boolean {
    const now = Date.now();
    const lastSent = this.lastProgressWebhookSent.get(jobId);

    if (!lastSent || now - lastSent >= this.PROGRESS_THROTTLE_MS) {
      // Update the timestamp and allow the webhook
      this.lastProgressWebhookSent.set(jobId, now);
      return false; // Don't throttle
    }

    return true; // Throttle this webhook
  }

  /**
   * Start periodic cleanup of throttling map to prevent memory leaks
   */
  private startThrottleCleanup(): void {
    // Clean up throttling entries older than 5 minutes every minute
    this.throttleCleanupInterval = setInterval(() => {
      const now = Date.now();
      const staleThreshold = 5 * 60 * 1000; // 5 minutes
      let cleaned = 0;

      for (const [jobId, timestamp] of this.lastProgressWebhookSent.entries()) {
        if (now - timestamp > staleThreshold) {
          this.lastProgressWebhookSent.delete(jobId);
          cleaned++;
        }
      }

      if (cleaned > 0) {
        logger.debug(`Cleaned up ${cleaned} stale throttling entries`, {
          remaining: this.lastProgressWebhookSent.size,
        });
      }
    }, 60 * 1000); // Run every minute
  }

  /**
   * Convert monitor event to webhook event type
   */
  private convertMonitorEventToWebhookEvent(event: MonitorEvent): WebhookEventType | null {
    switch (event.type) {
      case 'job_submitted':
        return 'job_submitted';
      case 'update_job_progress':
        return 'update_job_progress';
      case 'complete_job':
        return 'complete_job';
      case 'job_failed':
        return 'job_failed';
      case 'worker_connected':
      case 'worker_disconnected':
        return 'worker_status';
      case 'machine_startup_complete':
      case 'machine_shutdown':
        return 'machine_status';
      default:
        return null;
    }
  }

  /**
   * Find webhooks that match the event and filters
   */
  private findMatchingWebhooks(
    webhookEventType: WebhookEventType,
    event: MonitorEvent
  ): WebhookEndpoint[] {
    return Array.from(this.webhooksCache.values()).filter(webhook => {
      // Must be active
      if (!webhook.active) {
        return false;
      }

      // Must subscribe to this event type
      if (!webhook.events.includes(webhookEventType)) {
        return false;
      }

      // Apply filters
      if (webhook.filters) {
        return this.eventMatchesFilters(event, webhook.filters);
      }

      return true;
    });
  }

  /**
   * Check if event matches webhook filters
   */
  private eventMatchesFilters(event: MonitorEvent, filters: WebhookFilters): boolean {
    // Job type filter
    if (filters.job_types) {
      const jobEvent = event as JobSubmittedEvent | JobStatusChangedEvent;
      if ('job_id' in jobEvent && 'job_data' in jobEvent) {
        const jobData = jobEvent.job_data as { job_type?: string };
        if (!filters.job_types.includes(jobData.job_type || '')) {
          return false;
        }
      }
    }

    // Machine ID filter
    if (filters.machine_ids) {
      const machineEvent = event as unknown as Record<string, unknown>;
      if (
        machineEvent.machine_id &&
        !filters.machine_ids.includes(machineEvent.machine_id as string)
      ) {
        return false;
      }
    }

    // Worker ID filter
    if (filters.worker_ids) {
      const workerEvent = event as unknown as Record<string, unknown>;
      if (workerEvent.worker_id && !filters.worker_ids.includes(workerEvent.worker_id as string)) {
        return false;
      }
    }

    // Priority filter
    if (filters.job_priorities) {
      const jobEvent = event as unknown as Record<string, unknown>;
      if (
        jobEvent.priority !== undefined &&
        !filters.job_priorities.includes(jobEvent.priority as number)
      ) {
        return false;
      }
    }

    return true;
  }

  /**
   * Create webhook payload from event
   */
  private createWebhookPayload(
    webhook: WebhookEndpoint,
    eventType: WebhookEventType,
    event: MonitorEvent
  ): WebhookPayload {
    const eventData = this.extractEventData(event);

    return {
      event_type: eventType,
      event_id: this.generateId(),
      timestamp: event.timestamp,
      webhook_id: webhook.id,
      data: eventData,
    };
  }

  /**
   * Extract relevant data from monitor event
   */
  private extractEventData(event: MonitorEvent): WebhookEventData {
    const data: WebhookEventData = {};

    // Common job event properties
    const jobEvent = event as unknown as Record<string, unknown>;
    if (jobEvent.job_id) data.job_id = jobEvent.job_id as string;
    if (jobEvent.job_type) data.job_type = jobEvent.job_type as string;
    if (jobEvent.worker_id) data.worker_id = jobEvent.worker_id as string;
    if (jobEvent.machine_id) data.machine_id = jobEvent.machine_id as string;

    // IMPORTANT: Include workflow fields in webhook payload
    if (jobEvent.workflow_id) data.workflow_id = jobEvent.workflow_id as string;
    if (jobEvent.workflow_priority) data.workflow_priority = jobEvent.workflow_priority as number;
    if (jobEvent.workflow_datetime) data.workflow_datetime = jobEvent.workflow_datetime as number;
    if (jobEvent.step_number) data.step_number = jobEvent.step_number as number;
    if (jobEvent.total_steps) data.total_steps = jobEvent.total_steps as number;
    if (jobEvent.current_step) data.current_step = jobEvent.current_step as number;

    // Job submission events
    if (event.type === 'job_submitted') {
      data.job_status = JobStatus.PENDING;
      data.priority = jobEvent.priority as number;
      data.payload = jobEvent.payload;
      data.requirements = jobEvent.requirements;
      data.customer_id = jobEvent.customer_id as string;
      data.submitted_at = jobEvent.created_at || jobEvent.timestamp;
    }

    // Status change events
    if (event.type === 'job_status_changed') {
      const statusEvent = event as JobStatusChangedEvent;
      data.job_status = statusEvent.new_status;
      data.old_status = statusEvent.old_status;
    }

    // Progress events
    if (event.type === 'update_job_progress') {
      const progressEvent = event as JobProgressEvent;
      data.progress = progressEvent.progress;
      // Note: stage is not available in JobProgressEvent, using optional property
      if ('stage' in progressEvent) {
        data.stage = (progressEvent as unknown as { stage: string }).stage;
      }
    }

    // Completion events
    if (event.type === 'complete_job') {
      const completeEvent = event as JobCompletedEvent;
      data.result = completeEvent.result;
      data.completed_at = completeEvent.completed_at;
    }

    // Failure events
    if (event.type === 'job_failed') {
      const failEvent = event as JobFailedEvent;
      data.error = failEvent.error;
      data.failed_at = failEvent.failed_at;
    }

    return data;
  }

  /**
   * Queue webhook delivery
   */
  private queueDelivery(payload: WebhookPayload): void {
    this.deliveryQueue.push(payload);
    logger.debug(`Webhook queued for delivery: ${payload.webhook_id}`, {
      event_type: payload.event_type,
      job_id: payload.data.job_id,
    });
  }

  /**
   * Start processing delivery queue
   */
  private startProcessing(): void {
    this.processingInterval = setInterval(() => {
      this.processDeliveryQueue();
    }, 1000); // Process every second
  }

  /**
   * Process webhook delivery queue
   */
  private async processDeliveryQueue(): Promise<void> {
    if (this.isProcessing || this.deliveryQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      const payload = this.deliveryQueue.shift();
      if (!payload) return;
      await this.deliverWebhook(payload);
    } catch (error) {
      logger.error('Error processing webhook delivery queue', error);
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Deliver webhook with retry logic
   */
  private async deliverWebhook(payload: WebhookPayload, attemptNumber = 1): Promise<void> {
    const webhook = await this.getWebhook(payload.webhook_id);
    if (!webhook) {
      logger.warn(`Webhook not found for delivery: ${payload.webhook_id}`);
      return;
    }

    // DEBUG: Log webhook delivery attempt
    logger.info(`üöÄ [WEBHOOK DEBUG] Sending webhook`, {
      webhook_id: webhook.id,
      webhook_url: webhook.url,
      event_type: payload.event_type,
      event_id: payload.event_id,
      attempt_number: attemptNumber,
      job_id: payload.data?.job_id,
      workflow_id: payload.data?.workflow_id,
      payload_summary: {
        type: payload.event_type,
        timestamp: payload.timestamp,
        data_keys: Object.keys(payload.data || {}),
      },
    });

    const attempt: WebhookDeliveryAttempt = {
      id: this.generateId(),
      webhook_id: webhook.id,
      event_id: payload.event_id,
      event_type: payload.event_type,
      attempt_number: attemptNumber,
      timestamp: Date.now(),
      success: false,
    };

    try {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'User-Agent': 'EMP-Job-Queue-Webhook/1.0',
        'X-Webhook-Event': payload.event_type,
        'X-Webhook-ID': webhook.id,
        'X-Event-ID': payload.event_id,
        ...webhook.headers,
      };

      // Add HMAC signature if secret is configured
      if (webhook.secret) {
        const signature = await this.generateHmacSignature(payload, webhook.secret);
        headers['X-Webhook-Signature'] = signature;
      }

      // Use AbortController for timeout with native fetch
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      const response = await fetch(webhook.url, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      attempt.response_status = response.status;
      attempt.response_body = await response.text();
      attempt.success = response.ok;

      if (response.ok) {
        logger.info(`Webhook delivered successfully: ${webhook.id}`, {
          event_type: payload.event_type,
          job_id: payload.data.job_id,
          status: response.status,
        });
        this.emit('webhook.delivered', { webhook, payload, attempt });
      } else {
        throw new Error(`HTTP ${response.status}: ${attempt.response_body}`);
      }
    } catch (error) {
      attempt.error_message = error instanceof Error ? error.message : String(error);

      logger.warn(`Webhook delivery failed: ${webhook.id} (attempt ${attemptNumber})`, {
        error: attempt.error_message,
        event_type: payload.event_type,
        job_id: payload.data.job_id,
      });

      // Retry logic
      const retryConfig = webhook.retry_config || {
        max_attempts: 3,
        initial_delay_ms: 1000,
        backoff_multiplier: 2,
        max_delay_ms: 30000,
      };
      if (attemptNumber < retryConfig.max_attempts) {
        const delay = Math.min(
          retryConfig.initial_delay_ms *
            Math.pow(retryConfig.backoff_multiplier, attemptNumber - 1),
          retryConfig.max_delay_ms
        );

        attempt.next_retry_at = Date.now() + delay;
        this.retryQueue.set(attempt.id, attempt);

        setTimeout(() => {
          this.retryQueue.delete(attempt.id);
          void this.deliverWebhook(payload, attemptNumber + 1);
        }, delay);

        logger.info(`Webhook retry scheduled: ${webhook.id} in ${delay}ms`, {
          attempt: attemptNumber + 1,
          max_attempts: retryConfig.max_attempts,
        });
      } else {
        logger.error(`Webhook delivery failed permanently: ${webhook.id}`, {
          attempts: attemptNumber,
          error: attempt.error_message,
        });
        this.emit('webhook.failed', { webhook, payload, attempt });
      }
    }

    // Record attempt in Redis
    await this.webhookStorage.recordDeliveryAttempt(attempt);
    this.emit('webhook.attempt', { webhook, payload, attempt });
  }

  /**
   * Generate HMAC signature for webhook payload
   */
  private async generateHmacSignature(payload: WebhookPayload, secret: string): Promise<string> {
    const crypto = await import('crypto');
    const body = JSON.stringify(payload);
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(body);
    return `sha256=${hmac.digest('hex')}`;
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `wh_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get webhook delivery statistics
   */
  async getDeliveryStats(webhookId?: string): Promise<{
    total_deliveries: number;
    successful_deliveries: number;
    failed_deliveries: number;
    retry_queue_size: number;
    pending_deliveries: number;
    last_delivery_at?: number;
    last_success_at?: number;
    last_failure_at?: number;
  }> {
    if (webhookId) {
      const stats = await this.webhookStorage.getWebhookStats(webhookId);
      return {
        total_deliveries: stats?.total_deliveries || 0,
        successful_deliveries: stats?.successful_deliveries || 0,
        failed_deliveries: stats?.failed_deliveries || 0,
        retry_queue_size: this.retryQueue.size,
        pending_deliveries: this.deliveryQueue.length,
        last_delivery_at: stats?.last_delivery_at,
        last_success_at: stats?.last_success_at,
        last_failure_at: stats?.last_failure_at,
      };
    } else {
      // Return aggregate stats
      return {
        total_deliveries: 0,
        successful_deliveries: 0,
        failed_deliveries: 0,
        retry_queue_size: this.retryQueue.size,
        pending_deliveries: this.deliveryQueue.length,
      };
    }
  }

  /**
   * Test webhook endpoint
   */
  async testWebhook(webhookId: string): Promise<boolean> {
    const webhook = await this.getWebhook(webhookId);
    if (!webhook) {
      throw new Error(`Webhook not found: ${webhookId}`);
    }

    const baseEventId = 'test_wh_' + Date.now() + '_' + this.generateId().slice(-9);
    const timestamp = Date.now();
    let allTestsSucceeded = true;

    // Send a test event for each event type the webhook is subscribed to
    for (const eventType of webhook.events) {
      const testPayload = this.createTestPayloadForEventType(
        eventType,
        baseEventId,
        webhookId,
        timestamp
      );

      try {
        await this.deliverWebhook(testPayload);
        logger.debug(`Test event sent successfully: ${eventType}`, { webhook_id: webhookId });
      } catch (error) {
        logger.error(`Test event failed: ${eventType}`, { webhook_id: webhookId, error });
        allTestsSucceeded = false;
      }
    }

    return allTestsSucceeded;
  }

  private createTestPayloadForEventType(
    eventType: string,
    baseEventId: string,
    webhookId: string,
    timestamp: number
  ): WebhookPayload {
    const testJobId = 'test_job_' + Date.now();
    const testWorkerId = 'test_worker_' + Math.random().toString(36).substr(2, 5);

    const basePayload = {
      event_id: `${baseEventId}_${eventType}`,
      timestamp,
      webhook_id: webhookId,
      metadata: {
        original_timestamp: timestamp,
        test_event: true,
      },
    };

    switch (eventType) {
      case 'job_submitted':
        return {
          ...basePayload,
          event_type: 'job_submitted',
          data: {
            job_id: testJobId,
            job_type: 'comfyui',
            priority: 100,
            payload: {
              test_data: 'Sample job submission for webhook testing',
              workflow: 'test_workflow.json',
            },
            requirements: {
              hardware: { gpu_memory_gb: 8 },
              models: ['test_model.safetensors'],
            },
            customer_id: 'test_customer_123',
            submitted_at: new Date(timestamp).toISOString(),
            status: 'pending',
          },
        };

      case 'update_job_progress':
        return {
          ...basePayload,
          event_type: 'update_job_progress',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            progress: 45,
            progress_message: 'Processing test workflow...',
            status: 'in_progress',
            current_step: 3,
            total_steps: 5,
            estimated_completion: new Date(timestamp + 60000).toISOString(),
          },
        };

      case 'complete_job':
        return {
          ...basePayload,
          event_type: 'complete_job',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            progress: 100,
            result: {
              output: 'Test job completed successfully',
              files: ['test_output.png'],
              duration_ms: 5000,
            },
            completed_at: new Date(timestamp).toISOString(),
            status: 'completed',
            message: 'Test job finished successfully',
          },
        };

      case 'job_failed':
        return {
          ...basePayload,
          event_type: 'job_failed',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            error: 'Test failure: Connection timeout during processing',
            failed_at: new Date(timestamp).toISOString(),
            status: 'failed',
            can_retry: false,
            retry_count: 3,
          },
        };

      case 'cancel_job':
        return {
          ...basePayload,
          event_type: 'cancel_job',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            cancelled_at: new Date(timestamp).toISOString(),
            reason: 'Test cancellation: User requested stop',
            cancelled_by: 'test_user',
          },
        };

      case 'worker_status':
        return {
          ...basePayload,
          event_type: 'worker_status',
          data: {
            worker_id: testWorkerId,
            machine_id: 'test_machine_' + Math.random().toString(36).substr(2, 5),
            status: 'busy',
            previous_status: 'idle',
            capabilities: ['comfyui', 'simulation'],
            current_job_id: testJobId,
          },
        };

      case 'machine_status':
        return {
          ...basePayload,
          event_type: 'machine_status',
          data: {
            machine_id: 'test_machine_' + Math.random().toString(36).substr(2, 5),
            status: 'ready',
            health: 'healthy',
            worker_count: 2,
            services: ['comfyui', 'simulation'],
            startup_time: 15000,
          },
        };

      default:
        // Fallback for unknown event types
        return {
          ...basePayload,
          event_type: eventType as WebhookEventType,
          data: {
            job_id: testJobId,
            test_event_type: eventType,
            message: `Test event for ${eventType}`,
          },
        };
    }
  }

  /**
   * Start periodic cache refresh from Redis
   */
  private startCacheRefresh(): void {
    this.refreshCache(); // Initial load
    this.cacheRefreshInterval = setInterval(() => {
      this.refreshCache();
    }, 30000); // Refresh every 30 seconds
  }

  /**
   * Refresh webhook cache from Redis
   */
  private async refreshCache(): Promise<void> {
    try {
      const activeWebhooks = await this.webhookStorage.getActiveWebhooks();

      // Clear and rebuild cache
      this.webhooksCache.clear();
      for (const webhook of activeWebhooks) {
        this.webhooksCache.set(webhook.id, webhook);
      }

      logger.debug(`Webhook cache refreshed: ${activeWebhooks.length} active webhooks`);
    } catch (error) {
      logger.error('Failed to refresh webhook cache:', error);
    }
  }

  /**
   * Get webhook storage instance (for direct access if needed)
   */
  getWebhookStorage(): WebhookRedisStorage {
    return this.webhookStorage;
  }

  /**
   * Get webhook delivery history
   */
  async getWebhookDeliveryHistory(webhookId: string, limit = 50) {
    return await this.webhookStorage.getWebhookDeliveryHistory(webhookId, limit);
  }

  /**
   * Get recent deliveries across all webhooks
   */
  async getRecentDeliveries(limit = 100) {
    return await this.webhookStorage.getRecentDeliveries(limit);
  }

  /**
   * Get webhook summary for dashboard
   */
  async getWebhookSummary() {
    return await this.webhookStorage.getWebhookSummary();
  }

  /**
   * Cleanup resources
   */
  destroy(): void {
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
    }
    if (this.cacheRefreshInterval) {
      clearInterval(this.cacheRefreshInterval);
    }
    if (this.throttleCleanupInterval) {
      clearInterval(this.throttleCleanupInterval);
    }
    this.webhooksCache.clear();
    this.deliveryQueue.length = 0;
    this.retryQueue.clear();
    this.lastProgressWebhookSent.clear(); // Clean up throttling map
    this.workflowTracker.clear(); // Clean up workflow tracking
  }
}
