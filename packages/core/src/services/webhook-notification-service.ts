/**
 * Webhook Notification Service
 *
 * Delivers HTTP webhook notifications for job status changes and other events.
 * Integrates with the existing EventBroadcaster system to send notifications
 * to external systems when jobs are submitted, progress updates, complete, fail, etc.
 */

import { EventEmitter } from 'events';
import { Redis } from 'ioredis';
import { logger } from '../utils/logger.js';
import { WebhookRedisStorage } from './webhook-redis-storage.js';
import {
  MonitorEvent,
  JobSubmittedEvent,
  JobStatusChangedEvent,
  JobProgressEvent,
  JobCompletedEvent,
  JobFailedEvent,
} from '../types/monitor-events.js';
import { JobStatus } from '../types/job.js';
import { sendTrace } from '../telemetry/otel-client.js';

// Webhook configuration types
export interface WebhookEndpoint {
  id: string;
  url: string;
  secret?: string; // For HMAC signature verification
  events: WebhookEventType[];
  filters?: WebhookFilters;
  headers?: Record<string, string>;
  retry_config?: WebhookRetryConfig;
  active: boolean;
  disconnected?: boolean; // Set to true when 10+ consecutive failures occur
  consecutive_failures?: number; // Track consecutive failures for auto-disconnect
  last_failure_at?: number; // Timestamp of last failure
  last_success_at?: number; // Timestamp of last success
  created_at: number;
  updated_at: number;
}

export type WebhookEventType =
  | 'job_submitted' // Job submitted to queue (published by API)
  | 'update_job_progress' // Job progress updates (published by workers)
  | 'complete_job' // Job completed successfully (published by workers)
  | 'job_failed' // Job failed permanently (published by workers)
  | 'cancel_job' // Job cancelled (published by API)
  | 'worker_status' // Worker status changes
  | 'machine_status' // Machine status changes
  | 'workflow_completed' // Workflow completed (all steps finished) - generated by webhook service
  | 'workflow_submitted' // First job in workflow submitted - generated by webhook service
  | 'workflow_failed'; // Workflow failed (partial or complete failure) - generated by webhook service

export interface WebhookFilters {
  job_types?: string[]; // Filter by job type (e.g., ['comfyui', 'openai'])
  job_priorities?: number[]; // Filter by priority levels
  machine_ids?: string[]; // Filter by specific machines
  worker_ids?: string[]; // Filter by specific workers
  custom_filters?: Record<string, unknown>; // Custom filter criteria
}

export interface WebhookRetryConfig {
  max_attempts: number; // Default: 3
  initial_delay_ms: number; // Default: 1000 (1 second)
  backoff_multiplier: number; // Default: 2 (exponential backoff)
  max_delay_ms: number; // Default: 30000 (30 seconds)
}

export interface WebhookPayload {
  event_type: WebhookEventType;
  event_id: string;
  timestamp: number;
  webhook_id: string;
  data: WebhookEventData;
  metadata?: {
    retry_attempt?: number;
    original_timestamp?: number;
  };
  // OTEL trace context for webhook hierarchy
  parent_trace_context?: {
    trace_id?: string;
    span_id?: string;
  };
}

export interface WebhookEventData {
  job_id?: string;
  job_type?: string;
  job_status?: JobStatus;
  worker_id?: string;
  machine_id?: string;
  progress?: number;
  result?: unknown;
  error?: string;
  // Workflow fields - CRITICAL for workflow tracking
  workflow_id?: string;
  workflow_priority?: number;
  workflow_datetime?: number;
  total_steps?: number;
  current_step?: number;
  [key: string]: unknown;
}

export interface WebhookDeliveryAttempt {
  id: string;
  webhook_id: string;
  event_id: string;
  event_type: string; // The type of webhook event (job_failed, workflow_completed, etc.)
  attempt_number: number;
  timestamp: number;
  success: boolean;
  response_status?: number;
  response_body?: string;
  error_message?: string;
  next_retry_at?: number;
}

export class WebhookNotificationService extends EventEmitter {
  private webhookStorage: WebhookRedisStorage;
  private webhooksCache: Map<string, WebhookEndpoint> = new Map();
  private deliveryQueue: WebhookPayload[] = [];
  private retryQueue: Map<string, WebhookDeliveryAttempt> = new Map();
  private isProcessing = false;
  private processingInterval?: NodeJS.Timeout;
  private cacheRefreshInterval?: NodeJS.Timeout;
  private throttleCleanupInterval?: NodeJS.Timeout;
  private empropsApiUrl: string;
  private empropsApiKey?: string;
  private telemetryClient: any | null;

  // Auto-disconnect configuration
  private static readonly MAX_CONSECUTIVE_FAILURES = 10;
  private static readonly AUTO_RECONNECT_DELAY_MS = 5 * 60 * 1000; // 5 minutes

  // Throttling: Track last progress webhook sent per job (1 per second max)
  private lastProgressWebhookSent: Map<string, number> = new Map();
  private readonly PROGRESS_THROTTLE_MS = 1000; // 1 second

  // Workflow tracking for completion detection (independent of subscriptions)
  private workflowTracker = new Map<
    string,
    {
      steps: Map<number, string>; // current_step -> job_id mapping
      completedSteps: Set<number>; // completed step numbers (1-indexed)
      failedSteps: Set<number>; // failed step numbers (1-indexed)
      stepErrors: Map<number, string>; // current_step -> error message for failed steps
      totalSteps?: number; // total steps in workflow (from job submission)
      startTime: number;
      lastUpdate: number;
      currentStep?: number; // highest current_step seen
    }
  >();

  constructor(redis: Redis, telemetryClient?: any) {
    super();
    this.webhookStorage = new WebhookRedisStorage(redis);
    this.telemetryClient = telemetryClient || null;
    
    // REQUIRED: EMPROPS_API_URL must be explicitly set
    if (!process.env.EMPROPS_API_URL) {
      throw new Error('EMPROPS_API_URL environment variable is required for webhook notification service');
    }
    this.empropsApiUrl = process.env.EMPROPS_API_URL;
    
    // Optional: EMPROPS_API_KEY for authenticated endpoints
    this.empropsApiKey = process.env.EMPROPS_API_KEY;
    if (!this.empropsApiKey) {
      logger.warn('‚ö†Ô∏è [WEBHOOK] EMPROPS_API_KEY not set - API calls may fail if authentication is required');
    }
    
    this.startProcessing();
    this.startCacheRefresh();
    this.startThrottleCleanup();
  }

  /**
   * Track successful webhook delivery and reset failure count
   */
  private async recordWebhookSuccess(webhookId: string): Promise<void> {
    const webhook = await this.getWebhook(webhookId);
    if (!webhook) return;

    const updates: Partial<WebhookEndpoint> = {
      consecutive_failures: 0,
      last_success_at: Date.now(),
      updated_at: Date.now(),
    };

    // Re-enable webhook if it was disconnected
    if (webhook.disconnected) {
      updates.disconnected = false;
      logger.info(`üîå Webhook reconnected after successful delivery: ${webhookId}`, {
        url: webhook.url,
        previous_failures: webhook.consecutive_failures || 0,
      });

      // Send OTEL event for webhook reconnection
      if (this.telemetryClient) {
        await this.telemetryClient.otel.counter('webhook.status.reconnected', 1, {
          webhook_id: webhookId,
          previous_failures: (webhook.consecutive_failures || 0).toString(),
        });
      }
    }

    await this.updateWebhook(webhookId, updates);
  }

  /**
   * Track webhook delivery failure and auto-disconnect if threshold reached
   */
  private async recordWebhookFailure(webhookId: string): Promise<void> {
    const webhook = await this.getWebhook(webhookId);
    if (!webhook) return;

    const consecutiveFailures = (webhook.consecutive_failures || 0) + 1;
    const updates: Partial<WebhookEndpoint> = {
      consecutive_failures: consecutiveFailures,
      last_failure_at: Date.now(),
      updated_at: Date.now(),
    };

    // Auto-disconnect webhook if it hits the failure threshold
    if (consecutiveFailures >= WebhookNotificationService.MAX_CONSECUTIVE_FAILURES && !webhook.disconnected) {
      updates.disconnected = true;
      
      logger.warn(`üö® Webhook auto-disconnected due to ${consecutiveFailures} consecutive failures: ${webhookId}`, {
        url: webhook.url,
        threshold: WebhookNotificationService.MAX_CONSECUTIVE_FAILURES,
      });

      // Send OTEL trace event for webhook auto-disconnect
      await sendTrace('webhook.status.disconnected', {
        webhook_id: webhookId,
        webhook_url: webhook.url,
        consecutive_failures: consecutiveFailures.toString(),
        threshold: WebhookNotificationService.MAX_CONSECUTIVE_FAILURES.toString(),
        disconnect_reason: 'auto_disconnect_on_failures',
        disconnect_type: 'automatic',
        user_agent: 'emp-webhook-service',
      }, {
        duration_ms: 1,
        status: 'ok',
      });

      // Send OTEL counter for webhook auto-disconnect
      if (this.telemetryClient) {
        await this.telemetryClient.otel.counter('webhook.status.disconnected', 1, {
          webhook_id: webhookId,
          consecutive_failures: consecutiveFailures.toString(),
          threshold: WebhookNotificationService.MAX_CONSECUTIVE_FAILURES.toString(),
        });
      }

      // Emit event for external monitoring
      this.emit('webhook.disconnected', {
        webhook,
        consecutive_failures: consecutiveFailures,
        threshold: WebhookNotificationService.MAX_CONSECUTIVE_FAILURES,
      });
    }

    await this.updateWebhook(webhookId, updates);
  }

  /**
   * Check if webhook should be skipped due to disconnected state
   */
  private shouldSkipDisconnectedWebhook(webhook: WebhookEndpoint): boolean {
    if (!webhook.disconnected) return false;

    // Allow reconnection attempt after delay
    const lastFailure = webhook.last_failure_at || 0;
    const timeSinceLastFailure = Date.now() - lastFailure;
    
    if (timeSinceLastFailure >= WebhookNotificationService.AUTO_RECONNECT_DELAY_MS) {
      logger.info(`üîÑ Attempting to reconnect disconnected webhook: ${webhook.id}`, {
        url: webhook.url,
        minutes_since_last_failure: Math.round(timeSinceLastFailure / (60 * 1000)),
      });
      return false; // Allow delivery attempt
    }

    return true; // Skip delivery
  }

  /**
   * Manually reconnect a disconnected webhook
   */
  async reconnectWebhook(webhookId: string): Promise<boolean> {
    const webhook = await this.getWebhook(webhookId);
    if (!webhook) {
      logger.warn(`Cannot reconnect webhook: ${webhookId} not found`);
      return false;
    }

    if (!webhook.disconnected) {
      logger.info(`Webhook ${webhookId} is not disconnected, no action needed`);
      return true;
    }

    const updates: Partial<WebhookEndpoint> = {
      disconnected: false,
      consecutive_failures: 0,
      updated_at: Date.now(),
    };

    await this.updateWebhook(webhookId, updates);
    
    logger.info(`üîå Webhook manually reconnected: ${webhookId}`, {
      url: webhook.url,
      previous_failures: webhook.consecutive_failures || 0,
    });

    // Send OTEL event for manual reconnection
    if (this.telemetryClient) {
      await this.telemetryClient.otel.counter('webhook.status.manual_reconnect', 1, {
        webhook_id: webhookId,
        previous_failures: (webhook.consecutive_failures || 0).toString(),
      });
    }

    return true;
  }

  /**
   * Register a new webhook endpoint
   */
  async registerWebhook(
    config: Omit<WebhookEndpoint, 'id' | 'created_at' | 'updated_at'>
  ): Promise<WebhookEndpoint> {
    const webhook: WebhookEndpoint = {
      id: this.generateId(),
      created_at: Date.now(),
      updated_at: Date.now(),
      consecutive_failures: 0,
      disconnected: false,
      retry_config: {
        max_attempts: 3,
        initial_delay_ms: 1000,
        backoff_multiplier: 2,
        max_delay_ms: 30000,
        ...config.retry_config,
      },
      ...config,
    };

    await this.webhookStorage.storeWebhook(webhook);
    this.webhooksCache.set(webhook.id, webhook);

    logger.info(`Webhook registered: ${webhook.id} -> ${webhook.url}`, {
      webhook_id: webhook.id,
      events: webhook.events,
      filters: webhook.filters,
    });

    return webhook;
  }

  /**
   * Update an existing webhook
   */
  async updateWebhook(
    id: string,
    updates: Partial<WebhookEndpoint>
  ): Promise<WebhookEndpoint | null> {
    const updatedWebhook = await this.webhookStorage.updateWebhook(id, updates);
    if (updatedWebhook) {
      this.webhooksCache.set(id, updatedWebhook);
      logger.info(`Webhook updated: ${id}`, { updates });
    }
    return updatedWebhook;
  }

  /**
   * Delete a webhook
   */
  async deleteWebhook(id: string): Promise<boolean> {
    const deleted = await this.webhookStorage.deleteWebhook(id);
    if (deleted) {
      this.webhooksCache.delete(id);
      logger.info(`Webhook deleted: ${id}`);
    }
    return deleted;
  }

  /**
   * Get all webhooks
   */
  async getWebhooks(): Promise<WebhookEndpoint[]> {
    return await this.webhookStorage.getAllWebhooks();
  }

  /**
   * Get a specific webhook
   */
  async getWebhook(id: string): Promise<WebhookEndpoint | null> {
    // Try cache first
    const cached = this.webhooksCache.get(id);
    if (cached) {
      return cached;
    }

    // Fallback to Redis
    const webhook = await this.webhookStorage.getWebhook(id);
    if (webhook) {
      this.webhooksCache.set(id, webhook);
    }
    return webhook;
  }

  /**
   * Process monitor events and trigger webhooks
   */
  async processEvent(event: MonitorEvent): Promise<void> {
    // DEBUG: Log event processing (skip progress updates to reduce noise)
    if (event.type !== 'update_job_progress') {
      logger.info(`üì• [WEBHOOK DEBUG] Processing event for webhooks`, {
        event_type: event.type,
        job_id: (event as any).job_id,
        workflow_id: (event as any).workflow_id,
        timestamp: event.timestamp,
      });
    }

    const webhookEvent = this.convertMonitorEventToWebhookEvent(event);
    if (!webhookEvent) {
      logger.debug(`üì§ [WEBHOOK DEBUG] Event not supported for webhooks: ${event.type}`);
      return; // Event not supported for webhooks
    }

    // Note: Workflow tracking is now handled by API server with EMPROPS verification
    // The old internal workflow tracking logic has been disabled to prevent duplicate webhooks
    // await this.processWorkflowTracking(event, webhookEvent);

    // THROTTLING: Check if this is a progress update and if we should throttle it
    if (webhookEvent === 'update_job_progress') {
      const jobId = (event as any).job_id as string;
      if (jobId && this.shouldThrottleProgressWebhook(jobId)) {
        logger.debug(
          `‚è±Ô∏è [WEBHOOK DEBUG] Throttling progress webhook for job ${jobId} (< 1 second since last)`
        );
        return;
      }
    }

    // Find matching webhooks for THIS specific event (only send if explicitly subscribed)
    const matchingWebhooks = this.findMatchingWebhooks(webhookEvent, event);

    // Only log for non-progress events to reduce noise
    if (event.type !== 'update_job_progress') {
      logger.info(
        `üéØ [WEBHOOK DEBUG] Found ${matchingWebhooks.length} matching webhooks for ${event.type}`
      );
    }

    for (const webhook of matchingWebhooks) {
      const payload = this.createWebhookPayload(webhook, webhookEvent, event);

      // Only log for non-progress events to reduce noise
      if (event.type !== 'update_job_progress') {
        logger.info(`üìã [WEBHOOK DEBUG] Queueing webhook delivery`, {
          webhook_id: webhook.id,
          webhook_url: webhook.url,
          event_type: webhookEvent,
          job_id: (event as any).job_id,
          workflow_id: (event as any).workflow_id,
        });
      }

      this.queueDelivery(payload);
    }
  }

  /**
   * Process workflow tracking for completion detection (independent of subscriptions)
   */
  private async processWorkflowTracking(
    event: MonitorEvent,
    webhookEventType: WebhookEventType
  ): Promise<void> {
    const jobEvent = event as unknown as Record<string, unknown>;
    const workflowId = jobEvent.workflow_id as string;
    const jobId = jobEvent.job_id as string;
    const currentStep = jobEvent.current_step as number;
    const stepNumber = jobEvent.current_step as number;
    const totalSteps = jobEvent.total_steps as number;

    // DEBUG: Log extracted data for workflow events
    if (workflowId) {
      logger.info('üìã [WORKFLOW TRACKING] Processing workflow event', {
        eventType: webhookEventType,
        workflowId,
        jobId,
        currentStep,
        stepNumber,
        totalSteps,
        rawEvent: {
          type: event.type,
          workflow_id: jobEvent.workflow_id,
          job_id: jobEvent.job_id,
          current_step: jobEvent.current_step,
          total_steps: jobEvent.total_steps,
        },
      });
    }

    // Only track workflow events
    if (!workflowId || !jobId) {
      return;
    }

    const now = Date.now();
    let workflow = this.workflowTracker.get(workflowId);

    // Initialize workflow tracking if not exists
    if (!workflow) {
      workflow = {
        steps: new Map(),
        completedSteps: new Set(),
        failedSteps: new Set(),
        stepErrors: new Map(),
        startTime: now,
        lastUpdate: now,
      };
      this.workflowTracker.set(workflowId, workflow);
      logger.debug('Started tracking workflow', { workflowId });
    }

    // Update workflow metadata
    workflow.lastUpdate = now;
    if (totalSteps && !workflow.totalSteps) {
      workflow.totalSteps = totalSteps;
      logger.debug('Set workflow total steps', { workflowId, totalSteps });
    }
    if (currentStep && (!workflow.currentStep || currentStep > workflow.currentStep)) {
      workflow.currentStep = currentStep;
    }

    // Track step in workflow
    const effectiveStepNumber = currentStep || stepNumber || 1;
    workflow.steps.set(effectiveStepNumber, jobId);

    // Note: workflow_submitted events are handled by the API server when workflows are first created
    // No need to duplicate that logic here

    // Handle completion/failure
    const wasCompleted = workflow.completedSteps.has(effectiveStepNumber);
    const wasFailed = workflow.failedSteps.has(effectiveStepNumber);

    if (webhookEventType === 'complete_job' && !wasCompleted) {
      workflow.completedSteps.add(effectiveStepNumber);
      workflow.failedSteps.delete(effectiveStepNumber);
      logger.info('üéØ [WORKFLOW COMPLETION] Step completed', {
        workflowId,
        jobId,
        stepNumber: effectiveStepNumber,
        completed: workflow.completedSteps.size,
        total: workflow.totalSteps || workflow.steps.size,
        allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
        completedSteps: Array.from(workflow.completedSteps),
        failedSteps: Array.from(workflow.failedSteps),
      });
    } else if (webhookEventType === 'job_failed' && !wasFailed) {
      workflow.failedSteps.add(effectiveStepNumber);
      workflow.completedSteps.delete(effectiveStepNumber);
      
      // Store the error message for this step
      const errorMessage = (event as any).error || 'Unknown error';
      workflow.stepErrors.set(effectiveStepNumber, errorMessage);
      logger.info('‚ùå [WORKFLOW COMPLETION] Step failed', {
        workflowId,
        jobId,
        stepNumber: effectiveStepNumber,
        failed: workflow.failedSteps.size,
        total: workflow.totalSteps || workflow.steps.size,
        allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
        completedSteps: Array.from(workflow.completedSteps),
        failedSteps: Array.from(workflow.failedSteps),
      });
    } else if (webhookEventType === 'complete_job' && wasCompleted) {
      logger.debug('üîÑ [WORKFLOW COMPLETION] Step already completed, skipping', {
        workflowId,
        jobId,
        stepNumber: effectiveStepNumber,
      });
    }

    // ‚ùå DISABLED: Internal workflow completion check has been disabled
    // Workflow completion is now handled exclusively by the API server with EMPROPS verification
    // await this.checkWorkflowCompletion(workflowId, workflow, event);
  }

  /**
   * Send workflow events to subscribed webhooks
   */
  private async sendWorkflowEvent(
    eventType: 'workflow_submitted' | 'workflow_completed' | 'workflow_failed',
    workflowId: string,
    triggeringEvent: MonitorEvent
  ): Promise<void> {
    const workflowEvent = await this.createWorkflowEvent(eventType, workflowId, triggeringEvent);

    // Find webhooks subscribed to this workflow event type
    const matchingWebhooks = this.findMatchingWebhooksForEventType(eventType);

    logger.info(`üéØ [WORKFLOW] Found ${matchingWebhooks.length} webhooks for ${eventType}`, {
      workflowId,
    });

    for (const webhook of matchingWebhooks) {
      const payload = {
        event_type: eventType,
        event_id: this.generateId(),
        timestamp: Date.now(),
        webhook_id: webhook.id,
        data: workflowEvent,
      };

      logger.info(`üìã [WORKFLOW] Queueing ${eventType} webhook`, {
        webhook_id: webhook.id,
        webhook_url: webhook.url,
        workflow_id: workflowId,
      });

      this.queueDelivery(payload);
    }
  }

  /**
   * Handle workflow completion with EMPROPS API confirmation and fallback
   */
  private async handleWorkflowCompletionWithEmpropsConfirmation(
    workflowId: string, 
    triggeringEvent: MonitorEvent
  ): Promise<void> {
    const maxRetries = 10;
    const retryDelayMs = 2000; // 2 seconds between retries
    let lastKnownStatus: string | null = null;
    
    logger.info('‚è≥ [WORKFLOW COMPLETION] Waiting for EMPROPS API to confirm workflow completion...');
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        logger.info(`üîç [WORKFLOW COMPLETION] Checking EMPROPS API (attempt ${attempt}/${maxRetries})`);
        
        const workflowDetails = await this.fetchWorkflowDetails(workflowId);
        const empStatus = workflowDetails?.data?.status;
        const hasOutputs = workflowDetails?.data?.data?.outputs && workflowDetails.data.data.outputs.length > 0;
        
        // Track the last known status
        if (empStatus) {
          lastKnownStatus = empStatus;
        }
        
        logger.info(`üìä [WORKFLOW COMPLETION] EMPROPS Status Check:`);
        logger.info(`   Status: ${empStatus}`);
        logger.info(`   Progress: ${workflowDetails?.data?.progress || 'unknown'}`);
        logger.info(`   Has Outputs: ${hasOutputs}`);
        
        if (empStatus === 'completed') {
          logger.info('‚úÖ [WORKFLOW COMPLETION] EMPROPS workflow confirmed complete, sending webhook with outputs');
          await this.sendWorkflowEvent('workflow_completed', workflowId, triggeringEvent);
          return;
        }
        
        if (attempt < maxRetries) {
          logger.info(`   ‚è≥ EMPROPS job still ${empStatus}, waiting ${retryDelayMs}ms before next check...`);
          await new Promise(resolve => setTimeout(resolve, retryDelayMs));
        }
        
      } catch (error) {
        // Handle 404 or other errors - could be direct workflow not tracked by EMPROPS
        if (error.message?.includes('404') || error.message?.includes('not found')) {
          logger.info('üîÑ [WORKFLOW COMPLETION] EMPROPS job not found (likely direct workflow), sending completion with available data');
          await this.sendWorkflowEvent('workflow_completed', workflowId, triggeringEvent);
          return;
        }
        
        // For other errors, log and continue retrying
        logger.warn(`‚ö†Ô∏è [WORKFLOW COMPLETION] Attempt ${attempt} failed:`, error.message);
        
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, retryDelayMs));
        }
      }
    }
    
    // FIXED: Check last known status before sending completion webhook
    if (lastKnownStatus === 'processing' || lastKnownStatus === 'pending') {
      logger.warn(`‚ùå [WEBHOOK-BUG-FIX] EMPROPS API still shows status '${lastKnownStatus}' after ${maxRetries} attempts. NOT sending premature completion webhook.`);
      logger.warn(`   üîß This prevents sending 'workflow complete' webhooks for jobs still in progress.`);
      return; // Do NOT send completion webhook for jobs still processing
    }
    
    // Only send fallback completion if status was unknown/unreachable or already completed
    logger.warn(`‚ö†Ô∏è [WORKFLOW COMPLETION] EMPROPS API never confirmed completion after ${maxRetries} attempts (last status: ${lastKnownStatus}), sending webhook anyway`);
    await this.sendWorkflowEvent('workflow_completed', workflowId, triggeringEvent);
  }

  /**
   * Fetch workflow details from EMPROPS API
   */
  private async fetchWorkflowDetails(workflowId: string): Promise<any> {
    const url = `${this.empropsApiUrl}/jobs/${workflowId}`;
    let startTime: number;
    
    try {
      logger.info(`üîç [WEBHOOK] Making EMPROPS API Request:`);
      logger.info(`   URL: ${url}`);
      logger.info(`   Method: GET`);
      logger.info(`   Workflow ID: ${workflowId}`);
      
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };
      
      // Add authorization header if API key is available
      if (this.empropsApiKey) {
        headers['Authorization'] = `Bearer ${this.empropsApiKey}`;
        logger.info(`   Auth: Using Bearer token`);
      } else {
        logger.warn(`   Auth: No API key available`);
      }
      
      startTime = Date.now();
      
      // Send EMPROPS API call trace (start)
      const apiTraceResult = await sendTrace('webhook.emprops_api.call', {
        workflow_id: workflowId,
        endpoint: 'get_workflow_details',
        http_method: 'GET',
        api_url: url,
        status: 'started',
        user_agent: 'emp-webhook-service',
      }, {
        duration_ms: 1, // placeholder, will send completion trace
        status: 'ok',
      });
      
      const response = await fetch(url, {
        method: 'GET',
        headers,
        // 10 second timeout for API calls
        signal: AbortSignal.timeout(10000)
      });
      const responseTime = Date.now() - startTime;

      // Send EMPROPS API call completion trace
      await sendTrace('webhook.emprops_api.call', {
        workflow_id: workflowId,
        endpoint: 'get_workflow_details',
        http_method: 'GET',
        api_url: url,
        http_status: response.status.toString(),
        response_time_ms: responseTime.toString(),
        status: response.ok ? 'success' : 'http_error',
        user_agent: 'emp-webhook-service',
      }, {
        duration_ms: responseTime,
        status: response.ok ? 'ok' : 'error',
        parent_trace_id: apiTraceResult.traceId,
      });

      logger.info(`üì° [WEBHOOK] EMPROPS API Response:`);
      logger.info(`   Status: ${response.status} ${response.statusText}`);
      logger.info(`   Response Time: ${responseTime}ms`);
      logger.info(`   Headers: ${JSON.stringify(Object.fromEntries(response.headers.entries()))}`);

      if (!response.ok) {
        const errorBody = await response.text();
        logger.error(`‚ùå [WEBHOOK] EMPROPS API Error Response:`);
        logger.error(`   Status: ${response.status}`);
        logger.error(`   Body: ${errorBody}`);
        
        // Send OTEL event for HTTP error from EMPROPS API
        if (this.telemetryClient) {
          await this.telemetryClient.otel.counter('webhook.emprops_api.failure', 1, {
            workflow_id: workflowId,
            http_status: response.status.toString(),
            response_time_ms: responseTime.toString(),
            endpoint: 'get_workflow_details',
            error_type: 'HttpError',
            error_message: `HTTP ${response.status}: ${response.statusText}`,
          });
          
          await this.telemetryClient.otel.histogram('webhook.emprops_api.response_time', responseTime, {
            workflow_id: workflowId,
            status: 'error',
            endpoint: 'get_workflow_details',
          }, 'ms');
        }
        
        throw new Error(`EMPROPS API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      logger.info(`‚úÖ [WEBHOOK] Successfully fetched workflow details for ${workflowId}`);
      
      // Send OTEL event for successful EMPROPS API call
      if (this.telemetryClient) {
        await this.telemetryClient.otel.counter('webhook.emprops_api.success', 1, {
          workflow_id: workflowId,
          http_status: response.status.toString(),
          response_time_ms: responseTime.toString(),
          endpoint: 'get_workflow_details',
        });
        
        await this.telemetryClient.otel.histogram('webhook.emprops_api.response_time', responseTime, {
          workflow_id: workflowId,
          status: 'success',
          endpoint: 'get_workflow_details',
        }, 'ms');
      }
      
      // Log response summary (avoid verbose chunked logging that creates 50+ log entries)
      const responseSize = JSON.stringify(data).length;
      logger.info(`üìã [WEBHOOK] API Response received:`, {
        workflow_id: data?.data?.id,
        workflow_name: data?.data?.name,
        status: data?.data?.status, 
        job_type: data?.data?.job_type || 'N/A',
        has_outputs: !!data?.data?.data?.outputs,
        output_count: data?.data?.data?.outputs?.length || 0,
        response_size_bytes: responseSize
      });
      
      // Log first output if exists (CORRECT PATH: data.data.outputs)
      if (data?.data?.data?.outputs?.length > 0) {
        const firstOutput = data.data.data.outputs[0];
        logger.info(`   - First output ID: ${firstOutput?.id || 'unknown'}`);
        
        // Check for image outputs in steps
        if (firstOutput?.steps?.length > 0) {
          firstOutput.steps.forEach((step: any, index: number) => {
            if (step?.nodeResponse?.src) {
              logger.info(`   - Step ${index + 1} output: ${step.nodeName} - ${step.nodeResponse.src}`);
            }
          });
        }
      }
      
      return data;
    } catch (error) {
      const errorTime = Date.now() - startTime;
      
      // Send EMPROPS API error trace
      await sendTrace('webhook.emprops_api.call', {
        workflow_id: workflowId,
        endpoint: 'get_workflow_details',
        http_method: 'GET',
        api_url: url,
        response_time_ms: errorTime.toString(),
        status: 'error',
        error_type: error instanceof Error ? error.constructor.name : 'UnknownError',
        error_message: error instanceof Error ? error.message : String(error),
        user_agent: 'emp-webhook-service',
      }, {
        duration_ms: errorTime,
        status: 'error',
      });

      logger.error(`‚ùå [WEBHOOK] Failed to fetch workflow details for ${workflowId}:`, error);
      logger.error(`   Error Type: ${error.constructor.name}`);
      logger.error(`   Error Message: ${error.message}`);
      if (error.cause) {
        logger.error(`   Error Cause: ${error.cause}`);
      }
      
      // Send OTEL event for failed EMPROPS API call
      if (this.telemetryClient) {
        await this.telemetryClient.otel.counter('webhook.emprops_api.failure', 1, {
          workflow_id: workflowId,
          endpoint: 'get_workflow_details',
          error_type: error instanceof Error ? error.constructor.name : 'UnknownError',
          error_message: error instanceof Error ? error.message : String(error),
        });
      }
      
      return null;
    }
  }

  /**
   * Create workflow event data
   */
  private async createWorkflowEvent(
    eventType: string,
    workflowId: string,
    triggeringEvent: MonitorEvent
  ): Promise<Record<string, unknown>> {
    const jobEvent = triggeringEvent as unknown as Record<string, unknown>;
    const workflow = this.workflowTracker.get(workflowId);

    const baseEvent = {
      workflow_id: workflowId,
      timestamp: Date.now(),
      trigger_job_id: jobEvent.job_id,
      trigger_event_type: triggeringEvent.type,
    };

    if (eventType === 'workflow_submitted') {
      return {
        ...baseEvent,
        first_job_id: jobEvent.job_id,
        total_steps: jobEvent.total_steps,
        workflow_priority: jobEvent.workflow_priority,
        workflow_datetime: jobEvent.workflow_datetime,
        customer_id: jobEvent.customer_id,
        service_required: jobEvent.service_required,
      };
    }

    if (workflow && (eventType === 'workflow_completed' || eventType === 'workflow_failed')) {
      const isSuccess = eventType === 'workflow_completed';
      const duration = Date.now() - workflow.startTime;

      // Base workflow event data
      const workflowEventData: Record<string, unknown> = {
        ...baseEvent,
        success: isSuccess,
        total_steps: workflow.totalSteps,
        completed_steps: workflow.completedSteps.size,
        failed_steps: workflow.failedSteps.size,
        duration_ms: duration,
        start_time: workflow.startTime,
        end_time: Date.now(),
        current_step: jobEvent.current_step,
        step_details: Array.from(workflow.steps.entries()).map(([stepNum, stepJobId]) => {
          const hasError = workflow.stepErrors.has(stepNum);
          const errorMessage = workflow.stepErrors.get(stepNum);
          
          const stepDetail: {
            current_step: number;
            job_id: string;
            completed: boolean;
            failed: boolean;
            error?: string;
          } = {
            current_step: stepNum,
            job_id: stepJobId,
            completed: workflow.completedSteps.has(stepNum),
            failed: workflow.failedSteps.has(stepNum),
          };
          
          // Add error field if present
          if (hasError && errorMessage) {
            stepDetail.error = errorMessage;
          }
          
          return stepDetail;
        }),
      };

      // For completed workflows, use Redis event data (already fetched from EMPROPS by API server)
      if (isSuccess) {
        const triggeringEventAny = triggeringEvent as any;
        
        // Check if the Redis event already contains workflow outputs and details
        if (triggeringEventAny.outputs && Array.isArray(triggeringEventAny.outputs)) {
          workflowEventData.outputs = triggeringEventAny.outputs;
          logger.info(`‚úÖ [WEBHOOK] Using workflow outputs from Redis event: ${triggeringEventAny.outputs.length} outputs`);
          
          // Log the actual image URLs we're sending
          triggeringEventAny.outputs.forEach((output: any, index: number) => {
            if (output.steps) {
              output.steps.forEach((step: any) => {
                if (step?.nodeResponse?.src) {
                  logger.info(`   üñºÔ∏è Output ${index + 1} - ${step.nodeName}: ${step.nodeResponse.src}`);
                }
              });
            }
          });
          
          logger.info(`üì§ [WEBHOOK] Final payload size: ${JSON.stringify(workflowEventData).length} bytes`);
        } else if (triggeringEventAny.workflow_details) {
          // Fallback: try to extract from workflow_details
          logger.info(`üîç [WEBHOOK] Using workflow details from Redis event for ${workflowId}`);
          workflowEventData.workflow_details = triggeringEventAny.workflow_details;
          
          if (triggeringEventAny.workflow_details.outputs) {
            workflowEventData.outputs = triggeringEventAny.workflow_details.outputs;
            logger.info(`   ‚úÖ Extracted ${triggeringEventAny.workflow_details.outputs.length} outputs from workflow details`);
          }
        } else {
          logger.info(`‚ö†Ô∏è [WEBHOOK] No outputs found in Redis event data, sending basic workflow completion`);
        }
      }

      return workflowEventData;
    }

    return baseEvent;
  }

  /**
   * Find webhooks matching a specific event type
   */
  private findMatchingWebhooksForEventType(eventType: WebhookEventType): WebhookEndpoint[] {
    const allWebhooks = Array.from(this.webhooksCache.values());
    return allWebhooks.filter(webhook => 
      webhook.active && 
      webhook.events.includes(eventType) &&
      !this.shouldSkipDisconnectedWebhook(webhook)
    );
  }

  /**
   * Check for workflow completion
   */
  private async checkWorkflowCompletion(
    workflowId: string,
    workflow: NonNullable<ReturnType<typeof this.workflowTracker.get>>,
    triggeringEvent: MonitorEvent
  ): Promise<void> {
    const totalSteps = workflow.totalSteps;
    const completedSteps = workflow.completedSteps.size;
    const failedSteps = workflow.failedSteps.size;
    const finishedSteps = completedSteps + failedSteps;

    logger.info('üîç [WORKFLOW COMPLETION] Checking completion status', {
      workflowId,
      totalSteps: totalSteps || 'unknown',
      completedSteps,
      failedSteps,
      finishedSteps,
      allSteps: Array.from(workflow.steps.entries()).map(([step, job]) => `${step}:${job}`),
      completedStepsList: Array.from(workflow.completedSteps),
      failedStepsList: Array.from(workflow.failedSteps),
    });

    if (!totalSteps) {
      logger.debug('Workflow total steps unknown, deferring completion check', { workflowId });
      return;
    }

    if (finishedSteps === totalSteps && totalSteps > 0) {
      const isSuccess = failedSteps === 0;
      const eventType = isSuccess ? 'workflow_completed' : 'workflow_failed';

      logger.info('üéâ [WORKFLOW COMPLETION] Job queue steps finished!', {
        workflowId,
        totalSteps,
        completedSteps,
        failedSteps,
        success: isSuccess,
        eventType,
      });

      // For successful workflows, wait for EMPROPS API confirmation with fallback
      if (isSuccess) {
        await this.handleWorkflowCompletionWithEmpropsConfirmation(workflowId, triggeringEvent);
      } else {
        // For failed workflows, send immediately
        logger.info('‚ùå [WORKFLOW COMPLETION] Workflow failed, sending failure event immediately');
        await this.sendWorkflowEvent(eventType, workflowId, triggeringEvent);
      }

      // Clean up workflow tracking
      this.workflowTracker.delete(workflowId);
      logger.debug('Cleaned up workflow tracking', { workflowId });
    } else {
      logger.debug('üöß [WORKFLOW COMPLETION] Workflow not yet complete', {
        workflowId,
        finishedSteps,
        totalSteps,
        stillNeed: totalSteps - finishedSteps,
      });
    }
  }

  /**
   * Check if progress webhook should be throttled for this job
   */
  private shouldThrottleProgressWebhook(jobId: string): boolean {
    const now = Date.now();
    const lastSent = this.lastProgressWebhookSent.get(jobId);

    if (!lastSent || now - lastSent >= this.PROGRESS_THROTTLE_MS) {
      // Update the timestamp and allow the webhook
      this.lastProgressWebhookSent.set(jobId, now);
      return false; // Don't throttle
    }

    return true; // Throttle this webhook
  }

  /**
   * Start periodic cleanup of throttling map to prevent memory leaks
   */
  private startThrottleCleanup(): void {
    // Clean up throttling entries older than 5 minutes every minute
    this.throttleCleanupInterval = setInterval(() => {
      const now = Date.now();
      const staleThreshold = 5 * 60 * 1000; // 5 minutes
      let cleaned = 0;

      for (const [jobId, timestamp] of this.lastProgressWebhookSent.entries()) {
        if (now - timestamp > staleThreshold) {
          this.lastProgressWebhookSent.delete(jobId);
          cleaned++;
        }
      }

      if (cleaned > 0) {
        logger.debug(`Cleaned up ${cleaned} stale throttling entries`, {
          remaining: this.lastProgressWebhookSent.size,
        });
      }
    }, 60 * 1000); // Run every minute
  }

  /**
   * Convert monitor event to webhook event type
   */
  private convertMonitorEventToWebhookEvent(event: MonitorEvent): WebhookEventType | null {
    switch (event.type) {
      case 'job_submitted':
        return 'job_submitted';
      case 'update_job_progress':
        return 'update_job_progress';
      case 'complete_job':
        return 'complete_job';
      case 'job_failed':
        return 'job_failed';
      case 'worker_connected':
      case 'worker_disconnected':
        return 'worker_status';
      case 'machine_startup_complete':
      case 'machine_shutdown':
        return 'machine_status';
      case 'system_stats':
        // Check if this is actually a workflow event disguised as system_stats
        const eventAny = event as any;
        if (eventAny.workflow_submitted) {
          return 'workflow_submitted';
        }
        if (eventAny.workflow_completed) {
          return 'workflow_completed';
        }
        if (eventAny.workflow_failed) {
          return 'workflow_failed';
        }
        return null; // Regular system_stats events don't trigger webhooks
      default:
        return null;
    }
  }

  /**
   * Find webhooks that match the event and filters
   */
  private findMatchingWebhooks(
    webhookEventType: WebhookEventType,
    event: MonitorEvent
  ): WebhookEndpoint[] {
    return Array.from(this.webhooksCache.values()).filter(webhook => {
      // Must be active
      if (!webhook.active) {
        return false;
      }

      // Must subscribe to this event type
      if (!webhook.events.includes(webhookEventType)) {
        return false;
      }

      // Skip disconnected webhooks unless they're ready for reconnection
      if (this.shouldSkipDisconnectedWebhook(webhook)) {
        return false;
      }

      // Apply filters
      if (webhook.filters) {
        return this.eventMatchesFilters(event, webhook.filters);
      }

      return true;
    });
  }

  /**
   * Check if event matches webhook filters
   */
  private eventMatchesFilters(event: MonitorEvent, filters: WebhookFilters): boolean {
    // Job type filter
    if (filters.job_types) {
      const jobEvent = event as JobSubmittedEvent | JobStatusChangedEvent;
      if ('job_id' in jobEvent && 'job_data' in jobEvent) {
        const jobData = jobEvent.job_data as { job_type?: string };
        if (!filters.job_types.includes(jobData.job_type || '')) {
          return false;
        }
      }
    }

    // Machine ID filter
    if (filters.machine_ids) {
      const machineEvent = event as unknown as Record<string, unknown>;
      if (
        machineEvent.machine_id &&
        !filters.machine_ids.includes(machineEvent.machine_id as string)
      ) {
        return false;
      }
    }

    // Worker ID filter
    if (filters.worker_ids) {
      const workerEvent = event as unknown as Record<string, unknown>;
      if (workerEvent.worker_id && !filters.worker_ids.includes(workerEvent.worker_id as string)) {
        return false;
      }
    }

    // Priority filter
    if (filters.job_priorities) {
      const jobEvent = event as unknown as Record<string, unknown>;
      if (
        jobEvent.priority !== undefined &&
        !filters.job_priorities.includes(jobEvent.priority as number)
      ) {
        return false;
      }
    }

    return true;
  }

  /**
   * Create webhook payload from event
   */
  private createWebhookPayload(
    webhook: WebhookEndpoint,
    eventType: WebhookEventType,
    event: MonitorEvent
  ): WebhookPayload {
    const eventData = this.extractEventData(event);

    // Extract trace context for webhook hierarchy (especially from job completion)
    const jobEvent = event as unknown as Record<string, unknown>;
    const parentTraceContext = this.extractTraceContext(jobEvent);

    return {
      event_type: eventType,
      event_id: this.generateId(),
      timestamp: event.timestamp,
      webhook_id: webhook.id,
      data: eventData,
      parent_trace_context: parentTraceContext,
    };
  }

  /**
   * Extract trace context from job event for webhook hierarchy
   */
  private extractTraceContext(jobEvent: Record<string, unknown>): { trace_id?: string; span_id?: string } | undefined {
    // Check for job completion trace context (from job completion spans)
    if (jobEvent.job_trace_id && jobEvent.job_span_id) {
      return {
        trace_id: jobEvent.job_trace_id as string,
        span_id: jobEvent.job_span_id as string
      };
    }

    // Check for workflow trace context (from workflow spans)  
    if (jobEvent.workflow_trace_id && jobEvent.workflow_span_id) {
      return {
        trace_id: jobEvent.workflow_trace_id as string,
        span_id: jobEvent.workflow_span_id as string
      };
    }

    return undefined;
  }

  /**
   * Extract relevant data from monitor event
   */
  private extractEventData(event: MonitorEvent): WebhookEventData {
    const data: WebhookEventData = {};

    // Common job event properties
    const jobEvent = event as unknown as Record<string, unknown>;
    if (jobEvent.job_id) data.job_id = jobEvent.job_id as string;
    if (jobEvent.job_type) data.job_type = jobEvent.job_type as string;
    if (jobEvent.worker_id) data.worker_id = jobEvent.worker_id as string;
    if (jobEvent.machine_id) data.machine_id = jobEvent.machine_id as string;

    // IMPORTANT: Include workflow fields in webhook payload
    if (jobEvent.workflow_id) data.workflow_id = jobEvent.workflow_id as string;
    if (jobEvent.workflow_priority) data.workflow_priority = jobEvent.workflow_priority as number;
    if (jobEvent.workflow_datetime) data.workflow_datetime = jobEvent.workflow_datetime as number;
    if (jobEvent.total_steps) data.total_steps = jobEvent.total_steps as number;
    if (jobEvent.current_step) data.current_step = jobEvent.current_step as number;

    // Job submission events
    if (event.type === 'job_submitted') {
      data.job_status = JobStatus.PENDING;
      data.priority = jobEvent.priority as number;
      data.payload = jobEvent.payload;
      data.requirements = jobEvent.requirements;
      data.customer_id = jobEvent.customer_id as string;
      data.submitted_at = jobEvent.created_at || jobEvent.timestamp;
    }

    // Status change events
    if (event.type === 'job_status_changed') {
      const statusEvent = event as JobStatusChangedEvent;
      data.job_status = statusEvent.new_status;
      data.old_status = statusEvent.old_status;
    }

    // Progress events
    if (event.type === 'update_job_progress') {
      const progressEvent = event as JobProgressEvent;
      data.progress = progressEvent.progress;
      // Note: stage is not available in JobProgressEvent, using optional property
      if ('stage' in progressEvent) {
        data.stage = (progressEvent as unknown as { stage: string }).stage;
      }
    }

    // Completion events
    if (event.type === 'complete_job') {
      const completeEvent = event as JobCompletedEvent;
      data.result = completeEvent.result;
      data.completed_at = completeEvent.completed_at;
    }

    // Failure events
    if (event.type === 'job_failed') {
      const failEvent = event as JobFailedEvent;
      data.error = failEvent.error;
      data.failed_at = failEvent.failed_at;
    }

    // Workflow completion events (system_stats with workflow_completed: true)
    if (event.type === 'system_stats' && jobEvent.workflow_completed) {
      logger.info(`üéØ [WEBHOOK] Extracting workflow completion data from Redis event:`, {
        workflow_id: jobEvent.workflow_id,
        status: jobEvent.status,
        has_outputs: !!jobEvent.outputs,
        outputs_count: jobEvent.outputs ? (jobEvent.outputs as any[]).length : 0,
      });

      // Include all workflow completion data from EMPROPS API
      data.timestamp = jobEvent.timestamp as number;
      data.status = jobEvent.status as string;
      data.completed_at = jobEvent.completed_at as string;
      data.verified = jobEvent.verified as boolean;
      data.message = jobEvent.message as string;
      
      // Include workflow details from EMPROPS
      if (jobEvent.workflow_details) {
        const workflowDetails = jobEvent.workflow_details as any;
        data.workflow_details = {
          id: workflowDetails.id,
          name: workflowDetails.name,
          job_type: workflowDetails.job_type,
          status: workflowDetails.status,
          progress: workflowDetails.progress,
          created_at: workflowDetails.created_at,
          completed_at: workflowDetails.completed_at,
        };
      }

      // Include outputs (image URLs, step results, etc.)
      if (jobEvent.outputs && Array.isArray(jobEvent.outputs)) {
        data.outputs = jobEvent.outputs;
        
        // Log output details for debugging
        logger.info(`‚úÖ [WEBHOOK] Including workflow outputs in webhook: ${(jobEvent.outputs as any[]).length} outputs`);
        (jobEvent.outputs as any[]).forEach((output: any, index: number) => {
          if (output.steps) {
            output.steps.forEach((step: any) => {
              if (step?.nodeResponse?.src) {
                logger.info(`   üñºÔ∏è Output ${index + 1} - ${step.nodeName}: ${step.nodeResponse.src}`);
              }
            });
          }
        });
      }

      logger.info(`üöÄ [WEBHOOK] Final workflow completion webhook data:`, {
        workflow_id: data.workflow_id,
        status: data.status,
        verified: data.verified,
        outputs_count: data.outputs ? (data.outputs as any[]).length : 0,
        has_workflow_details: !!data.workflow_details,
      });
    }

    return data;
  }

  /**
   * Queue webhook delivery
   */
  private queueDelivery(payload: WebhookPayload): void {
    this.deliveryQueue.push(payload);
    logger.debug(`Webhook queued for delivery: ${payload.webhook_id}`, {
      event_type: payload.event_type,
      job_id: payload.data.job_id,
    });
  }

  /**
   * Start processing delivery queue
   */
  private startProcessing(): void {
    this.processingInterval = setInterval(() => {
      this.processDeliveryQueue();
    }, 1000); // Process every second
  }

  /**
   * Process webhook delivery queue
   */
  private async processDeliveryQueue(): Promise<void> {
    if (this.isProcessing || this.deliveryQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      const payload = this.deliveryQueue.shift();
      if (!payload) return;
      await this.deliverWebhook(payload);
    } catch (error) {
      logger.error('Error processing webhook delivery queue', error);
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Deliver webhook with retry logic
   */
  private async deliverWebhook(payload: WebhookPayload, attemptNumber = 1): Promise<void> {
    const webhook = await this.getWebhook(payload.webhook_id);
    if (!webhook) {
      logger.warn(`Webhook not found for delivery: ${payload.webhook_id}`);
      return;
    }

    // Check if webhook is disconnected and should be skipped
    if (this.shouldSkipDisconnectedWebhook(webhook)) {
      logger.debug(`‚ö†Ô∏è Skipping delivery to disconnected webhook: ${webhook.id}`, {
        url: webhook.url,
        consecutive_failures: webhook.consecutive_failures,
        last_failure_at: webhook.last_failure_at,
      });
      return;
    }

    // DEBUG: Log webhook delivery attempt
    logger.info(`üöÄ [WEBHOOK DEBUG] Sending webhook`, {
      webhook_id: webhook.id,
      webhook_url: webhook.url,
      event_type: payload.event_type,
      event_id: payload.event_id,
      attempt_number: attemptNumber,
      job_id: payload.data?.job_id,
      workflow_id: payload.data?.workflow_id,
      payload_summary: {
        type: payload.event_type,
        timestamp: payload.timestamp,
        data_keys: Object.keys(payload.data || {}),
      },
    });

    const attempt: WebhookDeliveryAttempt = {
      id: this.generateId(),
      webhook_id: webhook.id,
      event_id: payload.event_id,
      event_type: payload.event_type,
      attempt_number: attemptNumber,
      timestamp: Date.now(),
      success: false,
    };

    // Declare variables outside try block for catch access
    const deliveryStartTime = Date.now();
    let timeoutId: NodeJS.Timeout | null = null;
    let traceResult = null;

    try {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        'User-Agent': 'EMP-Job-Queue-Webhook/1.0',
        'X-Webhook-Event': payload.event_type,
        'X-Webhook-ID': webhook.id,
        'X-Event-ID': payload.event_id,
        ...webhook.headers,
      };

      // Add HMAC signature if secret is configured
      if (webhook.secret) {
        const signature = await this.generateHmacSignature(payload, webhook.secret);
        headers['X-Webhook-Signature'] = signature;
      }

      // Use AbortController for timeout with native fetch
      const controller = new AbortController();
      timeoutId = setTimeout(() => controller.abort(), 30000);
      
      const response = await fetch(webhook.url, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);
      const deliveryDuration = Date.now() - deliveryStartTime;

      // üö® BIG PAYLOAD LOGGING: WEBHOOK DELIVERY SUCCESS  
      console.log(`\nüö®üö®üö® WEBHOOK: DELIVERY SUCCESS`);
      console.log(`üö® JOB: ${payload.data?.job_id || 'unknown'}`);
      console.log(`üö® WEBHOOK: ${webhook.id}`);
      console.log(`üö® EVENT TYPE: ${payload.event_type}`);
      console.log(`üö® HTTP STATUS: ${response.status}`);
      console.log(`üö® PARENT TRACE ID: ${payload.parent_trace_context?.trace_id || 'NONE'}`);
      console.log(`üö® PARENT SPAN ID: ${payload.parent_trace_context?.span_id || 'NONE'}`);
      console.log(`üö®üö®üö®\n`);

      // Send successful webhook delivery trace with parent context
      traceResult = await sendTrace('webhook.delivery', {
        webhook_id: webhook.id,
        webhook_url: webhook.url,
        event_type: payload.event_type,
        http_status: response.status.toString(),
        http_method: 'POST',
        attempt_number: attemptNumber.toString(),
        job_id: payload.data?.job_id || 'unknown',
        workflow_id: payload.data?.workflow_id || 'none',
        response_time_ms: deliveryDuration.toString(),
        status: response.ok ? 'success' : 'http_error',
        user_agent: 'emp-webhook-service',
      }, {
        duration_ms: deliveryDuration,
        status: response.ok ? 'ok' : 'error',
        parent_trace_id: payload.parent_trace_context?.trace_id,
        parent_span_id: payload.parent_trace_context?.span_id,
      });

      attempt.response_status = response.status;
      attempt.response_body = await response.text();
      attempt.success = response.ok;

      if (response.ok) {
        logger.info(`Webhook delivered successfully: ${webhook.id}`, {
          event_type: payload.event_type,
          job_id: payload.data.job_id,
          status: response.status,
        });
        
        // Send OTEL event for successful webhook delivery
        if (this.telemetryClient) {
          await this.telemetryClient.otel.counter('webhook.delivery.success', 1, {
            webhook_id: webhook.id,
            event_type: payload.event_type,
            http_status: response.status.toString(),
            attempt_number: attemptNumber.toString(),
            job_id: payload.data.job_id || 'unknown',
            workflow_id: payload.data.workflow_id || 'none',
          });
        }
        
        // Track successful delivery and reset failure count
        await this.recordWebhookSuccess(webhook.id);
        
        this.emit('webhook.delivered', { webhook, payload, attempt });
      } else {
        throw new Error(`HTTP ${response.status}: ${attempt.response_body}`);
      }
    } catch (error) {
      if (timeoutId) clearTimeout(timeoutId);
      attempt.error_message = error instanceof Error ? error.message : String(error);
      const deliveryDuration = Date.now() - deliveryStartTime;

      // üö® BIG PAYLOAD LOGGING: WEBHOOK DELIVERY FAILED
      console.log(`\nüö®üö®üö® WEBHOOK: DELIVERY FAILED`);
      console.log(`üö® JOB: ${payload.data?.job_id || 'unknown'}`);
      console.log(`üö® WEBHOOK: ${webhook.id}`);
      console.log(`üö® EVENT TYPE: ${payload.event_type}`);
      console.log(`üö® ERROR: ${attempt.error_message}`);
      console.log(`üö® PARENT TRACE ID: ${payload.parent_trace_context?.trace_id || 'NONE'}`);
      console.log(`üö® PARENT SPAN ID: ${payload.parent_trace_context?.span_id || 'NONE'}`);
      console.log(`üö®üö®üö®\n`);

      // Send failed webhook delivery trace with parent context
      await sendTrace('webhook.delivery', {
        webhook_id: webhook.id,
        webhook_url: webhook.url,
        event_type: payload.event_type,
        http_status: attempt.response_status?.toString() || 'timeout',
        http_method: 'POST',
        attempt_number: attemptNumber.toString(),
        job_id: payload.data?.job_id || 'unknown',
        workflow_id: payload.data?.workflow_id || 'none',
        response_time_ms: deliveryDuration.toString(),
        status: 'error',
        error_type: error instanceof Error ? error.constructor.name : 'UnknownError',
        error_message: attempt.error_message,
        user_agent: 'emp-webhook-service',
      }, {
        duration_ms: deliveryDuration,
        status: 'error',
        parent_trace_id: payload.parent_trace_context?.trace_id,
        parent_span_id: payload.parent_trace_context?.span_id,
      });

      logger.warn(`Webhook delivery failed: ${webhook.id} (attempt ${attemptNumber})`, {
        error: attempt.error_message,
        event_type: payload.event_type,
        job_id: payload.data.job_id,
      });
      
      // Send OTEL event for failed webhook delivery
      if (this.telemetryClient) {
        await this.telemetryClient.otel.counter('webhook.delivery.failure', 1, {
          webhook_id: webhook.id,
          event_type: payload.event_type,
          http_status: attempt.response_status?.toString() || 'error',
          attempt_number: attemptNumber.toString(),
          job_id: payload.data.job_id || 'unknown',
          workflow_id: payload.data.workflow_id || 'none',
          error_type: error instanceof Error ? error.constructor.name : 'UnknownError',
        });
      }

      // Retry logic
      const retryConfig = webhook.retry_config || {
        max_attempts: 3,
        initial_delay_ms: 1000,
        backoff_multiplier: 2,
        max_delay_ms: 30000,
      };
      if (attemptNumber < retryConfig.max_attempts) {
        const delay = Math.min(
          retryConfig.initial_delay_ms *
            Math.pow(retryConfig.backoff_multiplier, attemptNumber - 1),
          retryConfig.max_delay_ms
        );

        attempt.next_retry_at = Date.now() + delay;
        this.retryQueue.set(attempt.id, attempt);

        setTimeout(() => {
          this.retryQueue.delete(attempt.id);
          void this.deliverWebhook(payload, attemptNumber + 1);
        }, delay);

        logger.info(`Webhook retry scheduled: ${webhook.id} in ${delay}ms`, {
          attempt: attemptNumber + 1,
          max_attempts: retryConfig.max_attempts,
        });
      } else {
        logger.error(`Webhook delivery failed permanently: ${webhook.id}`, {
          attempts: attemptNumber,
          error: attempt.error_message,
        });
        
        // Track permanent failure and potentially auto-disconnect
        await this.recordWebhookFailure(webhook.id);
        
        this.emit('webhook.failed', { webhook, payload, attempt });
      }
    }

    // Record attempt in Redis
    await this.webhookStorage.recordDeliveryAttempt(attempt);
    this.emit('webhook.attempt', { webhook, payload, attempt });
  }

  /**
   * Generate HMAC signature for webhook payload
   */
  private async generateHmacSignature(payload: WebhookPayload, secret: string): Promise<string> {
    const crypto = await import('crypto');
    const body = JSON.stringify(payload);
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(body);
    return `sha256=${hmac.digest('hex')}`;
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `wh_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get webhook delivery statistics
   */
  async getDeliveryStats(webhookId?: string): Promise<{
    total_deliveries: number;
    successful_deliveries: number;
    failed_deliveries: number;
    retry_queue_size: number;
    pending_deliveries: number;
    last_delivery_at?: number;
    last_success_at?: number;
    last_failure_at?: number;
  }> {
    if (webhookId) {
      const stats = await this.webhookStorage.getWebhookStats(webhookId);
      return {
        total_deliveries: stats?.total_deliveries || 0,
        successful_deliveries: stats?.successful_deliveries || 0,
        failed_deliveries: stats?.failed_deliveries || 0,
        retry_queue_size: this.retryQueue.size,
        pending_deliveries: this.deliveryQueue.length,
        last_delivery_at: stats?.last_delivery_at,
        last_success_at: stats?.last_success_at,
        last_failure_at: stats?.last_failure_at,
      };
    } else {
      // Return aggregate stats
      return {
        total_deliveries: 0,
        successful_deliveries: 0,
        failed_deliveries: 0,
        retry_queue_size: this.retryQueue.size,
        pending_deliveries: this.deliveryQueue.length,
      };
    }
  }

  /**
   * Test webhook endpoint
   */
  async testWebhook(webhookId: string): Promise<boolean> {
    const webhook = await this.getWebhook(webhookId);
    if (!webhook) {
      throw new Error(`Webhook not found: ${webhookId}`);
    }

    const baseEventId = 'test_wh_' + Date.now() + '_' + this.generateId().slice(-9);
    const timestamp = Date.now();
    let allTestsSucceeded = true;

    // Send a test event for each event type the webhook is subscribed to
    for (const eventType of webhook.events) {
      const testPayload = this.createTestPayloadForEventType(
        eventType,
        baseEventId,
        webhookId,
        timestamp
      );

      try {
        await this.deliverWebhook(testPayload);
        logger.debug(`Test event sent successfully: ${eventType}`, { webhook_id: webhookId });
      } catch (error) {
        logger.error(`Test event failed: ${eventType}`, { webhook_id: webhookId, error });
        allTestsSucceeded = false;
      }
    }

    return allTestsSucceeded;
  }

  private createTestPayloadForEventType(
    eventType: string,
    baseEventId: string,
    webhookId: string,
    timestamp: number
  ): WebhookPayload {
    const testJobId = 'test_job_' + Date.now();
    const testWorkerId = 'test_worker_' + Math.random().toString(36).substr(2, 5);

    const basePayload = {
      event_id: `${baseEventId}_${eventType}`,
      timestamp,
      webhook_id: webhookId,
      metadata: {
        original_timestamp: timestamp,
        test_event: true,
      },
    };

    switch (eventType) {
      case 'job_submitted':
        return {
          ...basePayload,
          event_type: 'job_submitted',
          data: {
            job_id: testJobId,
            job_type: 'comfyui',
            priority: 100,
            payload: {
              test_data: 'Sample job submission for webhook testing',
              workflow: 'test_workflow.json',
            },
            requirements: {
              hardware: { gpu_memory_gb: 8 },
              models: ['test_model.safetensors'],
            },
            customer_id: 'test_customer_123',
            submitted_at: new Date(timestamp).toISOString(),
            status: 'pending',
          },
        };

      case 'update_job_progress':
        return {
          ...basePayload,
          event_type: 'update_job_progress',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            progress: 45,
            progress_message: 'Processing test workflow...',
            status: 'in_progress',
            current_step: 3,
            total_steps: 5,
            estimated_completion: new Date(timestamp + 60000).toISOString(),
          },
        };

      case 'complete_job':
        return {
          ...basePayload,
          event_type: 'complete_job',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            progress: 100,
            result: {
              output: 'Test job completed successfully',
              files: ['test_output.png'],
              duration_ms: 5000,
            },
            completed_at: new Date(timestamp).toISOString(),
            status: 'completed',
            message: 'Test job finished successfully',
          },
        };

      case 'job_failed':
        return {
          ...basePayload,
          event_type: 'job_failed',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            error: 'Test failure: Connection timeout during processing',
            failed_at: new Date(timestamp).toISOString(),
            status: 'failed',
            can_retry: false,
            retry_count: 3,
          },
        };

      case 'cancel_job':
        return {
          ...basePayload,
          event_type: 'cancel_job',
          data: {
            job_id: testJobId,
            worker_id: testWorkerId,
            cancelled_at: new Date(timestamp).toISOString(),
            reason: 'Test cancellation: User requested stop',
            cancelled_by: 'test_user',
          },
        };

      case 'worker_status':
        return {
          ...basePayload,
          event_type: 'worker_status',
          data: {
            worker_id: testWorkerId,
            machine_id: 'test_machine_' + Math.random().toString(36).substr(2, 5),
            status: 'busy',
            previous_status: 'idle',
            capabilities: ['comfyui', 'simulation'],
            current_job_id: testJobId,
          },
        };

      case 'machine_status':
        return {
          ...basePayload,
          event_type: 'machine_status',
          data: {
            machine_id: 'test_machine_' + Math.random().toString(36).substr(2, 5),
            status: 'ready',
            health: 'healthy',
            worker_count: 2,
            services: ['comfyui', 'simulation'],
            startup_time: 15000,
          },
        };

      default:
        // Fallback for unknown event types
        return {
          ...basePayload,
          event_type: eventType as WebhookEventType,
          data: {
            job_id: testJobId,
            test_event_type: eventType,
            message: `Test event for ${eventType}`,
          },
        };
    }
  }

  /**
   * Start periodic cache refresh from Redis
   */
  private startCacheRefresh(): void {
    this.refreshCache(); // Initial load
    this.cacheRefreshInterval = setInterval(() => {
      this.refreshCache();
    }, 30000); // Refresh every 30 seconds
  }

  /**
   * Refresh webhook cache from Redis
   */
  private async refreshCache(): Promise<void> {
    try {
      const activeWebhooks = await this.webhookStorage.getActiveWebhooks();

      // Clear and rebuild cache
      this.webhooksCache.clear();
      for (const webhook of activeWebhooks) {
        this.webhooksCache.set(webhook.id, webhook);
      }

      logger.debug(`Webhook cache refreshed: ${activeWebhooks.length} active webhooks`);
    } catch (error) {
      logger.error('Failed to refresh webhook cache:', error);
    }
  }

  /**
   * Get webhook storage instance (for direct access if needed)
   */
  getWebhookStorage(): WebhookRedisStorage {
    return this.webhookStorage;
  }

  /**
   * Get webhook delivery history
   */
  async getWebhookDeliveryHistory(webhookId: string, limit = 50) {
    return await this.webhookStorage.getWebhookDeliveryHistory(webhookId, limit);
  }

  /**
   * Get recent deliveries across all webhooks
   */
  async getRecentDeliveries(limit = 100) {
    return await this.webhookStorage.getRecentDeliveries(limit);
  }

  /**
   * Get webhook summary for dashboard
   */
  async getWebhookSummary() {
    return await this.webhookStorage.getWebhookSummary();
  }

  /**
   * Cleanup resources
   */
  destroy(): void {
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
    }
    if (this.cacheRefreshInterval) {
      clearInterval(this.cacheRefreshInterval);
    }
    if (this.throttleCleanupInterval) {
      clearInterval(this.throttleCleanupInterval);
    }
    this.webhooksCache.clear();
    this.deliveryQueue.length = 0;
    this.retryQueue.clear();
    this.lastProgressWebhookSent.clear(); // Clean up throttling map
    this.workflowTracker.clear(); // Clean up workflow tracking
  }
}
